<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"guoxb.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Driller 源码分析本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Driller源码分析02">
<meta property="og:url" content="http://guoxb.top/2023/09/18/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/index.html">
<meta property="og:site_name" content="GuoXB&#39;s Blog">
<meta property="og:description" content="Driller 源码分析本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918094103338.png">
<meta property="og:image" content="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918095559741.png">
<meta property="og:image" content="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918100557240.png">
<meta property="article:published_time" content="2023-09-18T15:33:41.000Z">
<meta property="article:modified_time" content="2023-10-03T13:14:01.633Z">
<meta property="article:author" content="郭小白QAQ">
<meta property="article:tag" content="普通人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918094103338.png">

<link rel="canonical" href="http://guoxb.top/2023/09/18/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Driller源码分析02 | GuoXB's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">GuoXB's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://guoxb.top/2023/09/18/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Driller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202303122318253.jpg">
      <meta itemprop="name" content="郭小白QAQ">
      <meta itemprop="description" content="精彩不亮丽，起落是无常">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GuoXB's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Driller源码分析02
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-18 23:33:41" itemprop="dateCreated datePublished" datetime="2023-09-18T23:33:41+08:00">2023-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-03 21:14:01" itemprop="dateModified" datetime="2023-10-03T21:14:01+08:00">2023-10-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Driller/" itemprop="url" rel="index"><span itemprop="name">Driller</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Driller-源码分析"><a href="#Driller-源码分析" class="headerlink" title="Driller 源码分析"></a>Driller 源码分析</h1><p>本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。</p>
<span id="more"></span>

<h2 id="0x01-run-driller-py-脚本分析"><a href="#0x01-run-driller-py-脚本分析" class="headerlink" title="0x01 run_driller.py 脚本分析"></a>0x01 run_driller.py 脚本分析</h2><p>这里，先放下在项目搭建时，我们用到的运行 driller 的脚本 run_driller.py ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> driller <span class="keyword">import</span> Driller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_input</span>(<span class="params">content, dest_dir, count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Saves a new input to a file where AFL can find it.</span></span><br><span class="line"><span class="string">    File will be named id:XXXXXX,driller (where XXXXXX is the current value of</span></span><br><span class="line"><span class="string">    count) and placed in dest_dir.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&#x27;id:%06d,driller&#x27;</span> % count</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dest_dir, name), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> destfile:</span><br><span class="line">        destfile.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage: %s &lt;binary&gt; &lt;fuzzer_output_dir&gt;&#x27;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">#将第一个参数也就是binary文件路径赋值给binary变量</span></span><br><span class="line">    <span class="comment">#将第二个参数也就是AFL output的文件夹赋值给fuzzer_dir,用来保存driller生成的input</span></span><br><span class="line">    _, binary, fuzzer_dir = sys.argv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Figure out directories and inputs</span></span><br><span class="line">    <span class="comment"># 获取AFL的bitmap值</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(fuzzer_dir, <span class="string">&#x27;fuzz_bitmap&#x27;</span>), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> bitmap_file:</span><br><span class="line">        fuzzer_bitmap = bitmap_file.read()</span><br><span class="line">    <span class="comment"># 获取AFL输入队列的目录</span></span><br><span class="line">    source_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line">    <span class="comment"># driller输出目录</span></span><br><span class="line">    dest_dir = os.path.join(fuzzer_dir, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;driller&#x27;</span>, <span class="string">&#x27;queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure destination exists</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(dest_dir)</span><br><span class="line">    <span class="keyword">except</span> os.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.errno != errno.EEXIST:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    seen = <span class="built_in">set</span>()  <span class="comment"># Keeps track of source files already drilled</span></span><br><span class="line">    <span class="comment"># driller/queue目录中的数量</span></span><br><span class="line">    count = <span class="built_in">len</span>(os.listdir(dest_dir))  <span class="comment"># Helps us name outputs correctly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Repeat forever in case AFL finds something new</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Go through all of the files AFL has generated, but only once each</span></span><br><span class="line">        <span class="keyword">for</span> source_name <span class="keyword">in</span> os.listdir(source_dir):</span><br><span class="line">            <span class="comment"># 如果 source_name 已经在 seen 中，表示已经处理过这个 input，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> source_name <span class="keyword">in</span> seen <span class="keyword">or</span> <span class="keyword">not</span> source_name.startswith(<span class="string">&#x27;id:&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 否则将其加入 seen 中，并将其作为 driller 的输入来做concolic execution</span></span><br><span class="line">            seen.add(source_name)</span><br><span class="line">            <span class="comment"># 获取该种子文件的内容</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(source_dir, source_name), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> seedfile:</span><br><span class="line">                seed = seedfile.read()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="comment"># 传入当前种子，和AFL的bitmap信息，调用Driller开始获取符号执行的生成的输入，并将这些输入都保存到指定目录中</span></span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Try a larger input too because Driller won&#x27;t do it for you</span></span><br><span class="line">            seed = seed + <span class="string">b&#x27;0000&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Drilling input: %s&#x27;</span> % seed)</span><br><span class="line">            <span class="keyword">for</span> _, new_input <span class="keyword">in</span> Driller(binary, seed, fuzzer_bitmap).drill_generator():</span><br><span class="line">                save_input(new_input, dest_dir, count)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>先看下脚本的大致功能：首先设置好需要用到的AFL的 queue 以及 bitmap 文件路径，及存储 driller 生成数据的路径，遍历 queue 中AFL认为 interesting 的 seeds，将其作为 driller 的输入进行 concolic execution，然后保存 driller 生成的数据到指定目录供 AFL 使用。</p>
<p>在 main 函数中，最关键的部分就是 <code>Driller()</code> 类以及其成员方法 <code>drill_generator()</code>，所以我们暂时只看 Driller 中发挥关键作用的部分（即这个 <code>drill_generate()</code> ，其他的诸如 <code>shellphuzz</code>，<code>Fuzzer</code> 等，都是对已有工具的包装，是一个 wrapper ，留着以后再分析。</p>
<h2 id="0x02-driller-关键函数源码分析"><a href="#0x02-driller-关键函数源码分析" class="headerlink" title="0x02 driller 关键函数源码分析"></a>0x02 driller 关键函数源码分析</h2><p><strong>Driller</strong> 源码地址为：<a target="_blank" rel="noopener" href="https://github.com/shellphish/driller">https://github.com/shellphish/driller</a></p>
<p><code>Driller</code> 类以及成员函数 <code>drill_generate()</code> 定义在 <code>driller_main.py</code> 文件中，类中主要函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driller</span>(<span class="title class_ inherited__">object</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Driller object, symbolically follows an input looking for new state transitions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, binary, input_str, fuzz_bitmap=<span class="literal">None</span>, tag=<span class="literal">None</span>, redis=<span class="literal">None</span>, hooks=<span class="literal">None</span>, argv=<span class="literal">None</span></span>)</span><br><span class="line">    <span class="comment"># DRILLING</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drill_generator</span>(<span class="params">self</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_drill_input</span>(<span class="params">self</span>)</span><br><span class="line">    <span class="comment"># EXPLORE</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_symbolic_explorer_stub</span>(<span class="params">self, state</span>)</span><br><span class="line">    <span class="comment"># UTILS</span></span><br><span class="line"><span class="meta">    @static</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_concretizations</span>(<span class="params">state</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_writeout</span>(<span class="params">self, prev_addr, state</span>)</span><br></pre></td></tr></table></figure>

<p>我们先看类的构造函数 <code>__init__()</code> 进行的初始化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, binary, input_str, fuzz_bitmap=<span class="literal">None</span>, tag=<span class="literal">None</span>, redis=<span class="literal">None</span>, hooks=<span class="literal">None</span>, argv=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param binary     : The binary to be traced.</span></span><br><span class="line"><span class="string">        :param input_str  : Input string to feed to the binary.</span></span><br><span class="line"><span class="string">        :param fuzz_bitmap: AFL&#x27;s bitmap of state transitions (defaults to empty).</span></span><br><span class="line"><span class="string">        :param redis      : redis.Redis instance for coordinating multiple Driller instances.</span></span><br><span class="line"><span class="string">        :param hooks      : Dictionary of addresses to simprocedures.</span></span><br><span class="line"><span class="string">        :param argv       : Optionally specify argv params (i,e,: [&#x27;./calc&#x27;, &#x27;parm1&#x27;]),</span></span><br><span class="line"><span class="string">                            defaults to binary name with no params.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.binary      = binary</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Redis channel identifier.</span></span><br><span class="line">        self.identifier  = os.path.basename(binary) <span class="comment">#self.identifier = self.binary_name</span></span><br><span class="line">        self.<span class="built_in">input</span>       = input_str</span><br><span class="line">        self.fuzz_bitmap = fuzz_bitmap</span><br><span class="line">        self.tag         = tag</span><br><span class="line">        self.redis       = redis</span><br><span class="line">        self.argv = argv <span class="keyword">or</span> [binary]</span><br><span class="line"></span><br><span class="line">        self.base = os.path.join(os.path.dirname(__file__), <span class="string">&quot;..&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The simprocedures.要hook的函数</span></span><br><span class="line">        self._hooks = &#123;&#125; <span class="keyword">if</span> hooks <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> hooks</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The driller core, which is now an exploration technique in angr.</span></span><br><span class="line">        <span class="comment"># angr中的探索技术</span></span><br><span class="line">        self._core = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Start time, set by drill method.开始时间</span></span><br><span class="line">        self.start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set of all the generated inputs.生成的input的集合</span></span><br><span class="line">        self._generated = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set the memory limit specified in the config.</span></span><br><span class="line">        <span class="keyword">if</span> config.MEM_LIMIT <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            resource.setrlimit(resource.RLIMIT_AS, (config.MEM_LIMIT, config.MEM_LIMIT))</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        使用 resource.RLIMIT_AS 来查询或设置进程的地址空间大小限制（内存限制）</span></span><br><span class="line"><span class="string">        eg: # 设置内存限制（单位：字节）</span></span><br><span class="line"><span class="string">        resource.setrlimit(resource.RLIMIT_AS, (1024 * 1024 * 256, 1024 * 1024 * 512))  # 设置软限制为256MB，硬限制为512MB</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        l.debug(<span class="string">&quot;[%s] drilling started on %s.&quot;</span>, self.identifier, time.ctime(self.start_time))</span><br></pre></td></tr></table></figure>

<p>可以看到，前三个参数就是我们在 run_driller.py 脚本中传入的三个参数，分别是 bianry 文件的路径、binary 文件接受的输入（也就是 seeds）、AFL 的 bitmap 文件内容。后面参数的作用查看注释即可。在 <code>__init__()</code> 函数中，首先对类中的公有或私有(以_开头)属性进行赋值，并进行一些配置项的设置。</p>
<p>接下来，我们看脚本中调用的 <code>drill_generator()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">drill_generator</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A generator interface to the actual drilling.</span></span><br><span class="line"><span class="string">        真正drilling的生成器接口</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set up alarm for timeouts.</span></span><br><span class="line">        <span class="comment"># 设置超时警报</span></span><br><span class="line">        <span class="keyword">if</span> config.DRILL_TIMEOUT <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            signal.alarm(config.DRILL_TIMEOUT)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._drill_input():</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>可以看到，run_driller.py 脚本中调用的函数是一个生成器函数，在内部不断调用类私有方法 <code>self._drill_input()</code> 来获取 driller 生成的输入，并不断通过 yield 语句输出。</p>
<p>所以真正发挥作用的是<a id="_drill_input"> <code>self._drill_input()</code> </a>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_drill_input</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Symbolically step down a path with a tracer, trying to concretize inputs for unencountered</span></span><br><span class="line"><span class="string">        state transitions.</span></span><br><span class="line"><span class="string">        沿着tracer给出的path一步一步符号化，尝试将未遇到的状态转换的输入具体化，即求解出未遇到状态的输入</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize the tracer</span></span><br><span class="line">        <span class="comment"># 实例化 QEMURunner 类对象</span></span><br><span class="line">        r = tracer.qemu_runner.QEMURunner(self.binary, self.<span class="built_in">input</span>, argv=self.argv)</span><br><span class="line">        <span class="comment"># 创建 angr project</span></span><br><span class="line">        p = angr.Project(self.binary)</span><br><span class="line">        <span class="comment"># 对传入的需要 hook 的函数做 hook 操作</span></span><br><span class="line">        <span class="keyword">for</span> addr, proc <span class="keyword">in</span> self._hooks.items():</span><br><span class="line">            p.hook(addr, proc)</span><br><span class="line">            l.debug(<span class="string">&quot;Hooking %#x -&gt; %s...&quot;</span>, addr, proc.display_name)</span><br><span class="line">        <span class="comment"># 判断待分析的binary的操作系统类型</span></span><br><span class="line">        <span class="keyword">if</span> p.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">            p.simos.syscall_library.update(angr.SIM_LIBRARIES[<span class="string">&#x27;cgcabi_tracer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            s = p.factory.entry_state(stdin=angr.SimFileStream, flag_page=r.magic, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 除了 cgc 之外的，全部使用full_init_state获取初始状态。</span></span><br><span class="line">            <span class="comment"># 将程序的标准输入流stdin符号化，设置mode为&#x27;tracing&#x27;</span></span><br><span class="line">            <span class="comment"># &#x27;tracing&#x27;：这是一种常见的模式，用于创建一个用于路径跟踪（path tracing）的符号状态。在这种模式下，符号状态会记录路径执行的信息，包括指令和内存访问。这对于分析程序的执行路径非常有用。</span></span><br><span class="line">            s = p.factory.full_init_state(stdin=angr.SimFileStream, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">        <span class="comment"># 预先给符号执行添加约束，preconstrainer添加的约束可以在后面删除</span></span><br><span class="line">        <span class="comment"># preconstrain_file方法用于为文件设置约束，将s.posix.stdin(符号执行的输入)设置为self.input(传递给Driller的testcase)</span></span><br><span class="line">        <span class="comment"># True表示将文件内容解析为具体的数据值。这里应该是就是实现angr concolic execution的方式</span></span><br><span class="line">        s.preconstrainer.preconstrain_file(self.<span class="built_in">input</span>, s.posix.stdin, <span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#save_unset 将不可满足的状态存入“unsat存储”，hierarchy表示一个StateHierarchy对象，来跟踪状态之间的关系。</span></span><br><span class="line">        simgr = p.factory.simulation_manager(s, save_unsat=<span class="literal">True</span>, hierarchy=<span class="literal">False</span>, save_unconstrained=r.crash_mode)</span><br><span class="line">        <span class="comment"># 实例化一个Tracer类对象</span></span><br><span class="line">        <span class="comment"># trace 参数指定了要跟踪的执行路径，探测器将按照提供的执行路径来执行程序</span></span><br><span class="line">        <span class="comment"># crash_addr 参数指定了程序崩溃的地址，如果程序在执行过程中崩溃，探测器将停止跟踪，并记录crash state到“crashed” stash中</span></span><br><span class="line">        <span class="comment"># copy_states=True：这个参数控制是否在跟踪过程中复制符号状态。如果设置为 True，则探测器会为每个跟踪步骤创建符号状态的副本，以防止状态共享和互相干扰。</span></span><br><span class="line">        <span class="comment"># follow_unsat 参数控制是否跟踪不可满足的路径。如果设置为 True，则探测器将继续跟踪路径，即使遇到不可满足的约束条件。</span></span><br><span class="line">        t = angr.exploration_techniques.Tracer(trace=r.trace, crash_addr=r.crash_addr, copy_states=<span class="literal">True</span>, follow_unsat=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        self._core = angr.exploration_techniques.DrillerCore(trace=r.trace, fuzz_bitmap=self.fuzz_bitmap)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        exploration_techniques:</span></span><br><span class="line"><span class="string">        Tracer():An exploration technique that follows an angr path with a concrete input.</span></span><br><span class="line"><span class="string">                 The tracing result is the state at the last address of the trace, which can be found in the &#x27;traced&#x27; stash.</span></span><br><span class="line"><span class="string">                 If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the &#x27;crashed&#x27; stash.</span></span><br><span class="line"><span class="string">        Oppologist():The Oppologist is an exploration technique that forces uncooperative code through qemu.</span></span><br><span class="line"><span class="string">        DrillerCore():An exploration technique that symbolically follows an input looking for new state transitions.</span></span><br><span class="line"><span class="string">                      It has to be used with Tracer exploration technique. Results are put in &#x27;diverted&#x27; stash.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        simgr.use_technique(t)</span><br><span class="line">        simgr.use_technique(angr.exploration_techniques.Oppologist())</span><br><span class="line">        simgr.use_technique(self._core)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置对内存、寄存器符号化操作的阈值</span></span><br><span class="line">        self._set_concretizations(simgr.one_active)</span><br><span class="line"></span><br><span class="line">        l.debug(<span class="string">&quot;Drilling into %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line">        l.debug(<span class="string">&quot;Input is %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> simgr.active <span class="keyword">and</span> simgr.one_active.<span class="built_in">globals</span>[<span class="string">&#x27;trace_idx&#x27;</span>] &lt; <span class="built_in">len</span>(r.trace) - <span class="number">1</span>:</span><br><span class="line">            simgr.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check here to see if a crash has been found.</span></span><br><span class="line">            <span class="keyword">if</span> self.redis <span class="keyword">and</span> self.redis.sismember(self.identifier + <span class="string">&#x27;-finished&#x27;</span>, <span class="literal">True</span>):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># diverted 应该是发生状态转移</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;diverted&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> simgr.stashes:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 当检测到状态转移时,弹出状态 这里的diverted 是在DillerCore探索策略中的step方法中添加的</span></span><br><span class="line">            <span class="keyword">while</span> simgr.diverted:</span><br><span class="line">                state = simgr.diverted.pop(<span class="number">0</span>)</span><br><span class="line">                l.debug(<span class="string">&quot;Found a diverted state, exploring to some extent.&quot;</span>)</span><br><span class="line">                <span class="comment"># 首先调用_writeout来求解</span></span><br><span class="line">                w = self._writeout(state.history.bbl_addrs[-<span class="number">1</span>], state)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> w</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> self._symbolic_explorer_stub(state):</span><br><span class="line">                    <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>首先我们看到，该函数也是一个生成器函数，通过 yield 语句来返回生成的值，然后我们从头开始一点点分析该函数的功能。</p>
<p>函数首先实例化了一个 <code>QEMURunner</code> 类对象 <code>r</code>，该类定义在 angr 中的一个单独的模块 <code>Tracer</code> 中，该模块源码地址为：<a target="_blank" rel="noopener" href="https://github.com/angr/tracer">https://github.com/angr/tracer</a></p>
<hr>
<h3 id="Tracer-模块"><a href="#Tracer-模块" class="headerlink" title="Tracer 模块"></a>Tracer 模块</h3><blockquote>
<p>This package is in a bit of a complicated transition phase - it originally housed the concolic tracing helpers for angr, but those pieces of code have since been merged into angr proper</p>
</blockquote>
<p>进入仓库，可以看到其 Readme 给的信息很少，我们主要看看 driller 使用了 tracer 模块中的哪些 function，在项目中 grep 下，发现只有 driller_main.py 文件中使用了 tracer ，也就是实例化一个 <code>QEMURunner</code> 类对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = tracer.qemu_runner.QEMURunner(self.binary, self.<span class="built_in">input</span>, argv=self.argv)</span><br></pre></td></tr></table></figure>

<p>接下来我们对对象 <code>r</code> 进行分析。在 driller_main.py 中，总共使用了 <code>r</code> 对象里的四个属性：<code>r.trace</code>、<code>r.magic</code>、<code>r.crash_mode</code>、<code>r.crash_addr</code>。</p>
<p>QEMURunner() 类的构造函数大致功能为，将传入的 self.input 作为 self.binary 的输入，使用Qemu模拟执行 self.input，self.argv 是其命令行参数。（具体可查看源码，对于分析 driller 只需要理解大致功能就够用了）</p>
<p><code>r.trace</code>：记录了对于此次输入 self.input 程序执行的基本块的序列（应该是Qemu记录到的，跟angr一样，对于call也会划分基本块）</p>
<p><code>r.crash_mode</code>：记录此次输入执行后是否发生了crash</p>
<p><code>r.carsh_addr</code>：记录此次输入执行后发生crash的 faulting 地址</p>
<p><code>r.magic</code>：源码注释中说，作用是来保持符号跟踪与其 dynamic counterpart 遵循相同的路径，这个暂时没太看懂。</p>
<p><code>r.trace</code>：以示例程序 buggy 来举例，编译时注意开下-no-pie</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import tracer</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = tracer.qemu_runner.QEMURunner(<span class="string">&quot;./buggy&quot;</span>,b<span class="string">&quot;sth&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> addr <span class="keyword">in</span> r.trace:</span></span><br><span class="line">		if (addr&lt;0x4000000000): #这里说明一下,r.tarce记录程序内所有基本块的地址，但我们只关注text中的addr，做粗略过滤</span><br><span class="line">			print(hex(addr))</span><br><span class="line">···</span><br><span class="line">0x4005a7</span><br><span class="line">0x4004b0</span><br><span class="line">0x4005f0</span><br><span class="line">0x400629</span><br><span class="line">0x400490</span><br><span class="line">0x400635</span><br><span class="line">0x40064e</span><br><span class="line">0x400570</span><br><span class="line">0x400579</span><br><span class="line">0x400500</span><br><span class="line">0x400528</span><br><span class="line">0x400582</span><br><span class="line">0x4006c4</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span>		</span><br></pre></td></tr></table></figure>

<p>Tracer 模块暂时介绍到这里就够分析 driller 用了。</p>
<hr>
<p>我们看完 Tracer 继续往下看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(self.binary)</span><br><span class="line"><span class="keyword">for</span> addr, proc <span class="keyword">in</span> self._hooks.items():</span><br><span class="line">	p.hook(addr, proc)</span><br><span class="line">    l.debug(<span class="string">&quot;Hooking %#x -&gt; %s...&quot;</span>, addr, proc.display_name)</span><br><span class="line"><span class="keyword">if</span> p.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">    p.simos.syscall_library.update(angr.SIM_LIBRARIES[<span class="string">&#x27;cgcabi_tracer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    s = p.factory.entry_state(stdin=angr.SimFileStream, flag_page=r.magic, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s = p.factory.full_init_state(stdin=angr.SimFileStream, mode=<span class="string">&#x27;tracing&#x27;</span>)</span><br><span class="line">s.preconstrainer.preconstrain_file(self.<span class="built_in">input</span>, s.posix.stdin, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码也很好看，首先创建一个待符号执行的 binary 的 angr Project 为 <code>p</code> 。然后根据初始化Driller类成员时传入的 hooks（要 hook 的函数）在项目 <code>p</code> 中对其进行 hook 操作。接着，判断程序的目标操作系统，根据其是否为 cgc 类型来确定程序开始符号执行时的程序状态（状态预设），当 binary 为非 cgc 程序时，将调用 <code>full_inti_state</code> 状态构造函数。这里对是否是 cgc 程序的判断相当于是对 cgc 程序单独做了额外的优化。最后，调用 preconstrainer_file 方法对文件预先设置约束，将 <code>s.posix.stdin</code> ( concolic 执行的输入)设置为 <code>self.input</code> (传递给 Driller 的seed)，True 参数表示将文件内容解析为具体的数据值。</p>
<p>接下来，就是重要的地方了，<code>exploration_techniques</code> 和 <code>use_techniques</code> ，关于这两个的介绍，我在网上找了好久的博客都没有找到详细介绍的，而且我对 angr 是如何使用 <code>exploration_techniques</code> 尤其是多个并用非常疑惑和好奇，问了ChatGPT也看的比较懵，所以还是得自己一点一点啃源码理解。继续看 <code>self._dirll_input()</code> 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">simgr = p.factory.simulation_manager(s, save_unsat=<span class="literal">True</span>, hierarchy=<span class="literal">False</span>, save_unconstrained=r.crash_mode)</span><br><span class="line">t = angr.exploration_techniques.Tracer(trace=r.trace, crash_addr=r.crash_addr, copy_states=<span class="literal">True</span>, follow_unsat=<span class="literal">True</span>)</span><br><span class="line">self._core = angr.exploration_techniques.DrillerCore(trace=r.trace, fuzz_bitmap=self.fuzz_bitmap)</span><br><span class="line">simgr.use_technique(t)</span><br><span class="line">simgr.use_technique(angr.exploration_techniques.Oppologist())</span><br><span class="line">simgr.use_technique(self._core)</span><br></pre></td></tr></table></figure>

<p>这里我最好奇的点是，这些探索技术是如何运用到探索过程中的，如果之前看过 angr exploration_techniques 模块的源码，会发现，几乎每一个类中都有 <code>step()</code> 方法，只执行<code>simgr.step()</code> 的情况下，这些方法是如何跟 simulation_manage 类中的 <code>step()</code> 方法结合协作选择下一个状态呢？接下来，我们就来一点一点分析。</p>
<p>首先，我们通过 <code>simulation_manager()</code> 方法得到一个 SimulationManager 对象 simgr，用来管理我们后续符号执行得到的状态。</p>
<p>接下来，就是创建所需要的 exploration_techniques 对象，driller 一共创建了三个，分别为：</p>
<ul>
<li><p><code>Tracer()</code>：An exploration technique that follows an angr path with a concrete input. The tracing result is the state at the last address of the trace, which can be found in the ‘traced’ stash. If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the ‘crashed’ stash.</p>
</li>
<li><p><code>Oppologist()</code>：The Oppologist is an exploration technique that forces uncooperative code through qemu.</p>
</li>
<li><p><code>DrillerCore()</code>：An exploration technique that symbolically follows an input looking for new state transitions. It has to be used with Tracer exploration technique. Results are put in ‘diverted’ stash.</p>
</li>
</ul>
<p>接下来，simgr 分别调用 <code>use_technique()</code> 函数来应用创建的探索技术。<code>use_technique()</code> 函数源码在 simulation_manage.py 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_technique</span>(<span class="params">self, tech</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Use an exploration technique with this SimulationManager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Techniques can be found in :mod:`angr.exploration_techniques`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param tech:    An ExplorationTechnique object that contains code to modify</span></span><br><span class="line"><span class="string">                        this SimulationManager&#x27;s behavior.</span></span><br><span class="line"><span class="string">        :type tech:     ExplorationTechnique</span></span><br><span class="line"><span class="string">        :return:        The technique that was added, for convenience</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tech, ExplorationTechnique):</span><br><span class="line">            <span class="keyword">raise</span> SimulationManagerError</span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">XXX:</span> as promised</span></span><br><span class="line">        tech.project = self._project</span><br><span class="line">        tech.setup(self)</span><br><span class="line">        <span class="comment"># **tech._get_hooks() 理解：是一个参数解包操作，将tech._get_hooks()函数返回的字典作为关键字参数传递给HookSet.install_hooks()</span></span><br><span class="line">        <span class="comment"># _get_hooks()函数返回一个字典，其中包含了exploration_techniques类中定义的一组钩子函数。这些钩子函数是通过检查_hook_list列表中的每个元素，并调用_is_overriden方法来确定是否被子类重写而生成的。</span></span><br><span class="line">        <span class="comment"># 简单来说也就是返回应用的tech技术中，在_hook_list = (&quot;step&quot;, &quot;filter&quot;, &quot;selector&quot;, &quot;step_state&quot;, &quot;successors&quot;)列表里面的，重新实现的函数。</span></span><br><span class="line">        </span><br><span class="line">        HookSet.install_hooks(self, **tech._get_hooks())</span><br><span class="line">        self._techniques.append(tech)</span><br><span class="line">        <span class="keyword">return</span> tech</span><br></pre></td></tr></table></figure>

<p>可以看到，函数首先判断传入的参数 tech 是不是 ExplorationTechnique类型，然后调用该探索方法内置的 <code>setup()</code> 函数来做初始化（setup）操作。具体每一个探索技术的 setup() 函数的细节，这里先暂时跳过，等后边再开一节详细介绍。</p>
<p>然后调用 <code>HookSet</code> 类的静态方法 <code>install_hooks()</code> 函数来进行 hook ，这里就是 angr 如何利用多个探索技术的关键所在。我们首先解释下参数，然后再来看 HookSet 类及其静态方法的源码：</p>
<p>install_hooks 函数参数 <code>**tech._get_hooks()</code> 是一个参数解包操作，tech 是一个实例化的探索方法对象，<code>tech._get_hooks()</code> 函数是类的一个私有方法，定义在 angr exploration_techniques 目录下的 <code>__init__.py</code> 文件中，该文件定义了一个基类 <code>ExplorationTechnique</code> ，angr 自带的或自定义的探索方法均继承自这个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExplorationTechnique</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    An otiegnqwvk is a set of hooks for a simulation manager that assists in the implementation of new techniques in</span></span><br><span class="line"><span class="string">    symbolic exploration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: choose actual name for the functionality (techniques? strategies?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Any number of these methods may be overridden by a subclass.</span></span><br><span class="line"><span class="string">    To use an exploration technique, call ``simgr.use_technique`` with an *instance* of the technique.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is the master list of hook functinos</span></span><br><span class="line">    _hook_list = (<span class="string">&quot;step&quot;</span>, <span class="string">&quot;filter&quot;</span>, <span class="string">&quot;selector&quot;</span>, <span class="string">&quot;step_state&quot;</span>, <span class="string">&quot;successors&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_hooks</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;name: <span class="built_in">getattr</span>(self, name) <span class="keyword">for</span> name <span class="keyword">in</span> self._hook_list <span class="keyword">if</span> self._is_overriden(name)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_overriden</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self, name).__code__ <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(ExplorationTechnique, name).__code__</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里 <code>_get_hooks</code> 函数返回了一个字典，字典包含了在 <code>_hook_list</code> 中定义的钩子函数的名称和对应的方法。<code>_get_hooks</code> 函数通过列表推导式遍历 <code>_hook_list</code> 列表中的每个函数名称，并通过 <code>_is_overridden()</code> 函数检查该名称是否在当前对象中被覆写，如果被覆写了，也就说明被 hook 了，将其加入到字典中。</p>
<p><code>_is_overridden()</code> 函数将当前对象 tech 中相应函数的 <code>__code__</code> 属性与基类（父类 ExplorationTechnique）中对应函数的 <code>__code__</code> 属性做对比，判断两者是否相等，若不相同，则表示对应函数被覆写，返回 <code>True</code> 。</p>
<p>解释完 <code>HookSet.install_hooks()</code> 函数的参数，我们来看下函数的实现，函数定义在 angr misc 目录下的 hookset.py 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HookSet</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A HookSet is a static class that provides the capability to apply many hooks to an object.</span></span><br><span class="line"><span class="string">    一个静态类，提供对象应用多个hooks的能力</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install_hooks</span>(<span class="params">target, **hooks</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Given the target `target`, apply the hooks given as keyword arguments to it.</span></span><br><span class="line"><span class="string">        If any targeted method has already been hooked, the hooks will not be overridden but will instead be pushed</span></span><br><span class="line"><span class="string">        into a list of pending hooks. The final behavior should be that all hooks call each other in a nested stack.</span></span><br><span class="line"><span class="string">        如果任何想要hook的目标方法已经被hook了，那么不会覆盖以前hook的函数，而是把新的hook插入到一个pending hooks列表里。</span></span><br><span class="line"><span class="string">        最终的行为应该是所有钩子在嵌套堆栈中相互调用。</span></span><br><span class="line"><span class="string">        :param target:  Any object. Its methods named as keys in `hooks` will be replaced by `HookedMethod` objects.</span></span><br><span class="line"><span class="string">        :param hooks:   Any keywords will be interpreted as hooks to apply. Each method named will hooked with the</span></span><br><span class="line"><span class="string">                        corresponding function value.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> name, hook <span class="keyword">in</span> hooks.items():</span><br><span class="line">            func = <span class="built_in">getattr</span>(target, name)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(func, HookedMethod):</span><br><span class="line">                func = HookedMethod(func)   <span class="comment">#这里将func实例化为HookedMethod对象，当在后面调用到func时，就会用到__call__魔法方法，将示例对象func作为函数，函数体就是__call__方法里的程序</span></span><br><span class="line">                <span class="built_in">setattr</span>(target, name, func) <span class="comment">#将新来的方法设置为栈顶</span></span><br><span class="line">            func.pending.append(hook)</span><br></pre></td></tr></table></figure>

<p>可以看到，函数遍历传入的 hooks 字典，并判断每一个字典内的每一个函数是否是 <code>HookedMethod</code> 类的示例对象。如果不是，就把通过<code>getattr</code> 函数获取到的对象方法作为参数来实例化一个 <code>HookedMethod</code> 对象。然后调用 <code>setattr()</code> 函数将原始的 simgr 的方法（比如 step ）给 hook 成 Hooked Method(func) 类型的方法。最后将该函数方法添加到 HookedMethod 类的实例化对象 func 的属性 pending 列表中。</p>
<p>我们接下来看一下 HookedMethod 类的源码，跟 HookSet 定义在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HookedMethod</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    HookedMethod is a callable object which provides a stack of nested hooks.</span></span><br><span class="line"><span class="string">    HookedMethod 是一个可调用对象，它提供了一堆嵌套的钩子</span></span><br><span class="line"><span class="string">    :param func:    The bottom-most function which provides the original functionality that is being hooked</span></span><br><span class="line"><span class="string">                    最底层的函数提供被挂钩的原始功能</span></span><br><span class="line"><span class="string">    :ivar func:     Same as the eponymous parameter</span></span><br><span class="line"><span class="string">    :ivar pending:  The stack of hooks that have yet to be called. When this object is called, it will pop the last</span></span><br><span class="line"><span class="string">                    function in this list and call it. The function should call this object again in order to request</span></span><br><span class="line"><span class="string">                    the functionality of the original method, at which point the pop-dispatch mechanism will run</span></span><br><span class="line"><span class="string">                    recursively until the stack is exhausted, at which point the original function will be called.</span></span><br><span class="line"><span class="string">                    When the call returns, the hook will be restored to the stack.</span></span><br><span class="line"><span class="string">                    尚未调用的hook堆栈。当调用该对象时，它将弹出该列表中的最后一个函数并调用它。该函数应该再次调用该对象，</span></span><br><span class="line"><span class="string">                    以请求原始方法的功能，此时，pop-dispatch机制将运行直到堆栈耗尽，这时将调用原始函数。</span></span><br><span class="line"><span class="string">                    当调用返回时，hook将被恢复到堆栈中</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.pending = [] <span class="comment"># 初始化 pending 列表</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment"># 递归x 嵌套执行</span></span><br><span class="line">    <span class="comment"># 接下来对主要对step函数做修改，输出信息，来看递归的具体过程</span></span><br><span class="line">    <span class="comment"># 这里会先输出很多orig step is called，猜测是初始化到full_init_state时调用的，猜测是对的，在use_technique完毕之后，才开始使用探索策略中的step来探索。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pending:</span><br><span class="line">            current_hook = self.pending.pop()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = current_hook(self.func.__self__, *args, **kwargs) <span class="comment">#&lt;----嵌套执行处</span></span><br><span class="line">            <span class="comment"># 无论是否发生异常，均会执行finally</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.pending.append(current_hook)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure>

<p>这里边最重要的是魔法方法 <code>__call__</code> ，当一个对象实现了 <code>__call__</code> 方法时，它可以被当作函数一样使用，通过在对象后面加上括号来调用。这种方式类似于调用函数，实际上是调用了对象的 <code>__call__</code> 方法。在上面，我们通过 <code>setattr</code> 函数设置完之后，当在 simgr 执行符号执行探索 binary 的过程中，调用被 hook 的方法时，实际上就是调用这里的 <code>__call__</code> 方法。</p>
<p>当我们通过 use_teachnique() 函数使用多个 exploration_techniques 时，向 pending 列表中添加的每一个方法都是 HookedMethod 类对象。在被调用时都是调用 <code>__call__</code> ，所以，这时候应该能反应过来，这里其实类似是一个递归函数。（其实应该是嵌套执行，这里把嵌套跟递归搞混了）</p>
<p>我们可以通过修改 angr 包的源码来做一下简单验证，<a href="#_drill_input"><code>_drill_input</code></a> 中主要用到了 <code>step</code> 函数来进行符号执行探索，所以就以 <code>step</code> 函数为例做验证：</p>
<p>安装好的 angr 包所在的目录为：<code>/usr/local/lib/python3.5/dist-packages/angr/</code>，我们分别对 exploration_techniques 目录下用到的三种探索技术 Tracer 、Oppologist、DrillerCore 中的 step 方法，以及angr 原始的 step 方法（位于angr&#x2F;sim_manager.py）添加一行代码，输出打印信息（以 DrillerCore 为例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;driller_core step is called!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918094103338.png" alt="image-20230918094103338"></p>
<p>同时在 <code>__call__</code> 函数所在的 hookset.py 文件中定义一个全局变量来输出递归层数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line">···</span><br><span class="line">calss Hookset:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> n</span><br><span class="line">        <span class="keyword">if</span> self.pending:</span><br><span class="line">            current_hook = self.pending.pop</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;current_hook is &quot;</span>,current_hook)</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Entering , n = &quot;</span>,n)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = current_hook(self.func.__self__, *args，**kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Exiting, n = &quot;</span>,n)</span><br><span class="line">                self.pending.append(current_hook)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.func(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>修改完后，我们实际运行来验证一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ./run_driller.py ./buggy workdir/output/fuzzer-master</span><br></pre></td></tr></table></figure>

<p>注意：运行时需要保证 AFL 已经运行一段时间，生成了 ouput 目录，这里我是直接进入 docker 容器的 bash 跑的命令。</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918095559741.png" alt="image-20230918095559741"></p>
<p>从运行结果，我们可以看到，确实如刚才看源码分析的一致，这是一个递归（应该嵌套执行）的过程。通过我们打印的被 hook 的函数，我们也能看到除了 step 外，还有其他 hook_list 中的函数也被调用。以step为例，angr 按照 <code>use_techniques()</code> 函数中加载 exploration_technique 的逆顺序，来一层一层嵌套执行 step 函数，最后再调用最原始的 step() 函数。</p>
<p>其实这里的 pending 列表相当于一个<strong>栈</strong>，通过所用的 <code>pop()</code> 也能大概猜到，通过 <code>pop</code> 跟 <code>append</code> 实现出栈入栈操作，一层一层执行，最后再将栈给复原，进行下一次的探索。</p>
<p>这里我们还注意到，在嵌套执行开始前，还输出的一堆的 “original step is called！” ，这里其实是因为，angr要先将程序加载执行到我们通过初始状态构造函数所构造的状态，在这里是 <code>full_init_state()</code> 函数所定义的位置。可以通过在 <code>use_techniques()</code> 函数（位于angr&#x2F;sim_manager.py）中也添加打印输出信息的方法来验证：</p>
<p><img src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/image-20230918100557240.png" alt="image-20230918100557240"></p>
<p>其中，第一个与第二个 “use_technique is called!” 之间的 step 调用，是在应用 Tracer 的 setup 函数时调用的，此时还没进行 hook 操作。</p>
<p>到这里，基本上对于 “ angr 是如何将 exploration_techniques 应用到符号执行中的？” 这一个问题有了一个较为清晰的答案，就是通过嵌套执行的方式。对于angr是如何一步一步执行符号执行可以参考博客3。</p>
<p>我们再回到 <code>self._drill_input()</code> ，继续往下看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置对内存、寄存器符号化操作的阈值</span></span><br><span class="line">self._set_concretizations(simgr.one_active)</span><br><span class="line"></span><br><span class="line">l.debug(<span class="string">&quot;Drilling into %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line">l.debug(<span class="string">&quot;Input is %r.&quot;</span>, self.<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> simgr.active <span class="keyword">and</span> simgr.one_active.<span class="built_in">globals</span>[<span class="string">&#x27;trace_idx&#x27;</span>] &lt; <span class="built_in">len</span>(r.trace) - <span class="number">1</span>:</span><br><span class="line">    simgr.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check here to see if a crash has been found.</span></span><br><span class="line">    <span class="keyword">if</span> self.redis <span class="keyword">and</span> self.redis.sismember(self.identifier + <span class="string">&#x27;-finished&#x27;</span>, <span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># diverted 应该是发生状态转移</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;diverted&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> simgr.stashes:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 当检测到状态转移时,弹出状态 这里的diverted 是在DillerCore探索策略中的step方法中添加的</span></span><br><span class="line">    <span class="keyword">while</span> simgr.diverted:</span><br><span class="line">        state = simgr.diverted.pop(<span class="number">0</span>)</span><br><span class="line">        l.debug(<span class="string">&quot;Found a diverted state, exploring to some extent.&quot;</span>)</span><br><span class="line">        <span class="comment"># 首先调用_writeout来求解</span></span><br><span class="line">        w = self._writeout(state.history.bbl_addrs[-<span class="number">1</span>], state)</span><br><span class="line">        <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._symbolic_explorer_stub(state):</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>self._set_concretizations</code> 方法设置对内存、寄存器符号化操作的阈值，针对 cgc 程序单独做了优化，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set_concretizations</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> state.project.loader.main_object.os == <span class="string">&#x27;cgc&#x27;</span>:</span><br><span class="line">        flag_vars = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> state.cgc.flag_bytes:</span><br><span class="line">            flag_vars.update(b.variables)</span><br><span class="line">        state.unicorn.always_concretize.update(flag_vars)</span><br><span class="line">    <span class="comment"># Let&#x27;s put conservative thresholds（阈值） for now.</span></span><br><span class="line">    <span class="comment"># 设置了内存符号化的阈值。当符号状态中的内存符号化（例如，符号化的内存读取或写入操作）达到或超过 50000 个时，Unicorn 引擎将尝试将某些符号内存具体化为具体的值，以提高性能。</span></span><br><span class="line">    state.unicorn.concretization_threshold_memory = <span class="number">50000</span></span><br><span class="line">    <span class="comment"># 设置了寄存器符号化的阈值。当符号状态中的寄存器符号化（例如，符号化的寄存器读取或写入操作）达到或超过 50000 个时，Unicorn 引擎将尝试将某些符号寄存器具体化为具体的值，以提高性能。</span></span><br><span class="line">    state.unicorn.concretization_threshold_registers = <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>然后通过 <code>while</code> 判断循环条件，不断通过 <code>step()</code>  进行符号执行。这里说一下循环条件中的 <code>simgr.one_active.globals[&quot;trace_idx&quot;]</code> ，该变量定义在angr 探索技术 <code>Tracer()</code> 中的 <code>setup()</code> 函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># initialize the state info</span><br><span class="line">simgr.one_active.globals[&quot;trace_idx&quot;] = idx</span><br></pre></td></tr></table></figure>

<p>其中，idx 就代表执行路径 trace 的 index。</p>
<p>接下来，<code>self.redis</code> 应该是存储到 redis 数据库相关，暂时先不管。</p>
<p>再然后，判断 <code>simgr.stashes</code> 中存储的状态是否发生了转移，也就是是否有 <code>diverted</code> 。这里的 <code>diverted</code> 定义在 angr 探索技术 <code>DrillerCore()</code> 中的 <code>step()</code> 函数里。</p>
<p>如果检测到了 <code>diverted</code> 状态，将这个状态取出来，作为参数传递给 <code>self._writeout</code> 函数求解，如果求解成功，得到返回值 w，就调用 yield 语句返回，否则，调用 <code>self._symbolic_explorer_stub(state)</code> 函数来重新做符号执行求解并返回。</p>
<p>这里可以看到，最终 dirller 生成的 input 是通过 <code>self._writeout</code> 和 <code>self._symbolic_explorer_stub</code> 这两个函数来求解的。我们依次来看下这两个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里传入的参数是state.history.bbl_addrs[-1] 和 state</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_writeout</span>(<span class="params">self, prev_addr, state</span>):</span><br><span class="line">    <span class="comment"># 通过load方法从符号状态的标准输入state.posix.stdin中加载数据,具体来说，它加载从文件描述符 0（通常是标准输入）开始的数据，直到当前标准输入位置 state.posix.stdin.pos 处。这个操作实际上模拟了从标准输入读取数据的过程，并将读取的数据保存在 generated 变量中。</span></span><br><span class="line">    generated = state.posix.stdin.load(<span class="number">0</span>, state.posix.stdin.pos)</span><br><span class="line">    <span class="comment"># 调用 eval 执行求解过程，得到的结果存储在 generated 变量中 </span></span><br><span class="line">    generated = state.solver.<span class="built_in">eval</span>(generated, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    key = (<span class="built_in">len</span>(generated), prev_addr, state.addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Checks here to see if the generation is worth writing to disk.</span></span><br><span class="line">    <span class="comment"># If we generate too many inputs which are not really different we&#x27;ll seriously slow down AFL.</span></span><br><span class="line">    <span class="comment"># 调用_in_catalogue判断生成的input是否在之前的运行或者其他线程已经生成了，没有生成的话返回False</span></span><br><span class="line">    <span class="comment"># &lt;----跟redis相关，暂时不用管</span></span><br><span class="line">    <span class="keyword">if</span> self._in_catalogue(*key):</span><br><span class="line">        <span class="comment"># 如果生成了，那就从encounters中移除（addr，addr）？为什么要移除?</span></span><br><span class="line">        self._core.encounters.remove((prev_addr, state.addr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._add_to_catalogue(*key)</span><br><span class="line">    <span class="comment"># -----&gt;</span></span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] dumping input for %#x -&gt; %#x.&quot;</span>, self.identifier, prev_addr, state.addr)</span><br><span class="line">    <span class="comment"># 把本次生成的值 以（key，generated）的形式加入到_generated集合里</span></span><br><span class="line">    self._generated.add((key, generated))</span><br><span class="line">	<span class="comment"># &lt;-------redis 相关，暂时不管</span></span><br><span class="line">    <span class="keyword">if</span> self.redis:</span><br><span class="line">        <span class="comment"># Publish it out in real-time so that inputs get there immediately.</span></span><br><span class="line">        channel = self.identifier + <span class="string">&#x27;-generated&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.redis.publish(channel, pickle.dumps(&#123;<span class="string">&#x27;meta&#x27;</span>: key, <span class="string">&#x27;data&#x27;</span>: generated, <span class="string">&quot;tag&quot;</span>: self.tag&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l.debug(<span class="string">&quot;Generated: %s&quot;</span>, binascii.hexlify(generated))</span><br><span class="line">	<span class="comment">#--------&gt;</span></span><br><span class="line">    <span class="keyword">return</span> (key, generated)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_symbolic_explorer_stub</span>(<span class="params">self, state</span>):</span><br><span class="line">    <span class="comment"># Create a new simulation manager and step it forward up to 1024</span></span><br><span class="line">    <span class="comment"># accumulated active states or steps.</span></span><br><span class="line">    steps = <span class="number">0</span> <span class="comment"># 记录步数的计数器，用于限制探索的步数。</span></span><br><span class="line">    accumulated = <span class="number">1</span> <span class="comment"># 累积的活跃状态或步数的计数器，用于控制探索的终止条件。</span></span><br><span class="line"></span><br><span class="line">    p = state.project</span><br><span class="line">    state = state.copy() <span class="comment">#复制传入的状态 diverted，以便在符号执行过程中进行修改。</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 移除状态选项中的 LAZY_SOLVES 以确保在符号执行期间进行及时求解</span></span><br><span class="line">        state.options.remove(angr.options.LAZY_SOLVES)</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 创建状态管理器，用于符号执行，hierarchy=False 表示不使用层次结构模式（这里的层级结构还不是很清楚）。</span></span><br><span class="line">    simgr = p.factory.simulation_manager(state, hierarchy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] started symbolic exploration at %s.&quot;</span>, self.identifier, time.ctime())</span><br><span class="line">    <span class="comment"># 当还有活跃状态且累积计数小于 1024 时，进入循环。</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(simgr.active) <span class="keyword">and</span> accumulated &lt; <span class="number">1024</span>:</span><br><span class="line">        simgr.step() </span><br><span class="line">        steps += <span class="number">1</span> <span class="comment"># 增加步数计数器。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dump all inputs.</span></span><br><span class="line">        <span class="comment"># 根据步数和活跃状态数以及已结束状态数更新累积计数器。</span></span><br><span class="line">        accumulated = steps * (<span class="built_in">len</span>(simgr.active) + <span class="built_in">len</span>(simgr.deadended))</span><br><span class="line"></span><br><span class="line">    l.debug(<span class="string">&quot;[%s] stopped symbolic exploration at %s.&quot;</span>, self.identifier, time.ctime())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DO NOT think this is the same as using only the deadended stashes. this merges deadended and active</span></span><br><span class="line">    <span class="comment"># 将已经结束的状态合并到活跃状态中</span></span><br><span class="line">    simgr.stash(from_stash=<span class="string">&#x27;deadended&#x27;</span>, to_stash=<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">    <span class="comment"># 遍历所有的 active 状态</span></span><br><span class="line">    <span class="keyword">for</span> dumpable <span class="keyword">in</span> simgr.active:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 检查状态是否是可满足的。</span></span><br><span class="line">            <span class="keyword">if</span> dumpable.satisfiable():</span><br><span class="line">                <span class="comment"># 如果可满足就调用 _writeout 函数进行求解，然后通过 yield 返回</span></span><br><span class="line">                w = self._writeout(dumpable.history.bbl_addrs[-<span class="number">1</span>], dumpable)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the state we&#x27;re trying to dump wasn&#x27;t actually satisfiable.</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这里我对 <code>_symbolic_explorer_stub</code> 函数的理解是，边进行符号执行边做约束求解操作，这样就可以在符号执行 step 步进状态的同时直接判断出哪些状态是不可达的，即 deadended。不可达的路径就意味着新的分支，所以最后要把 deadended 与 active 合并，全部进行求解，这样能生成获得更多导致执行不同分支的 input ，从而可能增加 AFL 的代码覆盖率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇从整体程序的执行流程来分析 Driller 工具的功能，并针对 use_techniques 方法进行了较为详细的解释，理清了 angr 是如何同时应用多个 exploration_techniques 来协同进行符号执行的。但并未对每种探索技术中 hook 方法（比如，setup 和 step 函数等）进行详细的介绍，个人感觉这方面是理解 Driller 工具运作细节的重点。</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote>
<p>参考自博客：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://n132.github.io/2020/03/19/Driller.html">https://n132.github.io/2020/03/19/Driller.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/n132/n132.github.io/blob/master/_posts/2020-03-26-Driller2.md">https://github.com/n132/n132.github.io/blob/master/_posts/2020-03-26-Driller2.md</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/251983#h3-2">https://www.anquanke.com/post/id/251983#h3-2</a></p>
</li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/13/Ubuntu%E5%AE%89%E8%A3%85SSH/" rel="prev" title="Ubuntu安装SSH">
      <i class="fa fa-chevron-left"></i> Ubuntu安装SSH
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/20/Fuzz/AC15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9Eboofuzz%E6%B5%8B%E8%AF%95/" rel="next" title="AC15路由器栈溢出漏洞boofuzz测试">
      AC15路由器栈溢出漏洞boofuzz测试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Driller-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">Driller 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-run-driller-py-%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90"><span class="nav-number">1.1.</span> <span class="nav-text">0x01 run_driller.py 脚本分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-driller-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">0x02 driller 关键函数源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-%E6%A8%A1%E5%9D%97"><span class="nav-number">1.2.1.</span> <span class="nav-text">Tracer 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2"><span class="nav-number">1.3.</span> <span class="nav-text">参考博客</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭小白QAQ"
      src="https://guoxb.oss-cn-qingdao.aliyuncs.com/typora-imgs/202303122318253.jpg">
  <p class="site-author-name" itemprop="name">郭小白QAQ</p>
  <div class="site-description" itemprop="description">精彩不亮丽，起落是无常</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/guoxb0_0@qq.com" title="E-Mail → guoxb0_0@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭小白QAQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">105k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
